"use strict";
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.telemetrySubmitterFactory = exports.telemetryCacheConfigAdapter = exports.getTelemetryConfigStats = exports.telemetryCacheStatsAdapter = void 0;
var submitter_1 = require("./submitter");
var constants_1 = require("../../utils/constants");
var constants_2 = require("../../readiness/constants");
var settingsValidation_1 = require("../../utils/settingsValidation");
var apiKey_1 = require("../../utils/inputValidation/apiKey");
var timer_1 = require("../../utils/timeTracker/timer");
var objectAssign_1 = require("../../utils/lang/objectAssign");
/**
 * Converts data from telemetry cache into /metrics/usage request payload.
 */
function telemetryCacheStatsAdapter(telemetry, splits, segments) {
    return {
        isEmpty: function () { return false; },
        clear: function () { },
        // @TODO consider moving inside telemetry cache for code size reduction
        state: function () {
            return {
                lS: telemetry.getLastSynchronization(),
                mL: telemetry.popLatencies(),
                mE: telemetry.popExceptions(),
                hE: telemetry.popHttpErrors(),
                hL: telemetry.popHttpLatencies(),
                tR: telemetry.popTokenRefreshes(),
                aR: telemetry.popAuthRejections(),
                iQ: telemetry.getImpressionStats(constants_1.QUEUED),
                iDe: telemetry.getImpressionStats(constants_1.DEDUPED),
                iDr: telemetry.getImpressionStats(constants_1.DROPPED),
                spC: splits.getSplitNames().length,
                seC: segments.getRegisteredSegments().length,
                skC: segments.getKeysCount(),
                sL: telemetry.getSessionLength(),
                eQ: telemetry.getEventStats(constants_1.QUEUED),
                eD: telemetry.getEventStats(constants_1.DROPPED),
                sE: telemetry.popStreamingEvents(),
                t: telemetry.popTags(),
            };
        }
    };
}
exports.telemetryCacheStatsAdapter = telemetryCacheStatsAdapter;
var OPERATION_MODE_MAP = (_a = {},
    _a[constants_1.STANDALONE_MODE] = constants_1.STANDALONE_ENUM,
    _a[constants_1.CONSUMER_MODE] = constants_1.CONSUMER_ENUM,
    _a[constants_1.CONSUMER_PARTIAL_MODE] = constants_1.CONSUMER_PARTIAL_ENUM,
    _a);
var IMPRESSIONS_MODE_MAP = (_b = {},
    _b[constants_1.OPTIMIZED] = constants_1.OPTIMIZED_ENUM,
    _b[constants_1.DEBUG] = constants_1.DEBUG_ENUM,
    _b);
var USER_CONSENT_MAP = (_c = {},
    _c[constants_1.CONSENT_UNKNOWN] = 1,
    _c[constants_1.CONSENT_GRANTED] = 2,
    _c[constants_1.CONSENT_DECLINED] = 3,
    _c);
function getActiveFactories() {
    return Object.keys(apiKey_1.usedKeysMap).length;
}
function getRedundantActiveFactories() {
    return Object.keys(apiKey_1.usedKeysMap).reduce(function (acum, apiKey) {
        return acum + apiKey_1.usedKeysMap[apiKey] - 1;
    }, 0);
}
function getTelemetryConfigStats(mode, storageType) {
    return {
        oM: OPERATION_MODE_MAP[mode],
        st: storageType.toLowerCase(),
        aF: getActiveFactories(),
        rF: getRedundantActiveFactories(),
    };
}
exports.getTelemetryConfigStats = getTelemetryConfigStats;
/**
 * Converts data from telemetry cache and settings into /metrics/config request payload.
 */
function telemetryCacheConfigAdapter(telemetry, settings) {
    return {
        isEmpty: function () { return false; },
        clear: function () { },
        state: function () {
            var urls = settings.urls, scheduler = settings.scheduler;
            var isClientSide = settings.core.key !== undefined;
            return (0, objectAssign_1.objectAssign)(getTelemetryConfigStats(settings.mode, settings.storage.type), {
                sE: settings.streamingEnabled,
                rR: {
                    sp: scheduler.featuresRefreshRate / 1000,
                    se: isClientSide ? undefined : scheduler.segmentsRefreshRate / 1000,
                    ms: isClientSide ? scheduler.segmentsRefreshRate / 1000 : undefined,
                    im: scheduler.impressionsRefreshRate / 1000,
                    ev: scheduler.eventsPushRate / 1000,
                    te: scheduler.telemetryRefreshRate / 1000,
                },
                uO: {
                    s: urls.sdk !== settingsValidation_1.base.urls.sdk,
                    e: urls.events !== settingsValidation_1.base.urls.events,
                    a: urls.auth !== settingsValidation_1.base.urls.auth,
                    st: urls.streaming !== settingsValidation_1.base.urls.streaming,
                    t: urls.telemetry !== settingsValidation_1.base.urls.telemetry,
                },
                iQ: scheduler.impressionsQueueSize,
                eQ: scheduler.eventsQueueSize,
                iM: IMPRESSIONS_MODE_MAP[settings.sync.impressionsMode],
                iL: settings.impressionListener ? true : false,
                hP: false,
                tR: telemetry.getTimeUntilReady(),
                tC: telemetry.getTimeUntilReadyFromCache(),
                nR: telemetry.getNonReadyUsage(),
                t: telemetry.popTags(),
                i: settings.integrations && settings.integrations.map(function (int) { return int.type; }),
                uC: settings.userConsent ? USER_CONSENT_MAP[settings.userConsent] : 0
            });
        }
    };
}
exports.telemetryCacheConfigAdapter = telemetryCacheConfigAdapter;
/**
 * Submitter that periodically posts telemetry data
 */
function telemetrySubmitterFactory(params) {
    var _a = params.storage, splits = _a.splits, segments = _a.segments, telemetry = _a.telemetry, now = params.platform.now;
    if (!telemetry || !now)
        return; // No submitter created if telemetry cache is not defined
    var settings = params.settings, _b = params.settings, log = _b.log, telemetryRefreshRate = _b.scheduler.telemetryRefreshRate, splitApi = params.splitApi, readiness = params.readiness, sdkReadinessManager = params.sdkReadinessManager;
    var startTime = (0, timer_1.timer)(now);
    var submitter = (0, submitter_1.firstPushWindowDecorator)((0, submitter_1.submitterFactory)(log, splitApi.postMetricsUsage, telemetryCacheStatsAdapter(telemetry, splits, segments), telemetryRefreshRate, 'telemetry stats', undefined, 0, true), telemetryRefreshRate);
    readiness.gate.once(constants_2.SDK_READY_FROM_CACHE, function () {
        telemetry.recordTimeUntilReadyFromCache(startTime());
    });
    sdkReadinessManager.incInternalReadyCbCount();
    readiness.gate.once(constants_2.SDK_READY, function () {
        telemetry.recordTimeUntilReady(startTime());
        // Post config data when the SDK is ready and if the telemetry submitter was started
        if (submitter.isRunning()) {
            var postMetricsConfigTask = (0, submitter_1.submitterFactory)(log, splitApi.postMetricsConfig, telemetryCacheConfigAdapter(telemetry, settings), 0, 'telemetry config', undefined, 0, true);
            postMetricsConfigTask.execute();
        }
    });
    return submitter;
}
exports.telemetrySubmitterFactory = telemetrySubmitterFactory;
