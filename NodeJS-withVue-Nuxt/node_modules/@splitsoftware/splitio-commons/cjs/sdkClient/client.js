"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clientFactory = void 0;
var evaluator_1 = require("../evaluator");
var thenable_1 = require("../utils/promise/thenable");
var key_1 = require("../utils/key");
var splitExistance_1 = require("../utils/inputValidation/splitExistance");
var trafficTypeExistance_1 = require("../utils/inputValidation/trafficTypeExistance");
var labels_1 = require("../utils/labels");
var constants_1 = require("../utils/constants");
var constants_2 = require("../logger/constants");
/**
 * Creator of base client with getTreatments and track methods.
 */
function clientFactory(params) {
    var readinessManager = params.sdkReadinessManager.readinessManager, storage = params.storage, settings = params.settings, impressionsTracker = params.impressionsTracker, eventTracker = params.eventTracker, telemetryTracker = params.telemetryTracker;
    var log = settings.log, mode = settings.mode;
    function getTreatment(key, splitName, attributes, withConfig) {
        if (withConfig === void 0) { withConfig = false; }
        var stopTelemetryTracker = telemetryTracker.trackEval(withConfig ? constants_1.TREATMENT_WITH_CONFIG : constants_1.TREATMENT);
        var wrapUp = function (evaluationResult) {
            var queue = [];
            var treatment = processEvaluation(evaluationResult, splitName, key, attributes, withConfig, "getTreatment" + (withConfig ? 'withConfig' : ''), queue);
            impressionsTracker.track(queue, attributes);
            stopTelemetryTracker(queue[0] && queue[0].label);
            return treatment;
        };
        var evaluation = (0, evaluator_1.evaluateFeature)(log, key, splitName, attributes, storage);
        return (0, thenable_1.thenable)(evaluation) ? evaluation.then(function (res) { return wrapUp(res); }) : wrapUp(evaluation);
    }
    function getTreatmentWithConfig(key, splitName, attributes) {
        return getTreatment(key, splitName, attributes, true);
    }
    function getTreatments(key, splitNames, attributes, withConfig) {
        if (withConfig === void 0) { withConfig = false; }
        var stopTelemetryTracker = telemetryTracker.trackEval(withConfig ? constants_1.TREATMENTS_WITH_CONFIG : constants_1.TREATMENTS);
        var wrapUp = function (evaluationResults) {
            var queue = [];
            var treatments = {};
            Object.keys(evaluationResults).forEach(function (splitName) {
                treatments[splitName] = processEvaluation(evaluationResults[splitName], splitName, key, attributes, withConfig, "getTreatments" + (withConfig ? 'withConfig' : ''), queue);
            });
            impressionsTracker.track(queue, attributes);
            stopTelemetryTracker(queue[0] && queue[0].label);
            return treatments;
        };
        var evaluations = (0, evaluator_1.evaluateFeatures)(log, key, splitNames, attributes, storage);
        return (0, thenable_1.thenable)(evaluations) ? evaluations.then(function (res) { return wrapUp(res); }) : wrapUp(evaluations);
    }
    function getTreatmentsWithConfig(key, splitNames, attributes) {
        return getTreatments(key, splitNames, attributes, true);
    }
    // Internal function
    function processEvaluation(evaluation, splitName, key, attributes, withConfig, invokingMethodName, queue) {
        var isSdkReady = readinessManager.isReady() || readinessManager.isReadyFromCache();
        var matchingKey = (0, key_1.getMatching)(key);
        var bucketingKey = (0, key_1.getBucketing)(key);
        // If the SDK was not ready, treatment may be incorrect due to having Splits but not segments data.
        if (!isSdkReady) {
            evaluation = { treatment: constants_1.CONTROL, label: labels_1.SDK_NOT_READY };
        }
        var treatment = evaluation.treatment, label = evaluation.label, changeNumber = evaluation.changeNumber, _a = evaluation.config, config = _a === void 0 ? null : _a;
        log.info(constants_2.IMPRESSION, [splitName, matchingKey, treatment, label]);
        if ((0, splitExistance_1.validateSplitExistance)(log, readinessManager, splitName, label, invokingMethodName)) {
            log.info(constants_2.IMPRESSION_QUEUEING);
            queue.push({
                feature: splitName,
                keyName: matchingKey,
                treatment: treatment,
                time: Date.now(),
                bucketingKey: bucketingKey,
                label: label,
                changeNumber: changeNumber
            });
        }
        if (withConfig) {
            return {
                treatment: treatment,
                config: config
            };
        }
        return treatment;
    }
    function track(key, trafficTypeName, eventTypeId, value, properties, size) {
        if (size === void 0) { size = 1024; }
        var stopTelemetryTracker = telemetryTracker.trackEval(constants_1.TRACK);
        var matchingKey = (0, key_1.getMatching)(key);
        var timestamp = Date.now();
        var eventData = {
            eventTypeId: eventTypeId,
            trafficTypeName: trafficTypeName,
            value: value,
            timestamp: timestamp,
            key: matchingKey,
            properties: properties
        };
        // This may be async but we only warn, we don't actually care if it is valid or not in terms of queueing the event.
        (0, trafficTypeExistance_1.validateTrafficTypeExistance)(log, readinessManager, storage.splits, mode, trafficTypeName, 'track');
        var result = eventTracker.track(eventData, size);
        if ((0, thenable_1.thenable)(result)) {
            return result.then(function (result) {
                stopTelemetryTracker();
                return result;
            });
        }
        else {
            stopTelemetryTracker();
            return result;
        }
    }
    return {
        getTreatment: getTreatment,
        getTreatmentWithConfig: getTreatmentWithConfig,
        getTreatments: getTreatments,
        getTreatmentsWithConfig: getTreatmentsWithConfig,
        track: track,
        isClientSide: false
    };
}
exports.clientFactory = clientFactory;
