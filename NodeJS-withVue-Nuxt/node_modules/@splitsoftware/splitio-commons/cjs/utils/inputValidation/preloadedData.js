"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePreloadedData = void 0;
var lang_1 = require("../lang");
var split_1 = require("./split");
function validateTimestampData(log, maybeTimestamp, method, item) {
    if ((0, lang_1.isFiniteNumber)(maybeTimestamp) && maybeTimestamp > -1)
        return true;
    log.error(method + ": preloadedData." + item + " must be a positive number.");
    return false;
}
function validateSplitsData(log, maybeSplitsData, method) {
    if ((0, lang_1.isObject)(maybeSplitsData)) {
        var splitNames = Object.keys(maybeSplitsData);
        if (splitNames.length === 0)
            log.warn(method + ": preloadedData.splitsData doesn't contain split definitions.");
        // @TODO in the future, consider handling the possibility of having parsed definitions of splits
        if (splitNames.every(function (splitName) { return (0, split_1.validateSplit)(log, splitName, method) && (0, lang_1.isString)(maybeSplitsData[splitName]); }))
            return true;
    }
    log.error(method + ": preloadedData.splitsData must be a map of split names to their serialized definitions.");
    return false;
}
function validateMySegmentsData(log, maybeMySegmentsData, method) {
    if ((0, lang_1.isObject)(maybeMySegmentsData)) {
        var userKeys = Object.keys(maybeMySegmentsData);
        if (userKeys.every(function (userKey) {
            var segmentNames = maybeMySegmentsData[userKey];
            // an empty list is valid
            return Array.isArray(segmentNames) && segmentNames.every(function (segmentName) { return (0, lang_1.isString)(segmentName); });
        }))
            return true;
    }
    log.error(method + ": preloadedData.mySegmentsData must be a map of user keys to their list of segment names.");
    return false;
}
function validateSegmentsData(log, maybeSegmentsData, method) {
    if ((0, lang_1.isObject)(maybeSegmentsData)) {
        var segmentNames = Object.keys(maybeSegmentsData);
        if (segmentNames.every(function (segmentName) { return (0, lang_1.isString)(maybeSegmentsData[segmentName]); }))
            return true;
    }
    log.error(method + ": preloadedData.segmentsData must be a map of segment names to their serialized definitions.");
    return false;
}
function validatePreloadedData(log, maybePreloadedData, method) {
    if (!(0, lang_1.isObject)(maybePreloadedData)) {
        log.error(method + ": preloadedData must be an object.");
    }
    else if (validateTimestampData(log, maybePreloadedData.lastUpdated, method, 'lastUpdated') &&
        validateTimestampData(log, maybePreloadedData.since, method, 'since') &&
        validateSplitsData(log, maybePreloadedData.splitsData, method) &&
        (!maybePreloadedData.mySegmentsData || validateMySegmentsData(log, maybePreloadedData.mySegmentsData, method)) &&
        (!maybePreloadedData.segmentsData || validateSegmentsData(log, maybePreloadedData.segmentsData, method))) {
        return true;
    }
    return false;
}
exports.validatePreloadedData = validatePreloadedData;
