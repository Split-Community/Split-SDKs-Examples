"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchersTransform = void 0;
var lang_1 = require("../../utils/lang");
var matcherTypes_1 = require("../matchers/matcherTypes");
var segment_1 = require("./segment");
var whitelist_1 = require("./whitelist");
var set_1 = require("./set");
var unaryNumeric_1 = require("./unaryNumeric");
var convertions_1 = require("../convertions");
/**
 * Flat the complex matcherGroup structure into something handy.
 */
function matchersTransform(matchers) {
    var parsedMatchers = matchers.map(function (matcher) {
        var matcherType = matcher.matcherType /* string */, negate = matcher.negate /* boolean */, keySelector = matcher.keySelector /* keySelectorObject */, segmentObject = matcher.userDefinedSegmentMatcherData /* segmentObject */, whitelistObject = matcher.whitelistMatcherData /* whiteListObject, provided by 'WHITELIST', set and string matchers */, unaryNumericObject = matcher.unaryNumericMatcherData /* unaryNumericObject */, betweenObject = matcher.betweenMatcherData /* betweenObject */, dependencyObject = matcher.dependencyMatcherData /* dependencyObject */, booleanMatcherData = matcher.booleanMatcherData, stringMatcherData = matcher.stringMatcherData;
        var attribute = keySelector && keySelector.attribute;
        var type = (0, matcherTypes_1.matcherTypesMapper)(matcherType);
        // As default input data type we use string (even for ALL_KEYS)
        var dataType = matcherTypes_1.matcherDataTypes.STRING;
        var value = undefined;
        if (type === matcherTypes_1.matcherTypes.IN_SEGMENT) {
            value = (0, segment_1.segmentTransform)(segmentObject);
        }
        else if (type === matcherTypes_1.matcherTypes.WHITELIST) {
            value = (0, whitelist_1.whitelistTransform)(whitelistObject);
        }
        else if (type === matcherTypes_1.matcherTypes.EQUAL_TO) {
            value = (0, unaryNumeric_1.numericTransform)(unaryNumericObject);
            dataType = matcherTypes_1.matcherDataTypes.NUMBER;
            if (unaryNumericObject.dataType === 'DATETIME') {
                value = (0, convertions_1.zeroSinceHH)(value);
                dataType = matcherTypes_1.matcherDataTypes.DATETIME;
            }
        }
        else if (type === matcherTypes_1.matcherTypes.GREATER_THAN_OR_EQUAL_TO ||
            type === matcherTypes_1.matcherTypes.LESS_THAN_OR_EQUAL_TO) {
            value = (0, unaryNumeric_1.numericTransform)(unaryNumericObject);
            dataType = matcherTypes_1.matcherDataTypes.NUMBER;
            if (unaryNumericObject.dataType === 'DATETIME') {
                value = (0, convertions_1.zeroSinceSS)(value);
                dataType = matcherTypes_1.matcherDataTypes.DATETIME;
            }
        }
        else if (type === matcherTypes_1.matcherTypes.BETWEEN) {
            value = betweenObject;
            dataType = matcherTypes_1.matcherDataTypes.NUMBER;
            if (value.dataType === 'DATETIME') {
                value.start = (0, convertions_1.zeroSinceSS)(value.start);
                value.end = (0, convertions_1.zeroSinceSS)(value.end);
                dataType = matcherTypes_1.matcherDataTypes.DATETIME;
            }
        }
        else if (type === matcherTypes_1.matcherTypes.EQUAL_TO_SET ||
            type === matcherTypes_1.matcherTypes.CONTAINS_ANY_OF_SET ||
            type === matcherTypes_1.matcherTypes.CONTAINS_ALL_OF_SET ||
            type === matcherTypes_1.matcherTypes.PART_OF_SET) {
            value = (0, set_1.setTransform)(whitelistObject);
            dataType = matcherTypes_1.matcherDataTypes.SET;
        }
        else if (type === matcherTypes_1.matcherTypes.STARTS_WITH ||
            type === matcherTypes_1.matcherTypes.ENDS_WITH ||
            type === matcherTypes_1.matcherTypes.CONTAINS_STRING) {
            value = (0, set_1.setTransform)(whitelistObject);
        }
        else if (type === matcherTypes_1.matcherTypes.IN_SPLIT_TREATMENT) {
            value = dependencyObject;
            dataType = matcherTypes_1.matcherDataTypes.NOT_SPECIFIED;
        }
        else if (type === matcherTypes_1.matcherTypes.EQUAL_TO_BOOLEAN) {
            dataType = matcherTypes_1.matcherDataTypes.BOOLEAN;
            value = booleanMatcherData;
        }
        else if (type === matcherTypes_1.matcherTypes.MATCHES_STRING) {
            value = stringMatcherData;
        }
        return {
            attribute: attribute,
            negate: negate,
            type: type,
            value: value,
            dataType: dataType // runtime input data type
        };
    });
    if ((0, lang_1.findIndex)(parsedMatchers, function (m) { return m.type === matcherTypes_1.matcherTypes.UNDEFINED; }) === -1) {
        return parsedMatchers;
    }
    else {
        return [];
    }
}
exports.matchersTransform = matchersTransform;
