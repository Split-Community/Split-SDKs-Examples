"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Engine = void 0;
var tslib_1 = require("tslib");
var lang_1 = require("../utils/lang");
var parser_1 = require("./parser");
var key_1 = require("../utils/key");
var thenable_1 = require("../utils/promise/thenable");
var LabelsConstants = (0, tslib_1.__importStar)(require("../utils/labels"));
var constants_1 = require("../utils/constants");
function evaluationResult(result, defaultTreatment) {
    return {
        treatment: (0, lang_1.get)(result, 'treatment', defaultTreatment),
        label: (0, lang_1.get)(result, 'label', LabelsConstants.NO_CONDITION_MATCH)
    };
}
var Engine = /** @class */ (function () {
    function Engine(baseInfo, evaluator) {
        this.baseInfo = baseInfo;
        this.evaluator = evaluator;
        // in case we don't have a default treatment in the instanciation, use 'control'
        if (typeof this.baseInfo.defaultTreatment !== 'string') {
            this.baseInfo.defaultTreatment = constants_1.CONTROL;
        }
    }
    Engine.parse = function (log, splitFlatStructure, storage) {
        var conditions = splitFlatStructure.conditions;
        var evaluator = (0, parser_1.parser)(log, conditions, storage);
        return new Engine(splitFlatStructure, evaluator);
    };
    Engine.prototype.getKey = function () {
        return this.baseInfo.name;
    };
    Engine.prototype.getTreatment = function (key, attributes, splitEvaluator) {
        var _a = this.baseInfo, killed = _a.killed, seed = _a.seed, defaultTreatment = _a.defaultTreatment, trafficAllocation = _a.trafficAllocation, trafficAllocationSeed = _a.trafficAllocationSeed;
        var parsedKey;
        var treatment;
        var label;
        try {
            parsedKey = (0, key_1.keyParser)(key);
        }
        catch (err) {
            return {
                treatment: constants_1.CONTROL,
                label: LabelsConstants.EXCEPTION
            };
        }
        if (this.isGarbage()) {
            treatment = constants_1.CONTROL;
            label = LabelsConstants.SPLIT_ARCHIVED;
        }
        else if (killed) {
            treatment = defaultTreatment;
            label = LabelsConstants.SPLIT_KILLED;
        }
        else {
            var evaluation = this.evaluator(parsedKey, seed, trafficAllocation, trafficAllocationSeed, attributes, splitEvaluator);
            // Evaluation could be async, so we should handle that case checking for a
            // thenable object
            if ((0, thenable_1.thenable)(evaluation)) {
                return evaluation.then(function (result) { return evaluationResult(result, defaultTreatment); });
            }
            else {
                return evaluationResult(evaluation, defaultTreatment);
            }
        }
        return {
            treatment: treatment,
            label: label
        };
    };
    Engine.prototype.isGarbage = function () {
        return this.baseInfo.status === 'ARCHIVED';
    };
    Engine.prototype.getChangeNumber = function () {
        return this.baseInfo.changeNumber;
    };
    return Engine;
}());
exports.Engine = Engine;
