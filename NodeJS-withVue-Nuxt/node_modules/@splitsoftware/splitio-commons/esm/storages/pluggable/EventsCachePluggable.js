import { LOG_PREFIX } from './constants';
var EventsCachePluggable = /** @class */ (function () {
    function EventsCachePluggable(log, key, wrapper, metadata) {
        this.log = log;
        this.key = key;
        this.wrapper = wrapper;
        this.metadata = metadata;
    }
    /**
     * Push given event to the storage.
     * @param eventData  Event item to push.
     * @returns  A promise that is resolved with a boolean value indicating if the push operation succeeded or failed.
     * Unlike `impressions::track`, The promise will never be rejected.
     */
    EventsCachePluggable.prototype.track = function (eventData) {
        var _this = this;
        return this.wrapper.pushItems(this.key, [this._toJSON(eventData)])
            // We use boolean values to signal successful queueing
            .then(function () { return true; })
            .catch(function (e) {
            _this.log.error(LOG_PREFIX + "Error adding event to queue: " + e + ".");
            return false;
        });
    };
    EventsCachePluggable.prototype._toJSON = function (eventData) {
        return JSON.stringify({
            m: this.metadata,
            e: eventData
        });
    };
    /**
     * Returns a promise that resolves with the count of stored events, or 0 if there was some error.
     * The promise will never be rejected.
     */
    EventsCachePluggable.prototype.count = function () {
        return this.wrapper.getItemsCount(this.key).catch(function () { return 0; });
    };
    /**
     * Removes the given number of events from the store. If a number is not provided, it deletes all items.
     * The returned promise rejects if the wrapper operation fails.
     */
    EventsCachePluggable.prototype.drop = function (count) {
        if (!count)
            return this.wrapper.del(this.key);
        return this.wrapper.popItems(this.key, count).then(function () { });
    };
    /**
     * Pop the given number of events from the storage.
     * The returned promise rejects if the wrapper operation fails.
     *
     * NOTE: this method doesn't take into account MAX_EVENT_SIZE or MAX_QUEUE_BYTE_SIZE limits.
     * It is the submitter responsability to handle that.
     */
    EventsCachePluggable.prototype.popNWithMetadata = function (count) {
        return this.wrapper.popItems(this.key, count).then(function (items) {
            return items.map(function (item) { return JSON.parse(item); });
        });
    };
    return EventsCachePluggable;
}());
export { EventsCachePluggable };
