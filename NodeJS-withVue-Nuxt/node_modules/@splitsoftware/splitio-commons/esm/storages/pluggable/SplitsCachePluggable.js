import { __extends } from "tslib";
import { isFiniteNumber, isNaNNumber } from '../../utils/lang';
import { LOG_PREFIX } from './constants';
import { AbstractSplitsCacheAsync } from '../AbstractSplitsCacheAsync';
/**
 * ISplitsCacheAsync implementation for pluggable storages.
 */
var SplitsCachePluggable = /** @class */ (function (_super) {
    __extends(SplitsCachePluggable, _super);
    /**
     * Create a SplitsCache that uses a storage wrapper.
     * @param log  Logger instance.
     * @param keys  Key builder.
     * @param wrapper  Adapted wrapper storage.
     */
    function SplitsCachePluggable(log, keys, wrapper) {
        var _this = _super.call(this) || this;
        _this.log = log;
        _this.keys = keys;
        _this.wrapper = wrapper;
        return _this;
    }
    SplitsCachePluggable.prototype._decrementCounts = function (split) {
        var _this = this;
        if (split.trafficTypeName) {
            var ttKey_1 = this.keys.buildTrafficTypeKey(split.trafficTypeName);
            return this.wrapper.decr(ttKey_1).then(function (count) {
                if (count === 0)
                    return _this.wrapper.del(ttKey_1);
            });
        }
    };
    SplitsCachePluggable.prototype._incrementCounts = function (split) {
        if (split.trafficTypeName) {
            var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);
            return this.wrapper.incr(ttKey);
        }
    };
    /**
     * Add a given split.
     * The returned promise is resolved when the operation success
     * or rejected if it fails (e.g., wrapper operation fails)
     */
    SplitsCachePluggable.prototype.addSplit = function (name, split) {
        var _this = this;
        var splitKey = this.keys.buildSplitKey(name);
        return this.wrapper.get(splitKey).then(function (splitFromStorage) {
            // handling parsing error
            var parsedPreviousSplit, parsedSplit;
            try {
                parsedPreviousSplit = splitFromStorage ? JSON.parse(splitFromStorage) : undefined;
                parsedSplit = JSON.parse(split);
            }
            catch (e) {
                throw new Error('Error parsing split definition: ' + e);
            }
            return Promise.all([
                _this.wrapper.set(splitKey, split),
                _this._incrementCounts(parsedSplit),
                // If it's an update, we decrement the traffic type and segment count of the existing split,
                parsedPreviousSplit && _this._decrementCounts(parsedPreviousSplit)
            ]);
        }).then(function () { return true; });
    };
    /**
     * Add a list of splits.
     * The returned promise is resolved when the operation success
     * or rejected if it fails (e.g., wrapper operation fails)
     */
    SplitsCachePluggable.prototype.addSplits = function (entries) {
        var _this = this;
        return Promise.all(entries.map(function (keyValuePair) { return _this.addSplit(keyValuePair[0], keyValuePair[1]); }));
    };
    /**
     * Remove a given split.
     * The returned promise is resolved when the operation success, with a boolean indicating if the split existed or not.
     * or rejected if it fails (e.g., wrapper operation fails).
     */
    SplitsCachePluggable.prototype.removeSplit = function (name) {
        var _this = this;
        return this.getSplit(name).then(function (split) {
            if (split) {
                var parsedSplit = JSON.parse(split);
                _this._decrementCounts(parsedSplit);
            }
            return _this.wrapper.del(_this.keys.buildSplitKey(name));
        });
    };
    /**
     * Remove a list of splits.
     * The returned promise is resolved when the operation success, with a boolean array indicating if the splits existed or not.
     * or rejected if it fails (e.g., wrapper operation fails).
     */
    SplitsCachePluggable.prototype.removeSplits = function (names) {
        var _this = this;
        return Promise.all(names.map(function (name) { return _this.removeSplit(name); }));
    };
    /**
     * Get split.
     * The returned promise is resolved with the split definition or null if it's not defined,
     * or rejected if wrapper operation fails.
     */
    SplitsCachePluggable.prototype.getSplit = function (name) {
        return this.wrapper.get(this.keys.buildSplitKey(name));
    };
    /**
     * Get list of splits.
     * The returned promise is resolved with a map of split names to their split definition or null if it's not defined,
     * or rejected if wrapper operation fails.
     */
    SplitsCachePluggable.prototype.getSplits = function (names) {
        var _this = this;
        var keys = names.map(function (name) { return _this.keys.buildSplitKey(name); });
        return this.wrapper.getMany(keys).then(function (splitDefinitions) {
            var splits = {};
            names.forEach(function (name, idx) {
                splits[name] = splitDefinitions[idx];
            });
            return Promise.resolve(splits);
        });
    };
    /**
     * Get list of all split definitions.
     * The returned promise is resolved with the list of split definitions,
     * or rejected if wrapper operation fails.
     */
    SplitsCachePluggable.prototype.getAll = function () {
        var _this = this;
        return this.wrapper.getKeysByPrefix(this.keys.buildSplitKeyPrefix()).then(function (listOfKeys) { return Promise.all(listOfKeys.map(_this.wrapper.get)); });
    };
    /**
     * Get list of split names.
     * The returned promise is resolved with the list of split names,
     * or rejected if wrapper operation fails.
     */
    SplitsCachePluggable.prototype.getSplitNames = function () {
        var _this = this;
        return this.wrapper.getKeysByPrefix(this.keys.buildSplitKeyPrefix()).then(function (listOfKeys) { return listOfKeys.map(_this.keys.extractKey); });
    };
    /**
     * Check traffic type existence.
     * The returned promise is resolved with a boolean indicating whether the TT exist or not.
     * In case of wrapper operation failures, the promise resolves with a true value, assuming that the TT might exist.
     * It will never be rejected.
     */
    SplitsCachePluggable.prototype.trafficTypeExists = function (trafficType) {
        var _this = this;
        // If there is a number there should be > 0, otherwise the TT is considered as not existent.
        return this.wrapper.get(this.keys.buildTrafficTypeKey(trafficType))
            .then(function (ttCount) {
            if (ttCount === null)
                return false; // if entry doesn't exist, means that TT doesn't exist
            ttCount = parseInt(ttCount, 10);
            if (!isFiniteNumber(ttCount) || ttCount < 0) {
                _this.log.info(LOG_PREFIX + ("Could not validate traffic type existence of " + trafficType + " due to data corruption of some sorts."));
                return false;
            }
            return ttCount > 0;
        }).catch(function (e) {
            _this.log.error(LOG_PREFIX + ("Could not validate traffic type existence of " + trafficType + " due to an error: " + e + "."));
            // If there is an error, bypass the validation so the event can get tracked.
            return true;
        });
    };
    /**
     * Set till number.
     * The returned promise is resolved when the operation success,
     * or rejected if it fails (e.g., wrapper operation fails).
     */
    SplitsCachePluggable.prototype.setChangeNumber = function (changeNumber) {
        return this.wrapper.set(this.keys.buildSplitsTillKey(), changeNumber + '');
    };
    /**
     * Get till number or -1 if it's not defined.
     * The returned promise is resolved with the changeNumber or -1 if it doesn't exist or a wrapper operation fails.
     * The promise will never be rejected.
     */
    SplitsCachePluggable.prototype.getChangeNumber = function () {
        var _this = this;
        return this.wrapper.get(this.keys.buildSplitsTillKey()).then(function (value) {
            var i = parseInt(value, 10);
            return isNaNNumber(i) ? -1 : i;
        }).catch(function (e) {
            _this.log.error(LOG_PREFIX + 'Could not retrieve changeNumber from storage. Error: ' + e);
            return -1;
        });
    };
    // @TODO implement if required by DataLoader or producer mode
    SplitsCachePluggable.prototype.clear = function () {
        return Promise.resolve(true);
    };
    return SplitsCachePluggable;
}(AbstractSplitsCacheAsync));
export { SplitsCachePluggable };
