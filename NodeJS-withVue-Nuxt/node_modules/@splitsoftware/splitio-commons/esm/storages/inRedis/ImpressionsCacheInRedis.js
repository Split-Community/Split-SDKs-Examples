var IMPRESSIONS_TTL_REFRESH = 3600; // 1 hr
var ImpressionsCacheInRedis = /** @class */ (function () {
    function ImpressionsCacheInRedis(log, key, redis, metadata) {
        this.log = log;
        this.key = key;
        this.redis = redis;
        this.metadata = metadata;
    }
    ImpressionsCacheInRedis.prototype.track = function (impressions) {
        var _this = this;
        return this.redis.rpush(this.key, this._toJSON(impressions)).then(function (queuedCount) {
            // If this is the creation of the key on Redis, set the expiration for it in 1hr.
            if (queuedCount === impressions.length) {
                return _this.redis.expire(_this.key, IMPRESSIONS_TTL_REFRESH);
            }
        });
    };
    ImpressionsCacheInRedis.prototype._toJSON = function (impressions) {
        var _this = this;
        return impressions.map(function (impression) {
            var keyName = impression.keyName, bucketingKey = impression.bucketingKey, feature = impression.feature, treatment = impression.treatment, label = impression.label, time = impression.time, changeNumber = impression.changeNumber;
            return JSON.stringify({
                m: _this.metadata,
                i: {
                    k: keyName,
                    b: bucketingKey,
                    f: feature,
                    t: treatment,
                    r: label,
                    c: changeNumber,
                    m: time
                }
            });
        });
    };
    ImpressionsCacheInRedis.prototype.count = function () {
        return this.redis.llen(this.key).catch(function () { return 0; });
    };
    ImpressionsCacheInRedis.prototype.drop = function (count) {
        if (!count)
            return this.redis.del(this.key);
        return this.redis.ltrim(this.key, count, -1);
    };
    ImpressionsCacheInRedis.prototype.popNWithMetadata = function (count) {
        var _this = this;
        return this.redis.lrange(this.key, 0, count - 1).then(function (items) {
            return _this.redis.ltrim(_this.key, items.length, -1).then(function () {
                // This operation will simply do nothing if the key no longer exists (queue is empty)
                // It's only done in the "successful" exit path so that the TTL is not overriden if impressons weren't
                // popped correctly. This will result in impressions getting lost but will prevent the queue from taking
                // a huge amount of memory.
                _this.redis.expire(_this.key, IMPRESSIONS_TTL_REFRESH).catch(function () { }); // noop catch handler
                return items.map(function (item) { return JSON.parse(item); });
            });
        });
    };
    return ImpressionsCacheInRedis;
}());
export { ImpressionsCacheInRedis };
