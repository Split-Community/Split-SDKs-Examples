import { ISet } from '../../../utils/lang/sets';
import { ISegmentsCacheSync, ISplitsCacheSync, IStorageSync } from '../../../storages/types';
import { ISplitChangesFetcher } from '../fetchers/types';
import { ISplit } from '../../../dtos/types';
import { IReadinessManager, ISplitsEventEmitter } from '../../../readiness/types';
import { ISplitsSyncTask } from '../types';
import { IFetchSplitChanges } from '../../../services/types';
import { ISettings } from '../../../types';
declare type ISplitChangesUpdater = (noCache?: boolean) => Promise<boolean>;
/**
 * Collect segments from a raw split definition.
 * Exported for testing purposes.
 */
export declare function parseSegments({ conditions }: ISplit): ISet<string>;
interface ISplitMutations {
    added: [string, string][];
    removed: string[];
    segments: string[];
}
/**
 * Given the list of splits from /splitChanges endpoint, it returns the mutations,
 * i.e., an object with added splits, removed splits and used segments.
 * Exported for testing purposes.
 */
export declare function computeSplitsMutation(entries: ISplit[]): ISplitMutations;
/**
 * factory of SplitChanges updater (a.k.a, SplitsSyncTask), a task that:
 *  - fetches split changes using `splitChangesFetcher`
 *  - updates `splitsCache`
 *  - uses `splitsEventEmitter` to emit events related to split data updates
 * Exported for testing purposes.
 */
export declare function splitChangesUpdaterFactory(splitChangesFetcher: ISplitChangesFetcher, splitsCache: ISplitsCacheSync, segmentsCache: ISegmentsCacheSync, splitsEventEmitter: ISplitsEventEmitter, requestTimeoutBeforeReady: number, retriesOnFailureBeforeReady: number): ISplitChangesUpdater;
export default function splitsSyncTaskFactory(fetchSplitChanges: IFetchSplitChanges, storage: IStorageSync, readiness: IReadinessManager, settings: ISettings): ISplitsSyncTask;
export {};
