import { KeyBuilderSS } from '../KeyBuilderSS';
import { Redis } from 'ioredis';
import { ILogger } from '../../logger/types';
import { AbstractSplitsCacheAsync } from '../AbstractSplitsCacheAsync';
/**
 * ISplitsCacheAsync implementation that stores split definitions in Redis.
 * Supported by Node.
 */
export declare class SplitsCacheInRedis extends AbstractSplitsCacheAsync {
    private readonly log;
    private readonly redis;
    private readonly keys;
    private redisError?;
    constructor(log: ILogger, keys: KeyBuilderSS, redis: Redis);
    private _decrementCounts;
    private _incrementCounts;
    /**
     * Add a given split.
     * The returned promise is resolved when the operation success
     * or rejected if it fails (e.g., redis operation fails)
     */
    addSplit(name: string, split: string): Promise<boolean>;
    /**
     * Add a list of splits.
     * The returned promise is resolved when the operation success
     * or rejected if it fails (e.g., redis operation fails)
     */
    addSplits(entries: [string, string][]): Promise<boolean[]>;
    /**
     * Remove a given split.
     * The returned promise is resolved when the operation success, with 1 or 0 indicating if the split existed or not.
     * or rejected if it fails (e.g., redis operation fails).
     */
    removeSplit(name: string): Promise<number>;
    /**
     * Remove a list of splits.
     * The returned promise is resolved when the operation success,
     * or rejected if it fails (e.g., redis operation fails).
     */
    removeSplits(names: string[]): Promise<any>;
    /**
     * Get split definition or null if it's not defined.
     * Returned promise is rejected if redis operation fails.
     */
    getSplit(name: string): Promise<string | null>;
    /**
     * Set till number.
     * The returned promise is resolved when the operation success,
     * or rejected if it fails.
     */
    setChangeNumber(changeNumber: number): Promise<boolean>;
    /**
     * Get till number or -1 if it's not defined.
     * The returned promise is resolved with the changeNumber or -1 if it doesn't exist or a redis operation fails.
     * The promise will never be rejected.
     */
    getChangeNumber(): Promise<number>;
    /**
     * Get list of all split definitions.
     * The returned promise is resolved with the list of split definitions,
     * or rejected if redis operation fails.
     *
     * @TODO we need to benchmark which is the maximun number of commands we could
     *       pipeline without kill redis performance.
     */
    getAll(): Promise<string[]>;
    /**
     * Get list of split names.
     * The returned promise is resolved with the list of split names,
     * or rejected if redis operation fails.
     */
    getSplitNames(): Promise<string[]>;
    /**
     * Check traffic type existence.
     * The returned promise is resolved with a boolean indicating whether the TT exist or not.
     * In case of redis operation failure, the promise resolves with a true value, assuming that the TT might exist.
     * It will never be rejected.
     */
    trafficTypeExists(trafficType: string): Promise<boolean>;
    /**
     * Delete everything in the current database.
     *
     * @NOTE documentation says it never fails.
     */
    clear(): Promise<boolean>;
    /**
     * Fetches multiple splits definitions.
     * Returned promise is rejected if redis operation fails.
     */
    getSplits(names: string[]): Promise<Record<string, string | null>>;
}
