import { IPluggableStorageWrapper, IEventsCacheAsync } from '../types';
import { IMetadata } from '../../dtos/types';
import { SplitIO } from '../../types';
import { ILogger } from '../../logger/types';
import { StoredEventWithMetadata } from '../../sync/submitters/types';
export declare class EventsCachePluggable implements IEventsCacheAsync {
    private readonly log;
    private readonly wrapper;
    private readonly key;
    private readonly metadata;
    constructor(log: ILogger, key: string, wrapper: IPluggableStorageWrapper, metadata: IMetadata);
    /**
     * Push given event to the storage.
     * @param eventData  Event item to push.
     * @returns  A promise that is resolved with a boolean value indicating if the push operation succeeded or failed.
     * Unlike `impressions::track`, The promise will never be rejected.
     */
    track(eventData: SplitIO.EventData): Promise<boolean>;
    private _toJSON;
    /**
     * Returns a promise that resolves with the count of stored events, or 0 if there was some error.
     * The promise will never be rejected.
     */
    count(): Promise<number>;
    /**
     * Removes the given number of events from the store. If a number is not provided, it deletes all items.
     * The returned promise rejects if the wrapper operation fails.
     */
    drop(count?: number): Promise<any>;
    /**
     * Pop the given number of events from the storage.
     * The returned promise rejects if the wrapper operation fails.
     *
     * NOTE: this method doesn't take into account MAX_EVENT_SIZE or MAX_QUEUE_BYTE_SIZE limits.
     * It is the submitter responsability to handle that.
     */
    popNWithMetadata(count: number): Promise<StoredEventWithMetadata[]>;
}
