"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SplitsCacheInRedis = void 0;
var tslib_1 = require("tslib");
var lang_1 = require("../../utils/lang");
var constants_1 = require("./constants");
var AbstractSplitsCacheAsync_1 = require("../AbstractSplitsCacheAsync");
/**
 * Discard errors for an answer of multiple operations.
 */
function processPipelineAnswer(results) {
    return results.reduce(function (accum, errValuePair) {
        if (errValuePair[0] === null)
            accum.push(errValuePair[1]);
        return accum;
    }, []);
}
/**
 * ISplitsCacheAsync implementation that stores split definitions in Redis.
 * Supported by Node.
 */
var SplitsCacheInRedis = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(SplitsCacheInRedis, _super);
    function SplitsCacheInRedis(log, keys, redis) {
        var _this = _super.call(this) || this;
        _this.log = log;
        _this.redis = redis;
        _this.keys = keys;
        // There is no need to listen for redis 'error' event, because in that case ioredis calls will be rejected and handled by redis storage adapters.
        // But it is done just to avoid getting the ioredis message `Unhandled error event`.
        _this.redis.on('error', function (e) {
            _this.redisError = e;
        });
        _this.redis.on('connect', function () {
            _this.redisError = undefined;
        });
        return _this;
    }
    SplitsCacheInRedis.prototype._decrementCounts = function (split) {
        var _this = this;
        if (split.trafficTypeName) {
            var ttKey_1 = this.keys.buildTrafficTypeKey(split.trafficTypeName);
            return this.redis.decr(ttKey_1).then(function (count) {
                if (count === 0)
                    return _this.redis.del(ttKey_1);
            });
        }
    };
    SplitsCacheInRedis.prototype._incrementCounts = function (split) {
        if (split.trafficTypeName) {
            var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);
            return this.redis.incr(ttKey);
        }
    };
    /**
     * Add a given split.
     * The returned promise is resolved when the operation success
     * or rejected if it fails (e.g., redis operation fails)
     */
    SplitsCacheInRedis.prototype.addSplit = function (name, split) {
        var _this = this;
        var splitKey = this.keys.buildSplitKey(name);
        return this.redis.get(splitKey).then(function (splitFromStorage) {
            // handling parsing errors
            var parsedPreviousSplit, parsedSplit;
            try {
                parsedPreviousSplit = splitFromStorage ? JSON.parse(splitFromStorage) : undefined;
                parsedSplit = JSON.parse(split);
            }
            catch (e) {
                throw new Error('Error parsing split definition: ' + e);
            }
            return Promise.all([
                _this.redis.set(splitKey, split),
                _this._incrementCounts(parsedSplit),
                // If it's an update, we decrement the traffic type of the existing split,
                parsedPreviousSplit && _this._decrementCounts(parsedPreviousSplit)
            ]);
        }).then(function (_a) {
            var status = _a[0];
            return status === 'OK';
        });
    };
    /**
     * Add a list of splits.
     * The returned promise is resolved when the operation success
     * or rejected if it fails (e.g., redis operation fails)
     */
    SplitsCacheInRedis.prototype.addSplits = function (entries) {
        var _this = this;
        return Promise.all(entries.map(function (keyValuePair) { return _this.addSplit(keyValuePair[0], keyValuePair[1]); }));
    };
    /**
     * Remove a given split.
     * The returned promise is resolved when the operation success, with 1 or 0 indicating if the split existed or not.
     * or rejected if it fails (e.g., redis operation fails).
     */
    SplitsCacheInRedis.prototype.removeSplit = function (name) {
        var _this = this;
        return this.getSplit(name).then(function (split) {
            if (split) {
                var parsedSplit = JSON.parse(split);
                _this._decrementCounts(parsedSplit);
            }
            return _this.redis.del(_this.keys.buildSplitKey(name));
        });
    };
    /**
     * Remove a list of splits.
     * The returned promise is resolved when the operation success,
     * or rejected if it fails (e.g., redis operation fails).
     */
    SplitsCacheInRedis.prototype.removeSplits = function (names) {
        var _this = this;
        return Promise.all(names.map(function (name) { return _this.removeSplit(name); }));
    };
    /**
     * Get split definition or null if it's not defined.
     * Returned promise is rejected if redis operation fails.
     */
    SplitsCacheInRedis.prototype.getSplit = function (name) {
        if (this.redisError) {
            this.log.error(constants_1.LOG_PREFIX + this.redisError);
            return Promise.reject(this.redisError);
        }
        return this.redis.get(this.keys.buildSplitKey(name));
    };
    /**
     * Set till number.
     * The returned promise is resolved when the operation success,
     * or rejected if it fails.
     */
    SplitsCacheInRedis.prototype.setChangeNumber = function (changeNumber) {
        return this.redis.set(this.keys.buildSplitsTillKey(), changeNumber + '').then(function (status) { return status === 'OK'; });
    };
    /**
     * Get till number or -1 if it's not defined.
     * The returned promise is resolved with the changeNumber or -1 if it doesn't exist or a redis operation fails.
     * The promise will never be rejected.
     */
    SplitsCacheInRedis.prototype.getChangeNumber = function () {
        var _this = this;
        return this.redis.get(this.keys.buildSplitsTillKey()).then(function (value) {
            var i = parseInt(value, 10);
            return (0, lang_1.isNaNNumber)(i) ? -1 : i;
        }).catch(function (e) {
            _this.log.error(constants_1.LOG_PREFIX + 'Could not retrieve changeNumber from storage. Error: ' + e);
            return -1;
        });
    };
    /**
     * Get list of all split definitions.
     * The returned promise is resolved with the list of split definitions,
     * or rejected if redis operation fails.
     *
     * @TODO we need to benchmark which is the maximun number of commands we could
     *       pipeline without kill redis performance.
     */
    SplitsCacheInRedis.prototype.getAll = function () {
        var _this = this;
        return this.redis.keys(this.keys.searchPatternForSplitKeys()).then(function (listOfKeys) { return _this.redis.pipeline(listOfKeys.map(function (k) { return ['get', k]; })).exec(); }).then(processPipelineAnswer);
    };
    /**
     * Get list of split names.
     * The returned promise is resolved with the list of split names,
     * or rejected if redis operation fails.
     */
    SplitsCacheInRedis.prototype.getSplitNames = function () {
        var _this = this;
        return this.redis.keys(this.keys.searchPatternForSplitKeys()).then(function (listOfKeys) { return listOfKeys.map(_this.keys.extractKey); });
    };
    /**
     * Check traffic type existence.
     * The returned promise is resolved with a boolean indicating whether the TT exist or not.
     * In case of redis operation failure, the promise resolves with a true value, assuming that the TT might exist.
     * It will never be rejected.
     */
    SplitsCacheInRedis.prototype.trafficTypeExists = function (trafficType) {
        var _this = this;
        // If there is a number there should be > 0, otherwise the TT is considered as not existent.
        return this.redis.get(this.keys.buildTrafficTypeKey(trafficType))
            .then(function (ttCount) {
            if (ttCount === null)
                return false; // if entry doesn't exist, means that TT doesn't exist
            ttCount = parseInt(ttCount, 10);
            if (!(0, lang_1.isFiniteNumber)(ttCount) || ttCount < 0) {
                _this.log.info(constants_1.LOG_PREFIX + ("Could not validate traffic type existance of " + trafficType + " due to data corruption of some sorts."));
                return false;
            }
            return ttCount > 0;
        })
            .catch(function (e) {
            _this.log.error(constants_1.LOG_PREFIX + ("Could not validate traffic type existance of " + trafficType + " due to an error: " + e + "."));
            // If there is an error, bypass the validation so the event can get tracked.
            return true;
        });
    };
    /**
     * Delete everything in the current database.
     *
     * @NOTE documentation says it never fails.
     */
    SplitsCacheInRedis.prototype.clear = function () {
        return this.redis.flushdb().then(function (status) { return status === 'OK'; });
    };
    /**
     * Fetches multiple splits definitions.
     * Returned promise is rejected if redis operation fails.
     */
    SplitsCacheInRedis.prototype.getSplits = function (names) {
        var _a;
        var _this = this;
        if (this.redisError) {
            this.log.error(constants_1.LOG_PREFIX + this.redisError);
            return Promise.reject(this.redisError);
        }
        var splits = {};
        var keys = names.map(function (name) { return _this.keys.buildSplitKey(name); });
        return (_a = this.redis).mget.apply(_a, keys).then(function (splitDefinitions) {
            names.forEach(function (name, idx) {
                splits[name] = splitDefinitions[idx];
            });
            return Promise.resolve(splits);
        })
            .catch(function (e) {
            _this.log.error(constants_1.LOG_PREFIX + ("Could not grab splits due to an error: " + e + "."));
            return Promise.reject(e);
        });
    };
    return SplitsCacheInRedis;
}(AbstractSplitsCacheAsync_1.AbstractSplitsCacheAsync));
exports.SplitsCacheInRedis = SplitsCacheInRedis;
