"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.impressionsTrackerFactory = void 0;
var objectAssign_1 = require("../utils/lang/objectAssign");
var thenable_1 = require("../utils/promise/thenable");
var time_1 = require("../utils/time");
var constants_1 = require("../logger/constants");
var constants_2 = require("../utils/constants");
/**
 * Impressions tracker stores impressions in cache and pass them to the listener and integrations manager if provided.
 *
 * @param impressionsCache cache to save impressions
 * @param metadata runtime metadata (ip, hostname and version)
 * @param impressionListener optional impression listener
 * @param integrationsManager optional integrations manager
 * @param observer optional impression observer. If provided, previous time (pt property) is included in impression instances
 * @param countsCache optional cache to save impressions count. If provided, impressions will be deduped (OPTIMIZED mode)
 */
function impressionsTrackerFactory(settings, impressionsCache, integrationsManager, 
// if observer is provided, it implies `shouldAddPreviousTime` flag (i.e., if impressions previous time should be added or not)
observer, 
// if countsCache is provided, it implies `isOptimized` flag (i.e., if impressions should be deduped or not)
countsCache, telemetryCache) {
    var log = settings.log, impressionListener = settings.impressionListener, _a = settings.runtime, ip = _a.ip, hostname = _a.hostname, version = settings.version;
    return {
        track: function (impressions, attributes) {
            if (settings.userConsent === constants_2.CONSENT_DECLINED)
                return;
            var impressionsCount = impressions.length;
            var impressionsToStore = []; // Track only the impressions that are going to be stored
            // Wraps impressions to store and adds previousTime if it corresponds
            impressions.forEach(function (impression) {
                if (observer) {
                    // Adds previous time if it is enabled
                    impression.pt = observer.testAndSet(impression);
                }
                var now = Date.now();
                if (countsCache) {
                    // Increments impression counter per featureName
                    countsCache.track(impression.feature, now, 1);
                }
                // Checks if the impression should be added in queue to be sent
                if (!countsCache || !impression.pt || impression.pt < (0, time_1.truncateTimeFrame)(now)) {
                    impressionsToStore.push(impression);
                }
            });
            var res = impressionsCache.track(impressionsToStore);
            // If we're on an async storage, handle error and log it.
            if ((0, thenable_1.thenable)(res)) {
                res.then(function () {
                    log.info(constants_1.IMPRESSIONS_TRACKER_SUCCESS, [impressionsCount]);
                }).catch(function (err) {
                    log.error(constants_1.ERROR_IMPRESSIONS_TRACKER, [impressionsCount, err]);
                });
            }
            else {
                // Record when impressionsCache is sync only (standalone mode)
                // @TODO we are not dropping impressions on full queue yet, so DROPPED stats are not recorded
                if (telemetryCache) {
                    telemetryCache.recordImpressionStats(constants_2.QUEUED, impressionsToStore.length);
                    telemetryCache.recordImpressionStats(constants_2.DEDUPED, impressions.length - impressionsToStore.length);
                }
            }
            // @TODO next block might be handled by the integration manager. In that case, the metadata object doesn't need to be passed in the constructor
            if (impressionListener || integrationsManager) {
                var _loop_1 = function (i) {
                    var impressionData = {
                        // copy of impression, to avoid unexpected behaviour if modified by integrations or impressionListener
                        impression: (0, objectAssign_1.objectAssign)({}, impressions[i]),
                        attributes: attributes,
                        ip: ip,
                        hostname: hostname,
                        sdkLanguageVersion: version
                    };
                    // Wrap in a timeout because we don't want it to be blocking.
                    setTimeout(function () {
                        // integrationsManager.handleImpression does not throw errors
                        if (integrationsManager)
                            integrationsManager.handleImpression(impressionData);
                        try { // @ts-ignore. An exception on the listeners should not break the SDK.
                            if (impressionListener)
                                impressionListener.logImpression(impressionData);
                        }
                        catch (err) {
                            log.error(constants_1.ERROR_IMPRESSIONS_LISTENER, [err]);
                        }
                    }, 0);
                };
                for (var i = 0; i < impressionsCount; i++) {
                    _loop_1(i);
                }
            }
        }
    };
}
exports.impressionsTrackerFactory = impressionsTrackerFactory;
