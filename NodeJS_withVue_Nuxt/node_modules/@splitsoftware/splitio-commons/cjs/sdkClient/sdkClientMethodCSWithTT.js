"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sdkClientMethodCSFactory = void 0;
var clientCS_1 = require("./clientCS");
var key_1 = require("../utils/inputValidation/key");
var trafficType_1 = require("../utils/inputValidation/trafficType");
var key_2 = require("../utils/key");
var sdkClient_1 = require("./sdkClient");
var objectAssign_1 = require("../utils/lang/objectAssign");
var constants_1 = require("../logger/constants");
var constants_2 = require("../readiness/constants");
function buildInstanceId(key, trafficType) {
    // @ts-ignore
    return (key.matchingKey ? key.matchingKey : key) + "-" + (key.bucketingKey ? key.bucketingKey : key) + "-" + (trafficType !== undefined ? trafficType : '');
}
var method = 'Client instantiation';
/**
 * Factory of client method for the client-side (browser) variant of the Isomorphic JS SDK,
 * where clients can have a binded TT for the track method, which is provided via the settings
 * (default client) or the client method (shared clients).
 */
function sdkClientMethodCSFactory(params) {
    var storage = params.storage, syncManager = params.syncManager, sdkReadinessManager = params.sdkReadinessManager, _a = params.settings, _b = _a.core, key = _b.key, trafficType = _b.trafficType, readyTimeout = _a.startup.readyTimeout, log = _a.log;
    var mainClientInstance = (0, clientCS_1.clientCSDecorator)(log, (0, sdkClient_1.sdkClientFactory)(params), key, trafficType);
    var parsedDefaultKey = (0, key_2.keyParser)(key);
    var defaultInstanceId = buildInstanceId(parsedDefaultKey, trafficType);
    // Cache instances created per factory.
    var clientInstances = {};
    clientInstances[defaultInstanceId] = mainClientInstance;
    return function client(key, trafficType) {
        if (key === undefined) {
            log.debug(constants_1.RETRIEVE_CLIENT_DEFAULT);
            return mainClientInstance;
        }
        // Validate the key value
        var validKey = (0, key_1.validateKey)(log, key, "Shared " + method);
        if (validKey === false) {
            throw new Error('Shared Client needs a valid key.');
        }
        var validTrafficType;
        if (trafficType !== undefined) {
            validTrafficType = (0, trafficType_1.validateTrafficType)(log, trafficType, "Shared " + method);
            if (validTrafficType === false) {
                throw new Error('Shared Client needs a valid traffic type or no traffic type at all.');
            }
        }
        var instanceId = buildInstanceId(validKey, validTrafficType);
        if (!clientInstances[instanceId]) {
            var matchingKey = (0, key_2.getMatching)(validKey);
            var sharedSdkReadiness_1 = sdkReadinessManager.shared(readyTimeout);
            var sharedStorage = storage.shared && storage.shared(matchingKey, function (err) {
                if (err)
                    return;
                // Emit SDK_READY in consumer mode for shared clients
                sharedSdkReadiness_1.readinessManager.segments.emit(constants_2.SDK_SEGMENTS_ARRIVED);
            });
            // 3 possibilities:
            // - Standalone mode: both syncManager and sharedSyncManager are defined
            // - Consumer mode: both syncManager and sharedSyncManager are undefined
            // - Consumer partial mode: syncManager is defined (only for submitters) but sharedSyncManager is undefined
            // @ts-ignore
            var sharedSyncManager = syncManager && sharedStorage && syncManager.shared(matchingKey, sharedSdkReadiness_1.readinessManager, sharedStorage);
            // As shared clients reuse all the storage information, we don't need to check here if we
            // will use offline or online mode. We should stick with the original decision.
            clientInstances[instanceId] = (0, clientCS_1.clientCSDecorator)(log, (0, sdkClient_1.sdkClientFactory)((0, objectAssign_1.objectAssign)({}, params, {
                sdkReadinessManager: sharedSdkReadiness_1,
                storage: sharedStorage || storage,
                syncManager: sharedSyncManager,
                signalListener: undefined, // only the main client "destroy" method stops the signal listener
            }), true), validKey, validTrafficType);
            sharedSyncManager && sharedSyncManager.start();
            log.info(constants_1.NEW_SHARED_CLIENT);
        }
        else {
            log.debug(constants_1.RETRIEVE_CLIENT_EXISTING);
        }
        return clientInstances[instanceId];
    };
}
exports.sdkClientMethodCSFactory = sdkClientMethodCSFactory;
