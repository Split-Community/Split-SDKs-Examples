"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sdkFactory = void 0;
var sdkReadinessManager_1 = require("../readiness/sdkReadinessManager");
var impressionsTracker_1 = require("../trackers/impressionsTracker");
var eventTracker_1 = require("../trackers/eventTracker");
var telemetryTracker_1 = require("../trackers/telemetryTracker");
var key_1 = require("../utils/key");
var utils_1 = require("../trackers/impressionObserver/utils");
var apiKey_1 = require("../utils/inputValidation/apiKey");
var sdkLogger_1 = require("../logger/sdkLogger");
var constants_1 = require("../logger/constants");
var metadataBuilder_1 = require("../storages/metadataBuilder");
var constants_2 = require("../readiness/constants");
var objectAssign_1 = require("../utils/lang/objectAssign");
/**
 * Modular SDK factory
 */
function sdkFactory(params) {
    var settings = params.settings, platform = params.platform, storageFactory = params.storageFactory, splitApiFactory = params.splitApiFactory, extraProps = params.extraProps, syncManagerFactory = params.syncManagerFactory, SignalListener = params.SignalListener, impressionsObserverFactory = params.impressionsObserverFactory, integrationsManagerFactory = params.integrationsManagerFactory, sdkManagerFactory = params.sdkManagerFactory, sdkClientMethodFactory = params.sdkClientMethodFactory;
    var log = settings.log;
    // @TODO handle non-recoverable errors, such as, global `fetch` not available, invalid API Key, etc.
    // On non-recoverable errors, we should mark the SDK as destroyed and not start synchronization.
    // We will just log and allow for the SDK to end up throwing an SDK_TIMEOUT event for devs to handle.
    (0, apiKey_1.validateAndTrackApiKey)(log, settings.core.authorizationKey);
    var sdkReadinessManager = (0, sdkReadinessManager_1.sdkReadinessManagerFactory)(log, platform.EventEmitter, settings.startup.readyTimeout);
    var readiness = sdkReadinessManager.readinessManager;
    // @TODO consider passing the settings object, so that each storage access only what it needs
    var storageFactoryParams = {
        impressionsQueueSize: settings.scheduler.impressionsQueueSize,
        eventsQueueSize: settings.scheduler.eventsQueueSize,
        optimize: (0, utils_1.shouldBeOptimized)(settings),
        // ATM, only used by InLocalStorage
        matchingKey: (0, key_1.getMatching)(settings.core.key),
        splitFiltersValidation: settings.sync.__splitFiltersValidation,
        // ATM, only used by PluggableStorage
        mode: settings.mode,
        // Callback used to emit SDK_READY in consumer mode, where `syncManagerFactory` is undefined,
        // or partial consumer mode, where it only has submitters, and therefore it doesn't emit readiness events.
        onReadyCb: function (error) {
            if (error)
                return; // Don't emit SDK_READY if storage failed to connect. Error message is logged by wrapperAdapter
            readiness.splits.emit(constants_2.SDK_SPLITS_ARRIVED);
            readiness.segments.emit(constants_2.SDK_SEGMENTS_ARRIVED);
        },
        metadata: (0, metadataBuilder_1.metadataBuilder)(settings),
        log: log
    };
    var storage = storageFactory(storageFactoryParams);
    // @TODO add support for dataloader: `if (params.dataLoader) params.dataLoader(storage);`
    var integrationsManager = integrationsManagerFactory && integrationsManagerFactory({ settings: settings, storage: storage });
    // trackers
    var observer = impressionsObserverFactory && impressionsObserverFactory();
    var impressionsTracker = (0, impressionsTracker_1.impressionsTrackerFactory)(settings, storage.impressions, integrationsManager, observer, storage.impressionCounts, storage.telemetry);
    var eventTracker = (0, eventTracker_1.eventTrackerFactory)(settings, storage.events, integrationsManager, storage.telemetry);
    var telemetryTracker = (0, telemetryTracker_1.telemetryTrackerFactory)(storage.telemetry, platform.now);
    // splitApi is used by SyncManager and Browser signal listener
    var splitApi = splitApiFactory && splitApiFactory(settings, platform, telemetryTracker);
    var ctx = { splitApi: splitApi, eventTracker: eventTracker, impressionsTracker: impressionsTracker, telemetryTracker: telemetryTracker, sdkReadinessManager: sdkReadinessManager, readiness: readiness, settings: settings, storage: storage, platform: platform };
    var syncManager = syncManagerFactory && syncManagerFactory(ctx);
    ctx.syncManager = syncManager;
    var signalListener = SignalListener && new SignalListener(syncManager, settings, storage, splitApi);
    ctx.signalListener = signalListener;
    // SDK client and manager
    var clientMethod = sdkClientMethodFactory(ctx);
    var managerInstance = sdkManagerFactory(log, storage.splits, sdkReadinessManager);
    syncManager && syncManager.start();
    signalListener && signalListener.start();
    log.info(constants_1.NEW_FACTORY);
    // @ts-ignore
    return (0, objectAssign_1.objectAssign)({
        // Split evaluation and event tracking engine
        client: clientMethod,
        // Manager API to explore available information
        manager: function () {
            log.debug(constants_1.RETRIEVE_MANAGER);
            return managerInstance;
        },
        // Logger wrapper API
        Logger: (0, sdkLogger_1.createLoggerAPI)(settings.log),
        settings: settings,
    }, extraProps && extraProps(ctx));
}
exports.sdkFactory = sdkFactory;
