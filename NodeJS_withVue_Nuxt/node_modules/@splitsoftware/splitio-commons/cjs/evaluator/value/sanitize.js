"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitize = void 0;
var lang_1 = require("../../utils/lang");
var convertions_1 = require("../convertions");
var matcherTypes_1 = require("../matchers/matcherTypes");
var constants_1 = require("../../logger/constants");
function sanitizeNumber(val) {
    var num = (0, lang_1.toNumber)(val);
    return isNaN(num) ? undefined : num;
}
function sanitizeString(val) {
    var valueToSanitize = val;
    if ((0, lang_1.isObject)(val)) {
        // If the value is an object and is not a key, discard it.
        valueToSanitize = val.matchingKey ? val.matchingKey : undefined;
    }
    var str = (0, lang_1.toString)(valueToSanitize);
    return str ? str : undefined;
}
function sanitizeArray(val) {
    var arr = Array.isArray(val) ? (0, lang_1.uniq)(val.map(function (e) { return e + ''; })) : [];
    return arr.length ? arr : undefined;
}
function sanitizeBoolean(val) {
    if (val === true || val === false)
        return val;
    if (typeof val === 'string') {
        var lowerCaseValue = val.toLocaleLowerCase();
        if (lowerCaseValue === 'true')
            return true;
        if (lowerCaseValue === 'false')
            return false;
    }
    return undefined;
}
function dependencyProcessor(sanitizedValue, attributes) {
    return {
        key: sanitizedValue,
        attributes: attributes
    };
}
/**
 * We can define a pre-processing for the value, to be executed prior to matcher evaluation.
 */
function getProcessingFunction(matcherTypeID, dataType) {
    switch (matcherTypeID) {
        case matcherTypes_1.matcherTypes.EQUAL_TO:
            return dataType === 'DATETIME' ? convertions_1.zeroSinceHH : undefined;
        case matcherTypes_1.matcherTypes.GREATER_THAN_OR_EQUAL_TO:
        case matcherTypes_1.matcherTypes.LESS_THAN_OR_EQUAL_TO:
        case matcherTypes_1.matcherTypes.BETWEEN:
            return dataType === 'DATETIME' ? convertions_1.zeroSinceSS : undefined;
        case matcherTypes_1.matcherTypes.IN_SPLIT_TREATMENT:
            return dependencyProcessor;
        default:
            return undefined;
    }
}
/**
 * Sanitize matcher value
 */
function sanitize(log, matcherTypeID, value, dataType, attributes) {
    var processor = getProcessingFunction(matcherTypeID, dataType);
    var sanitizedValue;
    switch (dataType) {
        case matcherTypes_1.matcherDataTypes.NUMBER:
        case matcherTypes_1.matcherDataTypes.DATETIME:
            sanitizedValue = sanitizeNumber(value);
            break;
        case matcherTypes_1.matcherDataTypes.STRING:
            sanitizedValue = sanitizeString(value);
            break;
        case matcherTypes_1.matcherDataTypes.SET:
            sanitizedValue = sanitizeArray(value);
            break;
        case matcherTypes_1.matcherDataTypes.BOOLEAN:
            sanitizedValue = sanitizeBoolean(value);
            break;
        case matcherTypes_1.matcherDataTypes.NOT_SPECIFIED:
            sanitizedValue = value;
            break;
        default:
            sanitizedValue = undefined;
    }
    if (processor) {
        // @ts-ignore
        sanitizedValue = processor(sanitizedValue, attributes);
    }
    log.debug(constants_1.ENGINE_SANITIZE, [value, dataType, sanitizedValue instanceof Object ? JSON.stringify(sanitizedValue) : sanitizedValue]);
    return sanitizedValue;
}
exports.sanitize = sanitize;
