"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pollingManagerCSFactory = void 0;
var lang_1 = require("../../utils/lang");
var mySegmentsSyncTask_1 = require("./syncTasks/mySegmentsSyncTask");
var splitsSyncTask_1 = require("./syncTasks/splitsSyncTask");
var key_1 = require("../../utils/key");
var constants_1 = require("../../readiness/constants");
var constants_2 = require("../../logger/constants");
/**
 * Expose start / stop mechanism for polling data from services.
 * For client-side API with multiple clients.
 */
function pollingManagerCSFactory(params) {
    var splitApi = params.splitApi, storage = params.storage, readiness = params.readiness, settings = params.settings;
    var log = settings.log;
    var splitsSyncTask = (0, splitsSyncTask_1.splitsSyncTaskFactory)(splitApi.fetchSplitChanges, storage, readiness, settings, true);
    // Map of matching keys to their corresponding MySegmentsSyncTask.
    var mySegmentsSyncTasks = {};
    var matchingKey = (0, key_1.getMatching)(settings.core.key);
    var mySegmentsSyncTask = add(matchingKey, readiness, storage);
    function startMySegmentsSyncTasks() {
        (0, lang_1.forOwn)(mySegmentsSyncTasks, function (mySegmentsSyncTask) {
            mySegmentsSyncTask.start();
        });
    }
    function stopMySegmentsSyncTasks() {
        (0, lang_1.forOwn)(mySegmentsSyncTasks, function (mySegmentsSyncTask) {
            if (mySegmentsSyncTask.isRunning())
                mySegmentsSyncTask.stop();
        });
    }
    // smart pausing
    readiness.splits.on(constants_1.SDK_SPLITS_ARRIVED, function () {
        if (!splitsSyncTask.isRunning())
            return; // noop if not doing polling
        var splitsHaveSegments = storage.splits.usesSegments();
        if (splitsHaveSegments !== mySegmentsSyncTask.isRunning()) {
            log.info(constants_2.POLLING_SMART_PAUSING, [splitsHaveSegments ? 'ON' : 'OFF']);
            if (splitsHaveSegments) {
                startMySegmentsSyncTasks();
            }
            else {
                stopMySegmentsSyncTasks();
            }
        }
    });
    function add(matchingKey, readiness, storage) {
        var mySegmentsSyncTask = (0, mySegmentsSyncTask_1.mySegmentsSyncTaskFactory)(splitApi.fetchMySegments, storage, readiness, settings, matchingKey);
        // smart ready
        function smartReady() {
            if (!readiness.isReady() && !storage.splits.usesSegments())
                readiness.segments.emit(constants_1.SDK_SEGMENTS_ARRIVED);
        }
        if (!storage.splits.usesSegments())
            setTimeout(smartReady, 0);
        else
            readiness.splits.once(constants_1.SDK_SPLITS_ARRIVED, smartReady);
        mySegmentsSyncTasks[matchingKey] = mySegmentsSyncTask;
        return mySegmentsSyncTask;
    }
    return {
        splitsSyncTask: splitsSyncTask,
        segmentsSyncTask: mySegmentsSyncTask,
        // Start periodic fetching (polling)
        start: function () {
            log.info(constants_2.POLLING_START);
            splitsSyncTask.start();
            if (storage.splits.usesSegments())
                startMySegmentsSyncTasks();
        },
        // Stop periodic fetching (polling)
        stop: function () {
            log.info(constants_2.POLLING_STOP);
            if (splitsSyncTask.isRunning())
                splitsSyncTask.stop();
            stopMySegmentsSyncTasks();
        },
        // Used by SyncManager to know if running in polling mode.
        isRunning: splitsSyncTask.isRunning,
        // fetch splits and segments
        syncAll: function () {
            var promises = [splitsSyncTask.execute()];
            (0, lang_1.forOwn)(mySegmentsSyncTasks, function (mySegmentsSyncTask) {
                promises.push(mySegmentsSyncTask.execute());
            });
            return Promise.all(promises);
        },
        // Support for handling mySegments sync of multiple clients
        add: add,
        remove: function (matchingKey) {
            delete mySegmentsSyncTasks[matchingKey];
        },
        get: function (matchingKey) {
            return mySegmentsSyncTasks[matchingKey];
        }
    };
}
exports.pollingManagerCSFactory = pollingManagerCSFactory;
