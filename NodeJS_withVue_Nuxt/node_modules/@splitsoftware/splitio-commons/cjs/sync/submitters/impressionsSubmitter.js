"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.impressionsSubmitterFactory = exports.fromImpressionsCollector = void 0;
var lang_1 = require("../../utils/lang");
var submitter_1 = require("./submitter");
var constants_1 = require("../../logger/constants");
var DATA_NAME = 'impressions';
/**
 * Converts `impressions` data from cache into request payload.
 */
function fromImpressionsCollector(sendLabels, data) {
    var groupedByFeature = (0, lang_1.groupBy)(data, 'feature');
    var dto = [];
    // using forOwn instead of for...in since the last also iterates over prototype enumerables
    (0, lang_1.forOwn)(groupedByFeature, function (value, name) {
        dto.push({
            f: name,
            i: value.map(function (entry) {
                var keyImpression = {
                    k: entry.keyName,
                    t: entry.treatment,
                    m: entry.time,
                    c: entry.changeNumber,
                    r: sendLabels ? entry.label : undefined,
                    b: entry.bucketingKey ? entry.bucketingKey : undefined,
                    pt: entry.pt ? entry.pt : undefined // Previous time
                };
                return keyImpression;
            })
        });
    });
    return dto;
}
exports.fromImpressionsCollector = fromImpressionsCollector;
/**
 * Submitter that periodically posts impressions data
 */
function impressionsSubmitterFactory(params) {
    var _a = params.settings, log = _a.log, impressionsRefreshRate = _a.scheduler.impressionsRefreshRate, labelsEnabled = _a.core.labelsEnabled, postTestImpressionsBulk = params.splitApi.postTestImpressionsBulk, impressions = params.storage.impressions;
    // retry impressions only once.
    var syncTask = (0, submitter_1.submitterFactory)(log, postTestImpressionsBulk, impressions, impressionsRefreshRate, DATA_NAME, fromImpressionsCollector.bind(undefined, labelsEnabled), 1);
    // register impressions submitter to be executed when impressions cache is full
    impressions.setOnFullQueueCb(function () {
        if (syncTask.isRunning()) {
            log.info(constants_1.SUBMITTERS_PUSH_FULL_QUEUE, [DATA_NAME]);
            syncTask.execute();
        }
        // If submitter is stopped (e.g., user consent declined or unknown, or app state offline), we don't send the data.
        // Data will be sent when submitter is resumed.
    });
    return syncTask;
}
exports.impressionsSubmitterFactory = impressionsSubmitterFactory;
