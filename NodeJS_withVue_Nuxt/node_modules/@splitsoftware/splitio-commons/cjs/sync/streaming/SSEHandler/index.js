"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SSEHandlerFactory = void 0;
var NotificationParser_1 = require("./NotificationParser");
var NotificationKeeper_1 = require("./NotificationKeeper");
var constants_1 = require("../constants");
var constants_2 = require("../../../logger/constants");
var constants_3 = require("../../../utils/constants");
/**
 * Factory for SSEHandler, which processes SSEClient messages and emits the corresponding push events.
 *
 * @param log factory logger
 * @param pushEmitter emitter for events related to streaming support
 */
function SSEHandlerFactory(log, pushEmitter, telemetryTracker) {
    var notificationKeeper = (0, NotificationKeeper_1.notificationKeeperFactory)(pushEmitter, telemetryTracker);
    function isRetryableError(error) {
        if (error.parsedData && error.parsedData.code) {
            // Ably error
            var code = error.parsedData.code;
            telemetryTracker.streamingEvent(constants_3.ABLY_ERROR, code);
            // 401 errors due to invalid or expired token (e.g., if refresh token coudn't be executed)
            if (40140 <= code && code <= 40149)
                return true;
            // Others 4XX errors (e.g., bad request from the SDK)
            if (40000 <= code && code <= 49999)
                return false;
        }
        else {
            // network errors or 5XX HTTP errors
            telemetryTracker.streamingEvent(constants_3.SSE_CONNECTION_ERROR, constants_3.NON_REQUESTED);
        }
        return true;
    }
    return {
        handleOpen: function () {
            notificationKeeper.handleOpen();
        },
        /* HTTP & Network errors */
        handleError: function (error) {
            var errorWithParsedData = error;
            try {
                errorWithParsedData = (0, NotificationParser_1.errorParser)(error);
            }
            catch (err) {
                log.warn(constants_2.STREAMING_PARSING_ERROR_FAILS, [err]);
            }
            var errorMessage = (errorWithParsedData.parsedData && errorWithParsedData.parsedData.message) || errorWithParsedData.message;
            log.error(constants_2.ERROR_STREAMING_SSE, [errorMessage]);
            if (isRetryableError(errorWithParsedData)) {
                pushEmitter.emit(constants_1.PUSH_RETRYABLE_ERROR);
            }
            else {
                pushEmitter.emit(constants_1.PUSH_NONRETRYABLE_ERROR);
            }
        },
        /* NotificationProcessor */
        handleMessage: function (message) {
            var messageWithParsedData;
            try {
                messageWithParsedData = (0, NotificationParser_1.messageParser)(message);
                if (!messageWithParsedData)
                    return; // Messages with empty data are ignored
            }
            catch (err) {
                log.warn(constants_2.STREAMING_PARSING_MESSAGE_FAILS, [err]);
                return;
            }
            var parsedData = messageWithParsedData.parsedData, data = messageWithParsedData.data, channel = messageWithParsedData.channel, timestamp = messageWithParsedData.timestamp;
            log.debug(constants_2.STREAMING_NEW_MESSAGE, [data]);
            // we only handle update events if streaming is up.
            if (!notificationKeeper.isStreamingUp() && [constants_1.OCCUPANCY, constants_1.CONTROL].indexOf(parsedData.type) === -1)
                return;
            switch (parsedData.type) {
                /* update events */
                case constants_1.SPLIT_UPDATE:
                case constants_1.SEGMENT_UPDATE:
                case constants_1.MY_SEGMENTS_UPDATE_V2:
                case constants_1.SPLIT_KILL:
                    pushEmitter.emit(parsedData.type, parsedData);
                    break;
                case constants_1.MY_SEGMENTS_UPDATE:
                    pushEmitter.emit(parsedData.type, parsedData, channel);
                    break;
                /* occupancy & control events, handled by NotificationManagerKeeper */
                case constants_1.OCCUPANCY:
                    notificationKeeper.handleOccupancyEvent(parsedData.metrics.publishers, channel, timestamp);
                    break;
                case constants_1.CONTROL:
                    notificationKeeper.handleControlEvent(parsedData.controlType, channel, timestamp);
                    break;
                default:
                    break;
            }
        },
    };
}
exports.SSEHandlerFactory = SSEHandlerFactory;
