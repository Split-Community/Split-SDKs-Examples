import { findIndex } from '../../../utils/lang';
import { SDK_SEGMENTS_ARRIVED } from '../../../readiness/constants';
import { LOG_PREFIX_INSTANTIATION, LOG_PREFIX_SYNC_SEGMENTS } from '../../../logger/constants';
import { thenable } from '../../../utils/promise/thenable';
/**
 * Factory of SegmentChanges updater, a task that:
 *  - fetches segment changes using `segmentChangesFetcher`
 *  - updates `segmentsCache`
 *  - uses `segmentsEventEmitter` to emit events related to segments data updates
 *
 * @param log logger instance
 * @param segmentChangesFetcher fetcher of `/segmentChanges`
 * @param segments segments storage, with sync or async methods
 * @param readiness optional readiness manager. Not required for synchronizer or producer mode.
 */
export function segmentChangesUpdaterFactory(log, segmentChangesFetcher, segments, readiness) {
    var readyOnAlreadyExistentState = true;
    /**
     * Segments updater returns a promise that resolves with a `false` boolean value if it fails at least to fetch a segment or synchronize it with the storage.
     * Thus, a false result doesn't imply that SDK_SEGMENTS_ARRIVED was not emitted.
     * Returned promise will not be rejected.
     *
     * @param {string[] | undefined} segmentNames list of segment names to fetch. By passing `undefined` it fetches the list of segments registered at the storage
     * @param {boolean | undefined} noCache true to revalidate data to fetch on a SEGMENT_UPDATE notifications.
     * @param {boolean | undefined} fetchOnlyNew if true, only fetch the segments that not exists, i.e., which `changeNumber` is equal to -1.
     * This param is used by SplitUpdateWorker on server-side SDK, to fetch new registered segments on SPLIT_UPDATE notifications.
     */
    return function segmentChangesUpdater(segmentNames, noCache, fetchOnlyNew) {
        log.debug(LOG_PREFIX_SYNC_SEGMENTS + "Started segments update");
        // If not a segment name provided, read list of available segments names to be updated.
        var segmentsPromise = Promise.resolve(segmentNames ? segmentNames : segments.getRegisteredSegments());
        return segmentsPromise.then(function (segmentNames) {
            // Async fetchers are collected here.
            var updaters = [];
            var _loop_1 = function (index) {
                var segmentName = segmentNames[index];
                log.debug(LOG_PREFIX_SYNC_SEGMENTS + "Processing segment " + segmentName);
                var sincePromise = Promise.resolve(segments.getChangeNumber(segmentName));
                updaters.push(sincePromise.then(function (since) {
                    // if fetchOnlyNew flag, avoid processing already fetched segments
                    if (fetchOnlyNew && since !== -1)
                        return -1;
                    return segmentChangesFetcher(since, segmentName, noCache).then(function (changes) {
                        var changeNumber = -1;
                        var results = [];
                        changes.forEach(function (x) {
                            if (x.added.length > 0)
                                results.push(segments.addToSegment(segmentName, x.added));
                            if (x.removed.length > 0)
                                results.push(segments.removeFromSegment(segmentName, x.removed));
                            if (x.added.length > 0 || x.removed.length > 0) {
                                results.push(segments.setChangeNumber(segmentName, x.till));
                                changeNumber = x.till;
                            }
                            log.debug(LOG_PREFIX_SYNC_SEGMENTS + "Processed " + segmentName + " with till = " + x.till + ". Added: " + x.added.length + ". Removed: " + x.removed.length);
                        });
                        // If at least one storage operation result is a promise, join all in a single promise.
                        if (results.some(function (result) { return thenable(result); }))
                            return Promise.all(results).then(function () { return changeNumber; });
                        return changeNumber;
                    });
                }));
            };
            for (var index = 0; index < segmentNames.length; index++) {
                _loop_1(index);
            }
            return Promise.all(updaters).then(function (shouldUpdateFlags) {
                // if at least one segment fetch succeeded, mark segments ready
                if (findIndex(shouldUpdateFlags, function (v) { return v !== -1; }) !== -1 || readyOnAlreadyExistentState) {
                    readyOnAlreadyExistentState = false;
                    if (readiness)
                        readiness.segments.emit(SDK_SEGMENTS_ARRIVED);
                }
                return true;
            });
        })
            // Handles rejected promises at `segmentChangesFetcher`, `segments.getRegisteredSegments` and other segment storage operations.
            .catch(function (error) {
            if (error && error.statusCode === 403) {
                // If the operation is forbidden, it may be due to permissions. Destroy the SDK instance.
                // @TODO although factory status is destroyed, synchronization is not stopped
                if (readiness)
                    readiness.destroy();
                log.error(LOG_PREFIX_INSTANTIATION + ": you passed a client-side type authorizationKey, please grab an Api Key from the Split web console that is of type Server-side.");
            }
            else {
                log.warn(LOG_PREFIX_SYNC_SEGMENTS + "Error while doing fetch of segments. " + error);
            }
            return false;
        });
    };
}
