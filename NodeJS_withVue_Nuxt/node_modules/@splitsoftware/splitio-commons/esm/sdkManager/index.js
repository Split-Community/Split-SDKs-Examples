import { objectAssign } from '../utils/lang/objectAssign';
import { thenable } from '../utils/promise/thenable';
import { find } from '../utils/lang';
import { validateSplit, validateSplitExistance, validateIfNotDestroyed, validateIfOperational } from '../utils/inputValidation';
function collectTreatments(splitObject) {
    var conditions = splitObject.conditions;
    // Rollout conditions are supposed to have the entire partitions list, so we find the first one.
    var allTreatmentsCondition = find(conditions, function (cond) { return cond.conditionType === 'ROLLOUT'; });
    // Localstorage mode could fall into a no rollout conditions state. Take the first condition in that case.
    if (!allTreatmentsCondition)
        allTreatmentsCondition = conditions[0];
    // Then extract the treatments from the partitions
    return allTreatmentsCondition ? allTreatmentsCondition.partitions.map(function (v) { return v.treatment; }) : [];
}
function objectToView(json) {
    var splitObject;
    try {
        // @ts-expect-error
        splitObject = JSON.parse(json);
    }
    catch (e) {
        return null;
    }
    if (!splitObject)
        return null;
    return {
        name: splitObject.name,
        trafficType: splitObject.trafficTypeName,
        killed: splitObject.killed,
        changeNumber: splitObject.changeNumber || 0,
        treatments: collectTreatments(splitObject),
        configs: splitObject.configurations || {}
    };
}
function objectsToViews(jsons) {
    var views = [];
    jsons.forEach(function (split) {
        var view = objectToView(split);
        if (view)
            views.push(view);
    });
    return views;
}
export function sdkManagerFactory(log, splits, _a) {
    var readinessManager = _a.readinessManager, sdkStatus = _a.sdkStatus;
    var SPLIT_FN_LABEL = 'split';
    return objectAssign(
    // Proto-linkage of the readiness Event Emitter
    Object.create(sdkStatus), {
        /**
         * Get the Split object corresponding to the given split name if valid
         */
        split: function (maybeSplitName) {
            var splitName = validateSplit(log, maybeSplitName, SPLIT_FN_LABEL);
            if (!validateIfNotDestroyed(log, readinessManager, SPLIT_FN_LABEL) || !validateIfOperational(log, readinessManager, SPLIT_FN_LABEL) || !splitName) {
                return null;
            }
            var split = splits.getSplit(splitName);
            if (thenable(split)) {
                return split.catch(function () { return null; }).then(function (result) {
                    validateSplitExistance(log, readinessManager, splitName, result, SPLIT_FN_LABEL);
                    return objectToView(result);
                });
            }
            validateSplitExistance(log, readinessManager, splitName, split, SPLIT_FN_LABEL);
            return objectToView(split);
        },
        /**
         * Get the Split objects present on the factory storage
         */
        splits: function () {
            if (!validateIfNotDestroyed(log, readinessManager, 'splits') || !validateIfOperational(log, readinessManager, 'splits')) {
                return [];
            }
            var currentSplits = splits.getAll();
            return thenable(currentSplits) ?
                currentSplits.catch(function () { return []; }).then(objectsToViews) : // handle possible rejections when using pluggable storage
                objectsToViews(currentSplits);
        },
        /**
         * Get the Split names present on the factory storage
         */
        names: function () {
            if (!validateIfNotDestroyed(log, readinessManager, 'names') || !validateIfOperational(log, readinessManager, 'names')) {
                return [];
            }
            var splitNames = splits.getSplitNames();
            return thenable(splitNames) ?
                splitNames.catch(function () { return []; }) : // handle possible rejections when using pluggable storage
                splitNames;
        }
    });
}
