var NEW_LISTENER_EVENT = 'newListener';
var REMOVE_LISTENER_EVENT = 'removeListener';
function checkListener(listener) {
    if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
}
// @TODO implement missing methods, check spec and add UTs
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this.listeners = {};
    }
    EventEmitter.prototype.registerListener = function (type, listener, oneTime) {
        checkListener(listener);
        // To avoid recursion in the case that type === "newListener" before
        // adding it to the listeners, first emit "newListener".
        this.emit(NEW_LISTENER_EVENT, type, listener);
        if (!this.listeners[type]) {
            this.listeners[type] = [[listener, oneTime]];
        }
        else {
            this.listeners[type].push([listener, oneTime]);
        }
        return this;
    };
    EventEmitter.prototype.addListener = function (type, listener) {
        return this.registerListener(type, listener, false);
    };
    // alias of addListener
    EventEmitter.prototype.on = function (type, listener) {
        return this.addListener(type, listener);
    };
    EventEmitter.prototype.once = function (type, listener) {
        return this.registerListener(type, listener, true);
    };
    // @ts-ignore
    EventEmitter.prototype.removeListener = function ( /* type: string, listener: (...args: any[]) => void */) {
        throw new Error('Method not implemented.');
    };
    // @ts-ignore alias of removeListener
    EventEmitter.prototype.off = function ( /* type: string, listener: (...args: any[]) => void */) {
        return this.removeListener( /* type, listener */);
    };
    EventEmitter.prototype.emit = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // Returns false if the event doesn't have listeners
        if (!this.listeners[type] || this.listeners[type].length === 0)
            return false;
        // Call listeners while removing one-time listeners
        this.listeners[type] = this.listeners[type].filter(function (listenerEntry) {
            listenerEntry[0].apply(listenerEntry, args);
            return !listenerEntry[1];
        });
        return true;
    };
    EventEmitter.prototype.removeAllListeners = function (type) {
        if (!this.listeners[REMOVE_LISTENER_EVENT]) {
            // if not listening for `removeListener`, no need to emit
            if (type) {
                if (this.listeners[type])
                    delete this.listeners[type];
            }
            else {
                this.listeners = {};
            }
        }
        else {
            // emit `removeListener` for all listeners
            if (type) {
                var listeners = this.listeners[type];
                if (listeners) {
                    // LIFO order
                    for (var i = listeners.length - 1; i >= 0; i--) {
                        this.emit(REMOVE_LISTENER_EVENT, type, listeners[i]);
                    }
                    delete this.listeners[type];
                }
            }
            else {
                var keys = Object.keys(this.listeners);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (key === REMOVE_LISTENER_EVENT)
                        continue;
                    this.removeAllListeners(key);
                }
                this.listeners = {};
            }
        }
        return this;
    };
    return EventEmitter;
}());
export { EventEmitter };
