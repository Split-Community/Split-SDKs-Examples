import { IEventsCacheAsync } from '../types';
import { IMetadata } from '../../dtos/types';
import { Redis } from 'ioredis';
import { SplitIO } from '../../types';
import { ILogger } from '../../logger/types';
import { StoredEventWithMetadata } from '../../sync/submitters/types';
export declare class EventsCacheInRedis implements IEventsCacheAsync {
    private readonly log;
    private readonly key;
    private readonly redis;
    private readonly metadata;
    constructor(log: ILogger, key: string, redis: Redis, metadata: IMetadata);
    /**
     * Add a new event object into the queue.
     * Unlike `impressions::track`, result promise is never rejected.
     */
    track(eventData: SplitIO.EventData): Promise<boolean>;
    /**
     * Generates the JSON as we'll store it on Redis.
     */
    private _toJSON;
    count(): Promise<number>;
    drop(count?: number): Promise<any>;
    /**
     * Pop the given number of events from the storage.
     * The returned promise rejects if the wrapper operation fails.
     *
     * NOTE: this method doesn't take into account MAX_EVENT_SIZE or MAX_QUEUE_BYTE_SIZE limits.
     * It is the submitter responsability to handle that.
     */
    popNWithMetadata(count: number): Promise<StoredEventWithMetadata[]>;
}
