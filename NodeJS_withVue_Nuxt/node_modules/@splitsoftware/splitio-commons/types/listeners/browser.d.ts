import { ISignalListener } from './types';
import { IStorageSync } from '../storages/types';
import { ISplitApi } from '../services/types';
import { ISettings } from '../types';
import { ISyncManager } from '../sync/types';
/**
 * We'll listen for 'unload' event over the window object, since it's the standard way to listen page reload and close.
 */
export declare class BrowserSignalListener implements ISignalListener {
    private syncManager;
    private settings;
    private storage;
    private serviceApi;
    private fromImpressionsCollector;
    constructor(syncManager: ISyncManager | undefined, settings: ISettings, storage: IStorageSync, serviceApi: ISplitApi);
    /**
     * start method.
     * Called when SplitFactory is initialized.
     * We add a handler on unload events. The handler flushes remaining impressions and events to the backend.
     */
    start(): void;
    /**
     * stop method.
     * Called when client is destroyed.
     * We need to remove the handler for unload events, since it can break if called when Split context was destroyed.
     */
    stop(): void;
    /**
     * flushData method.
     * Called when unload event is triggered. It flushed remaining impressions and events to the backend,
     * using beacon API if possible, or falling back to regular post transport.
     */
    flushData(): void;
    private _flushData;
    /**
     * _sendBeacon method.
     * Util method that check if beacon API is available, build the payload and send it.
     */
    private _sendBeacon;
}
