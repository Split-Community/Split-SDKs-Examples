"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateStorage = void 0;
var isLocalStorageAvailable_1 = require("@splitsoftware/splitio-commons/cjs/utils/env/isLocalStorageAvailable");
var constants_1 = require("@splitsoftware/splitio-commons/cjs/utils/constants");
var STORAGE_LOCALSTORAGE = 'LOCALSTORAGE';
function validateStorage(settings) {
    var log = settings.log, mode = settings.mode, _a = settings.storage, _b = _a === void 0 ? { type: constants_1.STORAGE_MEMORY } : _a, type = _b.type, _c = _b.options, options = _c === void 0 ? {} : _c, prefix = _b.prefix;
    var __originalType;
    var fallbackToMemory = function () {
        __originalType = type;
        type = constants_1.STORAGE_MEMORY;
    };
    // In localhost mode, fallback to Memory storage and track original type to emit SDK_READY_FROM_CACHE if corresponds.
    // ATM, other mode settings (e.g., 'consumer') are ignored in client-side API, and so treated as standalone.
    if (mode === constants_1.LOCALHOST_MODE && type === STORAGE_LOCALSTORAGE) {
        fallbackToMemory();
    }
    // If an invalid storage type is provided OR we want to use LOCALSTORAGE and
    // it's not available, fallback into MEMORY
    if (type !== constants_1.STORAGE_MEMORY && type !== STORAGE_LOCALSTORAGE ||
        type === STORAGE_LOCALSTORAGE && !(0, isLocalStorageAvailable_1.isLocalStorageAvailable)()) {
        fallbackToMemory();
        log.error('Invalid or unavailable storage. Fallbacking into MEMORY storage');
    }
    return {
        type: type,
        options: options,
        prefix: prefix,
        __originalType: __originalType
    };
}
exports.validateStorage = validateStorage;
