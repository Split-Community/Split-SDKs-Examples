"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _impressions = _interopRequireDefault(require("../impressions"));

var _counter = _interopRequireDefault(require("../../impressions/counter"));

var _constants = require("../../utils/context/constants");

var _constants2 = require("../../utils/constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* Mocks start */
var generateContextMocks = function generateContextMocks() {
  // We are only mocking the pieces we care about
  var fakeSettings = {
    mode: _constants2.STANDALONE_MODE,
    runtime: {
      ip: 'fake-ip',
      hostname: 'fake-hostname'
    },
    version: 'js-test-10.4.0',
    impressionListener: {
      logImpression: _sinon.default.stub()
    },
    sync: {
      impressionsMode: _constants2.DEBUG
    }
  };
  var fakeStorage = {
    impressions: {
      track: _sinon.default.stub()
    }
  };
  var fakeIntegrationsManager = {
    handleImpression: _sinon.default.stub()
  };
  return {
    fakeSettings: fakeSettings,
    fakeStorage: fakeStorage,
    fakeIntegrationsManager: fakeIntegrationsManager
  };
};

var ContextMock = /*#__PURE__*/function () {
  function ContextMock(fakeStorage, fakeSettings, fakeIntegrationsManager) {
    (0, _classCallCheck2.default)(this, ContextMock);
    this.constants = {
      STORAGE: _constants.STORAGE,
      SETTINGS: _constants.SETTINGS,
      INTEGRATIONS_MANAGER: _constants.INTEGRATIONS_MANAGER,
      IMPRESSIONS_COUNTER: _constants.IMPRESSIONS_COUNTER
    };
    this.impressionsCounter = new _counter.default();
    this.fakeStorage = fakeStorage;
    this.fakeSettings = fakeSettings;
    this.fakeIntegrationsManager = fakeIntegrationsManager;
  }

  (0, _createClass2.default)(ContextMock, [{
    key: "get",
    value: function get(target) {
      switch (target) {
        case _constants.STORAGE:
          return this.fakeStorage;

        case _constants.SETTINGS:
          return this.fakeSettings;

        case _constants.INTEGRATIONS_MANAGER:
          return this.fakeIntegrationsManager;

        case _constants.IMPRESSIONS_COUNTER:
          return this.impressionsCounter;

        default:
          break;
      }
    }
  }]);
  return ContextMock;
}();
/* Mocks end */


(0, _tapeCatch.default)('Impressions Tracker', function (t) {
  t.test('Tracker API', function (assert) {
    assert.equal((0, _typeof2.default)(_impressions.default), 'function', 'The module should return a function which acts as a factory.');

    var _generateContextMocks = generateContextMocks(),
        fakeStorage = _generateContextMocks.fakeStorage,
        fakeSettings = _generateContextMocks.fakeSettings;

    var contextMock = new ContextMock(fakeStorage, fakeSettings);
    var instance = (0, _impressions.default)(contextMock);
    assert.equal((0, _typeof2.default)(instance.queue), 'function', 'The instance should implement the queue method, as it is used for multiple impressions collecting.');
    assert.equal((0, _typeof2.default)(instance.track), 'function', 'The instance should implement the track method which will actually track queued impressions.');
    assert.end();
  });
  t.test('Should be able to queue elements and track them on demand.', function (assert) {
    var _generateContextMocks2 = generateContextMocks(),
        fakeStorage = _generateContextMocks2.fakeStorage,
        fakeSettings = _generateContextMocks2.fakeSettings;

    var contextMock = new ContextMock(fakeStorage, fakeSettings);
    var tracker = (0, _impressions.default)(contextMock);
    var imp1 = {
      feature: '10'
    };
    var imp2 = {
      feature: '20'
    };
    var imp3 = {
      feature: '30'
    };
    tracker.queue(imp1);
    tracker.queue(imp2);
    tracker.queue(imp3);
    assert.false(fakeStorage.impressions.track.called, 'storage method should not be called by just queueing items.');
    tracker.track();
    assert.true(fakeStorage.impressions.track.calledWithMatch([imp1, imp2, imp3]), 'Should call the storage track method once we invoke .track() method, passing queued params in a sequence.');
    assert.end();
  });
  var fakeImpression = {
    fake: 'impression'
  };
  var fakeImpression2 = {
    fake: 'impression_2'
  };
  var fakeAttributes = {
    fake: 'attributes'
  };
  t.test('Queued impressions should be sent to impression listener and integration manager when we invoke .track()', function (assert) {
    var _generateContextMocks3 = generateContextMocks(),
        fakeStorage = _generateContextMocks3.fakeStorage,
        fakeSettings = _generateContextMocks3.fakeSettings,
        fakeIntegrationsManager = _generateContextMocks3.fakeIntegrationsManager;

    var contextMock = new ContextMock(fakeStorage, fakeSettings, fakeIntegrationsManager);
    var tracker = (0, _impressions.default)(contextMock);
    tracker.queue(fakeImpression, fakeAttributes);
    tracker.queue(fakeImpression2, fakeAttributes);
    assert.false(fakeStorage.impressions.track.called, 'The storage should not be invoked while we are queueing impressions.');
    assert.false(fakeSettings.impressionListener.logImpression.called, 'The listener should not be invoked synchronously while we are queueing impressions.');
    assert.false(fakeIntegrationsManager.handleImpression.called, 'The integrations manager handleImpression method should not be invoked while we are queueing impressions.');
    setTimeout(function () {
      assert.false(fakeSettings.impressionListener.logImpression.called, 'The listener should not be invoked asynchronously either while we are queueing impressions.');
      assert.false(fakeIntegrationsManager.handleImpression.called, 'The integrations manager handleImpression method should not be invoked asynchronously either while we are queueing impressions.'); // We signal that we actually want to track the queued impressions.

      tracker.track();
      assert.true(fakeStorage.impressions.track.calledWithMatch([fakeImpression, fakeImpression2]), 'Even with a listener, impression should be present in the collector sequence and sent to the storage');
      assert.false(fakeSettings.impressionListener.logImpression.called, 'The listener should not be executed synchronously.');
      assert.false(fakeIntegrationsManager.handleImpression.called, 'The integrations manager handleImpression method should not be executed synchronously.');
      setTimeout(function () {
        assert.true(fakeSettings.impressionListener.logImpression.calledTwice, 'The listener should be executed after the timeout wrapping make it to the queue stack, once per each impression quued.');
        assert.true(fakeIntegrationsManager.handleImpression.calledTwice, 'The integrations manager handleImpression method should be executed after the timeout wrapping make it to the queue stack, once per each impression quued.');

        var impressionData1 = _objectSpread({
          impression: fakeImpression,
          attributes: fakeAttributes,
          sdkLanguageVersion: fakeSettings.version
        }, fakeSettings.runtime);

        var impressionData2 = _objectSpread({
          impression: fakeImpression2,
          attributes: fakeAttributes,
          sdkLanguageVersion: fakeSettings.version
        }, fakeSettings.runtime);

        assert.deepEqual(fakeSettings.impressionListener.logImpression.getCall(0).args[0], impressionData1, 'The listener should be executed with the corresponding map for each of the impressions.');
        assert.deepEqual(fakeSettings.impressionListener.logImpression.getCall(1).args[0], impressionData2, 'The listener should be executed with the corresponding map for each of the impressions.');
        assert.notEqual(fakeSettings.impressionListener.logImpression.getCall(0).args[0].impression, fakeImpression, 'but impression should be a copy');
        assert.notEqual(fakeSettings.impressionListener.logImpression.getCall(1).args[0].impression, fakeImpression2, 'but impression should be a copy');
        assert.deepEqual(fakeIntegrationsManager.handleImpression.getCall(0).args[0], impressionData1, 'The integration manager handleImpression method should be executed with the corresponding map for each of the impressions.');
        assert.deepEqual(fakeIntegrationsManager.handleImpression.getCall(1).args[0], impressionData2, 'The integration manager handleImpression method should be executed with the corresponding map for each of the impressions.');
        assert.notEqual(fakeIntegrationsManager.handleImpression.getCall(0).args[0].impression, fakeImpression, 'but impression should be a copy');
        assert.notEqual(fakeIntegrationsManager.handleImpression.getCall(1).args[0].impression, fakeImpression2, 'but impression should be a copy');
        assert.end();
      }, 0);
    }, 0);
  });
  t.test('Should track 3 impressions.', function (assert) {
    var _generateContextMocks4 = generateContextMocks(),
        fakeStorage = _generateContextMocks4.fakeStorage,
        fakeSettings = _generateContextMocks4.fakeSettings;

    var contextMock = new ContextMock(fakeStorage, fakeSettings);
    var tracker = (0, _impressions.default)(contextMock);
    var impression = {
      feature: 'qc_team',
      keyName: 'marcio@split.io',
      treatment: 'no',
      time: 123456789,
      bucketingKey: 'impr_bucketing_2',
      label: 'default rule'
    };
    var impression2 = {
      feature: 'qc_team_2',
      keyName: 'marcio@split.io',
      treatment: 'yes',
      time: 123456789,
      bucketingKey: 'impr_bucketing_2',
      label: 'default rule'
    };
    var impression3 = {
      feature: 'qc_team',
      keyName: 'marcio@split.io',
      treatment: 'no',
      time: 1234567891,
      bucketingKey: 'impr_bucketing_2',
      label: 'default rule'
    };
    tracker.queue(impression);
    tracker.queue(impression2);
    tracker.queue(impression3);
    assert.false(fakeStorage.impressions.track.called, 'storage method should not be called by just queueing items.');
    tracker.track();
    var lastArgs = fakeStorage.impressions.track.lastCall.lastArg;
    assert.equal(lastArgs.length, 3);
    assert.equal(lastArgs[0].pt, undefined);
    assert.equal(lastArgs[0].feature, 'qc_team');
    assert.equal(lastArgs[1].pt, undefined);
    assert.equal(lastArgs[1].feature, 'qc_team_2');
    assert.equal(lastArgs[2].pt, 123456789);
    assert.equal(lastArgs[2].feature, 'qc_team');
    assert.end();
  });
  t.test('Should track 2 impressions in OPTIMIZED.', function (assert) {
    var _generateContextMocks5 = generateContextMocks(),
        fakeStorage = _generateContextMocks5.fakeStorage,
        fakeSettings = _generateContextMocks5.fakeSettings;

    fakeSettings.sync = {
      impressionsMode: _constants2.OPTIMIZED
    };
    var contextMock = new ContextMock(fakeStorage, fakeSettings);
    var tracker = (0, _impressions.default)(contextMock);
    var impression = {
      feature: 'qc_team',
      keyName: 'marcio@split.io',
      treatment: 'no',
      time: Date.now(),
      bucketingKey: 'impr_bucketing_2',
      label: 'default rule'
    };
    var impression2 = {
      feature: 'qc_team_2',
      keyName: 'marcio@split.io',
      treatment: 'yes',
      time: Date.now(),
      bucketingKey: 'impr_bucketing_2',
      label: 'default rule'
    };
    var impression3 = {
      feature: 'qc_team',
      keyName: 'marcio@split.io',
      treatment: 'no',
      time: Date.now(),
      bucketingKey: 'impr_bucketing_2',
      label: 'default rule'
    };
    tracker.queue(impression);
    tracker.queue(impression2);
    tracker.queue(impression3);
    assert.false(fakeStorage.impressions.track.called, 'storage method should not be called by just queueing items.');
    tracker.track();
    var lastArgs = fakeStorage.impressions.track.lastCall.lastArg;
    assert.equal(lastArgs.length, 2);
    assert.equal(lastArgs[0].pt, undefined);
    assert.equal(lastArgs[0].feature, 'qc_team');
    assert.equal(lastArgs[1].pt, undefined);
    assert.equal(lastArgs[1].feature, 'qc_team_2');
    var impressionsCounter = contextMock.get(_constants.IMPRESSIONS_COUNTER);
    assert.equal(impressionsCounter.size(), 2);
    assert.end();
  });
});