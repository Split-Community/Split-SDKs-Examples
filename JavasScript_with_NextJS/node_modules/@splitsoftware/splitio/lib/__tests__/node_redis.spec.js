"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _os = _interopRequireDefault(require("os"));

var _ip = _interopRequireDefault(require("ip"));

var _tape = _interopRequireDefault(require("tape"));

var _sinon = _interopRequireDefault(require("sinon"));

var _redisServer = _interopRequireDefault(require("redis-server"));

var _ioredis = _interopRequireDefault(require("ioredis"));

var _child_process = require("child_process");

var _ = require("../");

var _lang = require("../utils/lang");

var _Keys = _interopRequireDefault(require("../storage/Keys"));

var _settings = _interopRequireDefault(require("../utils/settings"));

var _testUtils = require("./testUtils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var IP_VALUE = _ip.default.address();

var HOSTNAME_VALUE = _os.default.hostname();

var NA = 'NA';
var redisPort = '6385';
var config = {
  core: {
    authorizationKey: 'uoj4sb69bjv7d4d027f7ukkitd53ek6a9ai9'
  },
  urls: {
    sdk: 'https://sdk-aws-staging.split.io/api',
    events: 'https://events-aws-staging.split.io/api'
  },
  mode: 'consumer',
  storage: {
    type: 'REDIS',
    prefix: 'REDIS_NODE_UT',
    options: {
      url: "redis://localhost:".concat(redisPort, "/0")
    }
  },
  startup: {
    readyTimeout: 36000 // 10hs

  }
};
/**
 * Initialize redis server and run a cli bash command to load redis with data to do the proper tests
 */

var initializeRedisServer = function initializeRedisServer() {
  // Simply pass the port that you want a Redis server to listen on.
  var server = new _redisServer.default(redisPort);
  var promise = new Promise(function (resolve, reject) {
    server.open().then(function () {
      (0, _child_process.exec)("cat ./src/__tests__/mocks/redis-commands.txt | redis-cli -p ".concat(redisPort), function (err) {
        if (err) {
          reject(server); // node couldn't execute the command

          return;
        }

        resolve(server);
      });
    });
  });
  return promise;
};

(0, _tape.default)('NodeJS Redis', function (t) {
  t.test('Regular usage', function (assert) {
    initializeRedisServer().then( /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(server) {
        var expectedConfig, sdk, client;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                expectedConfig = '{"color":"brown"}';
                sdk = (0, _.SplitFactory)(config);
                client = sdk.client();
                _context.t0 = assert;
                _context.next = 6;
                return client.getTreatment('UT_Segment_member', 'UT_IN_SEGMENT');

              case 6:
                _context.t1 = _context.sent;

                _context.t0.equal.call(_context.t0, _context.t1, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t2 = assert;
                _context.next = 11;
                return client.getTreatment('other', 'UT_IN_SEGMENT');

              case 11:
                _context.t3 = _context.sent;

                _context.t2.equal.call(_context.t2, _context.t3, 'off', 'Evaluations using Redis storage should be correct.');

                _context.t4 = assert;
                _context.next = 16;
                return client.getTreatment('UT_Segment_member', 'UT_NOT_IN_SEGMENT');

              case 16:
                _context.t5 = _context.sent;

                _context.t4.equal.call(_context.t4, _context.t5, 'off', 'Evaluations using Redis storage should be correct.');

                _context.t6 = assert;
                _context.next = 21;
                return client.getTreatment('other', 'UT_NOT_IN_SEGMENT');

              case 21:
                _context.t7 = _context.sent;

                _context.t6.equal.call(_context.t6, _context.t7, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t8 = assert;
                _context.next = 26;
                return client.getTreatment('UT_Segment_member', 'UT_SET_MATCHER', {
                  permissions: ['admin']
                });

              case 26:
                _context.t9 = _context.sent;

                _context.t8.equal.call(_context.t8, _context.t9, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t10 = assert;
                _context.next = 31;
                return client.getTreatment('UT_Segment_member', 'UT_SET_MATCHER', {
                  permissions: ['not_matching']
                });

              case 31:
                _context.t11 = _context.sent;

                _context.t10.equal.call(_context.t10, _context.t11, 'off', 'Evaluations using Redis storage should be correct.');

                _context.t12 = assert;
                _context.next = 36;
                return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                  permissions: ['create']
                });

              case 36:
                _context.t13 = _context.sent;

                _context.t12.equal.call(_context.t12, _context.t13, 'off', 'Evaluations using Redis storage should be correct.');

                _context.t14 = assert;
                _context.next = 41;
                return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                  permissions: ['not_matching']
                });

              case 41:
                _context.t15 = _context.sent;

                _context.t14.equal.call(_context.t14, _context.t15, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t16 = assert;
                _context.next = 46;
                return client.getTreatmentWithConfig('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                  permissions: ['not_matching']
                });

              case 46:
                _context.t17 = _context.sent;
                _context.t18 = {
                  treatment: 'on',
                  config: null
                };

                _context.t16.deepEqual.call(_context.t16, _context.t17, _context.t18, 'Evaluations using Redis storage should be correct, including configs.');

                _context.t19 = assert;
                _context.next = 52;
                return client.getTreatmentWithConfig('UT_Segment_member', 'always-on-with-config');

              case 52:
                _context.t20 = _context.sent;
                _context.t21 = {
                  treatment: 'on',
                  config: expectedConfig
                };

                _context.t19.deepEqual.call(_context.t19, _context.t20, _context.t21, 'Evaluations using Redis storage should be correct, including configs.');

                _context.t22 = assert;
                _context.next = 58;
                return client.getTreatment('UT_Segment_member', 'always-on');

              case 58:
                _context.t23 = _context.sent;

                _context.t22.equal.call(_context.t22, _context.t23, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t24 = assert;
                _context.next = 63;
                return client.getTreatment('UT_Segment_member', 'hierarchical_splits_testing_on');

              case 63:
                _context.t25 = _context.sent;

                _context.t24.equal.call(_context.t24, _context.t25, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t26 = assert;
                _context.next = 68;
                return client.getTreatment('UT_Segment_member', 'hierarchical_splits_testing_off');

              case 68:
                _context.t27 = _context.sent;

                _context.t26.equal.call(_context.t26, _context.t27, 'off', 'Evaluations using Redis storage should be correct.');

                _context.t28 = assert;
                _context.next = 73;
                return client.getTreatment('UT_Segment_member', 'hierarchical_splits_testing_on_negated');

              case 73:
                _context.t29 = _context.sent;

                _context.t28.equal.call(_context.t28, _context.t29, 'off', 'Evaluations using Redis storage should be correct.');

                assert.equal((0, _typeof2.default)(client.track('nicolas@split.io', 'user', 'test.redis.event', 18).then), 'function', 'Track calls should always return a promise on Redis mode.');
                assert.equal((0, _typeof2.default)(client.track().then), 'function', 'Track calls should always return a promise on Redis mode, even when parameters are incorrect.');
                _context.t30 = assert;
                _context.next = 80;
                return client.track('nicolas@split.io', 'user', 'test.redis.event', 18);

              case 80:
                _context.t31 = _context.sent;

                _context.t30.true.call(_context.t30, _context.t31, 'If the event was succesfully queued the promise will resolve to true');

                _context.t32 = assert;
                _context.next = 85;
                return client.track();

              case 85:
                _context.t33 = _context.sent;

                _context.t32.false.call(_context.t32, _context.t33, 'If the event was NOT succesfully queued the promise will resolve to false');

                _context.next = 89;
                return client.ready();

              case 89:
                _context.next = 91;
                return client.destroy();

              case 91:
                // close server connection
                server.close().then(assert.end);

              case 92:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  t.test('Connection ready and timed out', function (assert) {
    var readyTimeout = 0.1; // 100 millis

    var configWithShortTimeout = _objectSpread(_objectSpread({}, config), {}, {
      startup: {
        readyTimeout: readyTimeout
      }
    });

    var sdk = (0, _.SplitFactory)(configWithShortTimeout);
    var client = sdk.client();
    var start = Date.now();
    var readyTimestamp;
    var redisServer;
    assert.plan(19);
    client.getTreatment('UT_Segment_member', 'always-on').then(function (treatment) {
      assert.equal(treatment, 'on', 'Evaluations using Redis storage should be correct and resolved once Redis connection is stablished');
    });
    client.track('nicolas@split.io', 'user', 'test.redis.event', 18).then(function (result) {
      assert.true(result, 'If the event was succesfully queued the promise will resolve to true once Redis connection is stablished');
    }); // SDK_READY_TIMED_OUT event must be emitted after 100 millis

    client.on(client.Event.SDK_READY_TIMED_OUT, function () {
      var delay = Date.now() - start;
      assert.true((0, _testUtils.nearlyEqual)(delay, readyTimeout * 1000), 'SDK_READY_TIMED_OUT event must be emitted after 100 millis');
    }); // alse, ready promise must be rejected after 100 millis

    client.ready().catch(function () {
      var delay = Date.now() - start;
      assert.true((0, _testUtils.nearlyEqual)(delay, readyTimeout * 1000), 'Ready promise must be rejected after 100 millis'); // initialize server to emit SDK_READY

      initializeRedisServer().then( /*#__PURE__*/function () {
        var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(server) {
          return _regenerator.default.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  readyTimestamp = Date.now();
                  redisServer = server;
                  _context2.prev = 2;
                  _context2.next = 5;
                  return client.ready();

                case 5:
                  assert.fail('Ready promise keeps being rejected until SDK_READY is emitted');
                  _context2.next = 11;
                  break;

                case 8:
                  _context2.prev = 8;
                  _context2.t0 = _context2["catch"](2);
                  assert.pass('Ready promise keeps being rejected until SDK_READY is emitted');

                case 11:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[2, 8]]);
        }));

        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());
    }); // subscribe to SDK_READY event to assert regular usage

    client.on(client.Event.SDK_READY, /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
      var delay;
      return _regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              delay = Date.now() - readyTimestamp;
              assert.true((0, _testUtils.nearlyEqual)(delay, 0, 100), 'SDK_READY event must be emitted soon once Redis server is connected');
              _context3.next = 4;
              return client.ready();

            case 4:
              assert.pass('Ready promise is resolved once SDK_READY is emitted'); // some asserts to test regular usage

              _context3.t0 = assert;
              _context3.next = 8;
              return client.getTreatment('UT_Segment_member', 'UT_IN_SEGMENT');

            case 8:
              _context3.t1 = _context3.sent;

              _context3.t0.equal.call(_context3.t0, _context3.t1, 'on', 'Evaluations using Redis storage should be correct.');

              _context3.t2 = assert;
              _context3.next = 13;
              return client.getTreatment('other', 'UT_IN_SEGMENT');

            case 13:
              _context3.t3 = _context3.sent;

              _context3.t2.equal.call(_context3.t2, _context3.t3, 'off', 'Evaluations using Redis storage should be correct.');

              _context3.t4 = assert;
              _context3.next = 18;
              return client.track('nicolas@split.io', 'user', 'test.redis.event', 18);

            case 18:
              _context3.t5 = _context3.sent;

              _context3.t4.true.call(_context3.t4, _context3.t5, 'If the event was succesfully queued the promise will resolve to true');

              _context3.t6 = assert;
              _context3.next = 23;
              return client.track();

            case 23:
              _context3.t7 = _context3.sent;

              _context3.t6.false.call(_context3.t6, _context3.t7, 'If the event was NOT succesfully queued the promise will resolve to false');

              _context3.next = 27;
              return client.destroy();

            case 27:
              assert.pass();

            case 28:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }))); // create a new factory with a very short readyTimedout config to emit SDK_READY_TIMED_OUT even with the Redis server on

    client.on(client.Event.SDK_READY, /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
      var configWithVeryShortTimeout, sdk2, client2;
      return _regenerator.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              configWithVeryShortTimeout = _objectSpread(_objectSpread({}, config), {}, {
                startup: {
                  readyTimeout: 0.001
                },
                core: {
                  authorizationKey: 'aaa4sb69bjv7d4d027f7ukkitd53ek6a9ai9'
                }
              });
              sdk2 = (0, _.SplitFactory)(configWithVeryShortTimeout);
              client2 = sdk2.client();
              client2.on(client2.Event.SDK_READY_TIMED_OUT, function () {
                assert.pass('SDK_READY_TIMED_OUT event must be emitted');
              });
              client2.on(client2.Event.SDK_READY, /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
                return _regenerator.default.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        assert.pass('SDK_READY event must be emitted'); // some asserts to test regular usage

                        _context4.t0 = assert;
                        _context4.next = 4;
                        return client2.getTreatment('UT_Segment_member', 'UT_IN_SEGMENT');

                      case 4:
                        _context4.t1 = _context4.sent;

                        _context4.t0.equal.call(_context4.t0, _context4.t1, 'on', 'Evaluations using Redis storage should be correct.');

                        _context4.t2 = assert;
                        _context4.next = 9;
                        return client2.getTreatment('other', 'UT_IN_SEGMENT');

                      case 9:
                        _context4.t3 = _context4.sent;

                        _context4.t2.equal.call(_context4.t2, _context4.t3, 'off', 'Evaluations using Redis storage should be correct.');

                        _context4.t4 = assert;
                        _context4.next = 14;
                        return client2.track('nicolas@split.io', 'user', 'test.redis.event', 18);

                      case 14:
                        _context4.t5 = _context4.sent;

                        _context4.t4.true.call(_context4.t4, _context4.t5, 'If the event was succesfully queued the promise will resolve to true');

                        _context4.t6 = assert;
                        _context4.next = 19;
                        return client2.track();

                      case 19:
                        _context4.t7 = _context4.sent;

                        _context4.t6.false.call(_context4.t6, _context4.t7, 'If the event was NOT succesfully queued the promise will resolve to false');

                        _context4.next = 23;
                        return client2.destroy();

                      case 23:
                        // close server connection
                        redisServer.close().then(function () {
                          assert.pass();
                          assert.end();
                        });

                      case 24:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              })));

            case 5:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    })));
  });
  t.test('Connection error', function (assert) {
    initializeRedisServer().then(function (server) {
      var sdk = (0, _.SplitFactory)(config);
      var client = sdk.client();
      client.once(client.Event.SDK_READY_TIMED_OUT, assert.fail);
      client.ready().then(assert.pass).catch(assert.fail);
      var start = Date.now();
      client.once(client.Event.SDK_READY, /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
        var delay;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return client.ready();

              case 2:
                delay = Date.now() - start;
                assert.true((0, _testUtils.nearlyEqual)(delay, 0), 'Ready promise is resolved once SDK_READY is emitted, and it is emitted almost immediately after the SDK is created');
                _context7.t0 = assert;
                _context7.next = 7;
                return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                  permissions: ['create']
                });

              case 7:
                _context7.t1 = _context7.sent;

                _context7.t0.equal.call(_context7.t0, _context7.t1, 'off', 'Control assertion - Everything working as expected.');

                _context7.t2 = assert;
                _context7.next = 12;
                return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                  permissions: ['not_matching']
                });

              case 12:
                _context7.t3 = _context7.sent;

                _context7.t2.equal.call(_context7.t2, _context7.t3, 'on', 'Control assertion - Everything working as expected.');

                _context7.t4 = assert;
                _context7.next = 17;
                return client.getTreatment('UT_Segment_member', 'always-on');

              case 17:
                _context7.t5 = _context7.sent;

                _context7.t4.equal.call(_context7.t4, _context7.t5, 'on', 'Control assertion - Everything working as expected.');

                _context7.t6 = assert;
                _context7.next = 22;
                return client.track('nicolas@split.io', 'user', 'test.redis.event', 18);

              case 22:
                _context7.t7 = _context7.sent;

                _context7.t6.true.call(_context7.t6, _context7.t7, 'Control assertion - Everything working as expected.');

                _context7.t8 = assert;
                _context7.next = 27;
                return client.track();

              case 27:
                _context7.t9 = _context7.sent;

                _context7.t8.notEqual.call(_context7.t8, _context7.t9, 'Control assertion - Everything working as expected.');

                // close server connection
                server.close().then(function () {
                  // we need to add a delay before doing a getTreatment
                  setTimeout( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
                    return _regenerator.default.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.t0 = assert;
                            _context6.next = 3;
                            return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                              permissions: ['create']
                            });

                          case 3:
                            _context6.t1 = _context6.sent;

                            _context6.t0.equal.call(_context6.t0, _context6.t1, 'control', 'In the event of a Redis error like a disconnection, getTreatments should not hang but resolve to "control".');

                            _context6.t2 = assert;
                            _context6.next = 8;
                            return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                              permissions: ['not_matching']
                            });

                          case 8:
                            _context6.t3 = _context6.sent;

                            _context6.t2.equal.call(_context6.t2, _context6.t3, 'control', 'In the event of a Redis error like a disconnection, getTreatments should not hang but resolve to "control".');

                            _context6.t4 = assert;
                            _context6.next = 13;
                            return client.getTreatment('UT_Segment_member', 'always-on');

                          case 13:
                            _context6.t5 = _context6.sent;

                            _context6.t4.equal.call(_context6.t4, _context6.t5, 'control', 'In the event of a Redis error like a disconnection, getTreatments should not hang but resolve to "control".');

                            _context6.t6 = assert;
                            _context6.next = 18;
                            return client.track('nicolas@split.io', 'user', 'test.redis.event', 18);

                          case 18:
                            _context6.t7 = _context6.sent;

                            _context6.t6.false.call(_context6.t6, _context6.t7, 'In the event of a Redis error like a disconnection, track should resolve to false.');

                            _context6.next = 22;
                            return client.destroy();

                          case 22:
                            assert.end();

                          case 23:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  })), 1000);
                });

              case 30:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      })));
    });
  });
  t.test('Calling destroy with pending operations', function (assert) {
    initializeRedisServer().then( /*#__PURE__*/function () {
      var _ref8 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(server) {
        var sdk, client;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                sdk = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, config), {}, {
                  debug: 'WARN' // we want to see the error/warning logs calling the actual log method (if there's any)

                }));
                client = sdk.client();
                _context8.prev = 2;
                _context8.next = 5;
                return client.ready();

              case 5:
                _context8.next = 10;
                break;

              case 7:
                _context8.prev = 7;
                _context8.t0 = _context8["catch"](2);
                assert.fail(_context8.t0);

              case 10:
                process.on('unhandledRejection', assert.fail);
                process.on('uncaughtException', assert.fail);

                _sinon.default.spy(console, 'log');

                _context8.next = 15;
                return client.getTreatment('Tito_the_skeleton', 'always-on');

              case 15:
                client.destroy();
                setTimeout(function () {
                  process.off('unhandledRejection', assert.fail);
                  process.off('uncaughtException', assert.fail);
                  assert.pass('Check unhandledRejection or uncaughtException detected. None is expected');
                  assert.false(console.log.calledWithMatch('threw or exceeded configured timeout of 5000ms setting. Message: Error: Stream isn\'t writeable and enableOfflineQueue options is false'), 'No error should have been triggered from Redis.');
                  console.log.restore(); // close server connection and wrap up.

                  server.close().then(assert.end);
                }, 2000);

              case 17:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, null, [[2, 7]]);
      }));

      return function (_x3) {
        return _ref8.apply(this, arguments);
      };
    }());
  });
  t.test('Check IP and Hostname in Redis', function (assert) {
    initializeRedisServer().then( /*#__PURE__*/function () {
      var _ref9 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9(server) {
        var configs, _i, _configs, _config, setting, connection, keys, eventKey, impressionsKey, sdk, client, redisImpressions, parsedImpression, redisEvents, parsedEvent;

        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                configs = [config, (0, _lang.merge)({}, config, {
                  core: {
                    IPAddressesEnabled: true
                  }
                }), (0, _lang.merge)({}, config, {
                  core: {
                    IPAddressesEnabled: false
                  }
                })];
                _i = 0, _configs = configs;

              case 2:
                if (!(_i < _configs.length)) {
                  _context9.next = 38;
                  break;
                }

                _config = _configs[_i];
                // Redis client and keys required to check Redis store.
                setting = (0, _settings.default)(_config);
                connection = new _ioredis.default(setting.storage.options.url);
                keys = new _Keys.default(setting);
                eventKey = keys.buildEventsKey();
                impressionsKey = keys.buildImpressionsKey(); // Clean up list of events and impressions.

                connection.del(eventKey);
                connection.del(impressionsKey); // Init Split client for current config

                sdk = (0, _.SplitFactory)(_config);
                client = sdk.client(); // Perform client actions to store a single event and impression objects into Redis

                _context9.next = 15;
                return client.getTreatment('UT_Segment_member', 'UT_IN_SEGMENT');

              case 15:
                _context9.next = 17;
                return client.track('nicolas@split.io', 'user', 'test.redis.event', 18);

              case 17:
                _context9.next = 19;
                return connection.lrange(impressionsKey, 0, -1);

              case 19:
                redisImpressions = _context9.sent;
                assert.equal(redisImpressions.length, 1, 'After getting a treatment, we should have one impression on Redis.');
                parsedImpression = JSON.parse(redisImpressions[0]);
                assert.equal(parsedImpression.m.i, setting.core.IPAddressesEnabled ? IP_VALUE : NA, "If IPAddressesEnabled is true, the property .m.i of the impression object must be equal to the machine ip, or \"".concat(NA, "\" otherwise."));
                assert.equal(parsedImpression.m.n, setting.core.IPAddressesEnabled ? HOSTNAME_VALUE : NA, "If IPAddressesEnabled is true, the property .m.n of the impression object must be equal to the machine hostname, or \"".concat(NA, "\" otherwise.")); // Assert if the event object was stored properly

                _context9.next = 26;
                return connection.lrange(eventKey, 0, -1);

              case 26:
                redisEvents = _context9.sent;
                assert.equal(redisEvents.length, 1, 'After tracking an event, we should have one event on Redis.');
                parsedEvent = JSON.parse(redisEvents[0]);
                assert.equal(parsedEvent.m.i, setting.core.IPAddressesEnabled ? IP_VALUE : NA, "If IPAddressesEnabled is true, the property .m.i of the event object must be equal to the machine ip, or \"".concat(NA, "\" otherwise."));
                assert.equal(parsedEvent.m.n, setting.core.IPAddressesEnabled ? HOSTNAME_VALUE : NA, "If IPAddressesEnabled is true, the property .m.n of the event object must be equal to the machine hostname, or \"".concat(NA, "\" otherwise.")); // Deallocate Split and Redis clients

                _context9.next = 33;
                return client.destroy();

              case 33:
                _context9.next = 35;
                return connection.quit();

              case 35:
                _i++;
                _context9.next = 2;
                break;

              case 38:
                // close server connection
                server.close().then(assert.end);

              case 39:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      return function (_x4) {
        return _ref9.apply(this, arguments);
      };
    }());
  });
});