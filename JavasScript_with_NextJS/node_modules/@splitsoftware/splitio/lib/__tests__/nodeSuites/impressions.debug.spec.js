"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _ = require("../..");

var _settings = _interopRequireDefault(require("../../utils/settings"));

var _splitchangesSince = _interopRequireDefault(require("../mocks/splitchanges.since.-1.json"));

var _splitchangesSince2 = _interopRequireDefault(require("../mocks/splitchanges.since.1457552620999.json"));

var _constants = require("../../utils/constants");

var baseUrls = {
  sdk: 'https://sdk.baseurl/impressionsSuite',
  events: 'https://events.baseurl/impressionsSuite'
};
var settings = (0, _settings.default)({
  core: {
    key: '<fake id>'
  },
  urls: baseUrls,
  streamingEnabled: false
});
var config = {
  core: {
    authorizationKey: '<fake-token-2>'
  },
  scheduler: {
    featuresRefreshRate: 1,
    segmentsRefreshRate: 1,
    metricsRefreshRate: 3000,
    impressionsRefreshRate: 5
  },
  urls: baseUrls,
  startup: {
    eventsFirstPushWindow: 3000
  },
  sync: {
    impressionsMode: _constants.DEBUG
  },
  streamingEnabled: false
};

function _default(_x, _x2, _x3) {
  return _ref.apply(this, arguments);
}

function _ref() {
  _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(key, fetchMock, assert) {
    var splitio, client, evaluationsStart, readyEvaluationsStart, evaluationsEnd;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // Mocking this specific route to make sure we only get the items we want to test from the handlers.
            fetchMock.getOnce(settings.url('/splitChanges?since=-1'), {
              status: 200,
              body: _splitchangesSince.default
            });
            fetchMock.get(settings.url('/splitChanges?since=1457552620999'), {
              status: 200,
              body: _splitchangesSince2.default
            });
            fetchMock.get(new RegExp("".concat(settings.url('/segmentChanges/'), ".*")), {
              status: 200,
              body: {
                since: 10,
                till: 10,
                name: 'segmentName',
                added: [],
                removed: []
              }
            });
            splitio = (0, _.SplitFactory)(config);
            client = splitio.client();
            evaluationsStart = 0, readyEvaluationsStart = 0, evaluationsEnd = 0;
            fetchMock.postOnce(settings.url('/testImpressions/bulk'), function (url, opts) {
              assert.equal(opts.headers.SplitSDKImpressionsMode, _constants.DEBUG);
              var data = JSON.parse(opts.body);
              assert.equal(data.length, 1, 'We performed evaluations for one split, so we should have 1 item total.'); // finding these validate the feature names collection too

              var alwaysOnWithConfigImpr = data.filter(function (e) {
                return e.f === 'split_with_config';
              })[0];
              assert.equal(alwaysOnWithConfigImpr.i.length, 3);

              function validateImpressionData(output, expected) {
                var performedWhenReady = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
                assert.equal(output.k, expected.keyName, 'Present impressions should have the correct key.');
                assert.equal(output.b, expected.bucketingKey, 'Present impressions should have the correct bucketingKey.');
                assert.equal(output.t, expected.treatment, 'Present impressions should have the correct treatment.');
                assert.equal(output.r, expected.label, 'Present impressions should have the correct label.');
                assert.equal(output.c, expected.changeNumber, 'Present impressions should have the correct changeNumber.');
                assert.equal(output.pt, expected.pt, 'Present impressions should have the correct previousTime.');
                assert.true(output.m >= (performedWhenReady ? readyEvaluationsStart : evaluationsStart) && output.m <= evaluationsEnd, 'Present impressions should have the correct timestamp (test with error margin).');
              }

              validateImpressionData(alwaysOnWithConfigImpr.i[0], {
                keyName: 'facundo@split.io',
                label: 'another expected label',
                treatment: 'on',
                bucketingKey: 'test_buck_key',
                changeNumber: 828282828282,
                pt: undefined
              });
              validateImpressionData(alwaysOnWithConfigImpr.i[1], {
                keyName: 'facundo@split.io',
                label: 'another expected label',
                treatment: 'on',
                bucketingKey: 'test_buck_key',
                changeNumber: 828282828282,
                pt: alwaysOnWithConfigImpr.i[0].m
              });
              validateImpressionData(alwaysOnWithConfigImpr.i[2], {
                keyName: 'facundo@split.io',
                label: 'another expected label',
                treatment: 'on',
                bucketingKey: 'test_buck_key',
                changeNumber: 828282828282,
                pt: alwaysOnWithConfigImpr.i[1].m
              });
              client.destroy();
              assert.end();
              return 200;
            });
            fetchMock.postOnce(settings.url('/testImpressions/bulk'), 200);
            splitio.Logger.enable();
            evaluationsStart = Date.now();
            _context.next = 12;
            return client.ready();

          case 12:
            readyEvaluationsStart = Date.now();
            client.getTreatment({
              matchingKey: key,
              bucketingKey: 'test_buck_key'
            }, 'split_with_config');
            client.getTreatment({
              matchingKey: key,
              bucketingKey: 'test_buck_key'
            }, 'split_with_config');
            client.getTreatment({
              matchingKey: key,
              bucketingKey: 'test_buck_key'
            }, 'split_with_config');
            splitio.Logger.disable();
            evaluationsEnd = Date.now();

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _ref.apply(this, arguments);
}