"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _sinon = _interopRequireDefault(require("sinon"));

var _ = require("../../");

var _settings = _interopRequireDefault(require("../../utils/settings"));

var _splitchangesSince = _interopRequireDefault(require("../mocks/splitchanges.since.-1.json"));

var _mysegmentsFacundoSplitIo = _interopRequireDefault(require("../mocks/mysegments.facundo@split.io.json"));

var _constants = require("../../utils/constants");

var config = {
  core: {
    authorizationKey: '...',
    key: 'facundo@split.io'
  },
  urls: {
    sdk: 'https://sdk.baseurlbeacon',
    events: 'https://sdk.baseurlbeacon'
  },
  streamingEnabled: false
};
var settings = (0, _settings.default)(config); // Spy calls to Beacon API method

var sendBeaconSpy; // util method to trigger 'unload' event

function triggerUnloadEvent() {
  var event = document.createEvent('HTMLEvents');
  event.initEvent('unload', true, true);
  event.eventName = 'unload';
  window.dispatchEvent(event);
}

var assertImpressionSent = function assertImpressionSent(assert, impression) {
  assert.equal(impression.f, 'hierarchical_splits_test', 'Present impression should have the correct split name.');
  assert.equal(impression.i[0].k, 'facundo@split.io', 'Present impression should have the correct key.');
  assert.equal(impression.i[0].r, 'expected label', 'Present impression should have the correct label.');
  assert.equal(impression.i[0].t, 'on', 'Present impression should have the correct treatment.');
};

var assertEventSent = function assertEventSent(assert, event) {
  assert.equal(event.key, 'facundo@split.io', 'Key should match received value.');
  assert.equal(event.eventTypeId, 'someEvent', 'EventTypeId should match received value.');
  assert.equal(event.trafficTypeName, 'sometraffictype', 'TrafficTypeName should match the binded value.');
};

var assertImpressionsCountSent = function assertImpressionsCountSent(assert, impressionCount) {
  assert.equal(impressionCount.pf.length, 1, 'It should sent one impression count.');
  assert.equal(impressionCount.pf[0].f, 'hierarchical_splits_test', 'Present impression count should have the correct split name.');
  assert.equal(impressionCount.pf[0].rc, 1, 'It should be one.');
  assert.equal((0, _typeof2.default)(impressionCount.pf[0].m), 'number', 'It should be number.');
};

var assertCallsToBeaconAPI = function assertCallsToBeaconAPI(assert) {
  assert.ok(sendBeaconSpy.calledThrice, 'sendBeacon should have been called thrice'); // The first call is for flushing impressions

  var impressionsCallArgs = sendBeaconSpy.firstCall.args;
  assert.equal(impressionsCallArgs[0], settings.url('/testImpressions/beacon'), 'assert correct url');
  var parsedPayload = JSON.parse(impressionsCallArgs[1]);
  assert.equal(parsedPayload.token, '...', 'assert correct payload token');
  assert.equal(parsedPayload.sdk, settings.version, 'assert correct sdk version');
  assert.equal(parsedPayload.sim, _constants.OPTIMIZED, 'assert correct impressions mode');
  assertImpressionSent(assert, parsedPayload.entries[0]); // The second call is for flushing events

  var eventsCallArgs = sendBeaconSpy.secondCall.args;
  assert.equal(eventsCallArgs[0], settings.url('/events/beacon'), 'assert correct url');
  parsedPayload = JSON.parse(eventsCallArgs[1]);
  assert.equal(parsedPayload.token, '...', 'assert correct payload token');
  assert.equal(parsedPayload.sdk, settings.version, 'assert correct sdk version');
  assertEventSent(assert, parsedPayload.entries[0]); // The third call is for flushing impressions count

  var impressionsCountCallArgs = sendBeaconSpy.thirdCall.args;
  assert.equal(impressionsCountCallArgs[0], settings.url('/testImpressions/count/beacon'), 'assert correct url');
  parsedPayload = JSON.parse(impressionsCountCallArgs[1]);
  assert.equal(parsedPayload.token, '...', 'assert correct payload token');
  assert.equal(parsedPayload.sdk, settings.version, 'assert correct sdk version');
  assertImpressionsCountSent(assert, parsedPayload.entries);
}; // This E2E test checks that Beacon API is not called when page unload is triggered and there are not events or impressions to send.


function beaconApiNotSendTest(fetchMock, assert) {
  sendBeaconSpy = _sinon.default.spy(window.navigator, 'sendBeacon'); // Mocking this specific route to make sure we only get the items we want to test from the handlers.

  fetchMock.get(settings.url('/splitChanges?since=-1'), {
    status: 200,
    body: _splitchangesSince.default
  });
  fetchMock.get(settings.url('/splitChanges?since=1457552620999'), {
    status: 200,
    body: {
      splits: [],
      since: 1457552620999,
      till: 1457552620999
    }
  });
  fetchMock.get(settings.url('/mySegments/facundo%40split.io'), {
    status: 200,
    body: _mysegmentsFacundoSplitIo.default
  }); // Init and run Split client

  var splitio = (0, _.SplitFactory)(config);
  var client = splitio.client();
  client.on(client.Event.SDK_READY, function () {
    // trigger unload event, without tracked events and impressions
    triggerUnloadEvent(); // destroy the client and execute the next E2E test named beaconApiSendTest

    setTimeout(function () {
      assert.ok(sendBeaconSpy.notCalled, 'sendBeacon should not be called if there are not events and impressions to track');
      sendBeaconSpy.resetHistory();
      client.destroy().then(function () {
        beaconApiSendTest(fetchMock, assert);
      });
    }, 0);
  });
} // This E2E test checks that impressions and events are sent to backend via Beacon API when page unload is triggered.


function beaconApiSendTest(fetchMock, assert) {
  // Init and run Split client
  var splitio = (0, _.SplitFactory)(config);
  var client = splitio.client();
  client.on(client.Event.SDK_READY, function () {
    client.getTreatment('hierarchical_splits_test');
    client.track('sometraffictype', 'someEvent', 10); // trigger unload event inmmediatly, before scheduled push of events and impressions

    triggerUnloadEvent(); // queue the assertion of the Beacon requests, destroy the client and execute the next E2E test named fallbackTest

    setTimeout(function () {
      assertCallsToBeaconAPI(assert);
      sendBeaconSpy.resetHistory();
      client.destroy().then(function () {
        fallbackTest(fetchMock, assert);
      });
    }, 0);
  });
} // This E2E test checks that impressions and events are sent to backend via Axios when page unload is triggered and Beacon API is not available.


function fallbackTest(fetchMock, assert) {
  // destroy reference to Beacon API
  window.navigator.sendBeacon = null;
  var splitio = (0, _.SplitFactory)(config);
  var client = splitio.client(); // synchronize client destruction when both endpoints ('/testImpressions/bulk' and '/events/bulk') are called

  var finish = /*#__PURE__*/_regenerator.default.mark(function _callee() {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return;

          case 2:
            _context.next = 4;
            return;

          case 4:
            // @TODO review why we must destroy client in a different event-loop cycle, compared to axios-mock-adapter
            setTimeout(function () {
              client.destroy().then(function () {
                sendBeaconSpy.restore();
                assert.end();
              });
            }, 0);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })(); // Mock endpoints used by Axios


  fetchMock.postOnce(settings.url('/testImpressions/bulk'), function (url, opts) {
    var resp = JSON.parse(opts.body);
    assert.ok(opts, 'Fallback to /testImpressions/bulk');
    assertImpressionSent(assert, resp[0]);
    finish.next();
    return 200;
  });
  fetchMock.postOnce(settings.url('/events/bulk'), function (url, opts) {
    var resp = JSON.parse(opts.body);
    assert.ok(opts, 'Fallback to /events/bulk');
    assertEventSent(assert, resp[0]);
    finish.next();
    return 200;
  });
  fetchMock.post(settings.url('/testImpressions/count'), function (url, opts) {
    var resp = JSON.parse(opts.body);
    assert.ok(opts, 'Fallback to /testImpressions/count');
    assertImpressionsCountSent(assert, resp);
    finish.next();
    return 200;
  });
  client.on(client.Event.SDK_READY, function () {
    client.getTreatment('hierarchical_splits_test');
    client.track('sometraffictype', 'someEvent', 10); // trigger unload event inmmediatly, before scheduled push of events and impressions

    triggerUnloadEvent();
  });
}

var _default = beaconApiNotSendTest;
exports.default = _default;