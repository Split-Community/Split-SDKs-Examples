"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _RedisAdapter = _interopRequireDefault(require("../../../RedisAdapter"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _Keys = _interopRequireDefault(require("../../../Keys"));

var _InRedis = _interopRequireDefault(require("../../../ImpressionsCache/InRedis"));

var _settings = _interopRequireDefault(require("../../../../utils/settings"));

/**
Copyright 2016 Split Software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
(0, _tapeCatch.default)('IMPRESSIONS CACHE IN REDIS / should incrementally store values', /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(assert) {
    var settings, impressionsKey, testMeta, connection, keys, c, o1, o2, o3, state;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            settings = (0, _settings.default)({
              storage: {
                type: 'REDIS',
                prefix: 'ut_impr_cache'
              }
            });
            impressionsKey = 'ut_impr_cache.SPLITIO.impressions';
            testMeta = {
              thisIsTheMeta: true
            };
            connection = new _RedisAdapter.default(settings.storage.options);
            keys = new _Keys.default(settings);
            c = new _InRedis.default(keys, connection, testMeta);
            o1 = {
              feature: 'test1',
              keyName: 'facundo@split.io',
              treatment: 'on',
              time: Date.now(),
              changeNumber: 1
            };
            o2 = {
              feature: 'test2',
              keyName: 'pepep@split.io',
              treatment: 'A',
              time: Date.now(),
              bucketingKey: '1234-5678',
              label: 'is in segment',
              changeNumber: 1
            };
            o3 = {
              feature: 'test3',
              keyName: 'pipiip@split.io',
              treatment: 'B',
              time: Date.now(),
              changeNumber: 1
            }; // cleanup

            _context.next = 11;
            return connection.del(impressionsKey);

          case 11:
            _context.next = 13;
            return c.track([o1]);

          case 13:
            _context.next = 15;
            return c.track([o2, o3]);

          case 15:
            _context.next = 17;
            return connection.lrange(impressionsKey, 0, -1);

          case 17:
            state = _context.sent;
            // This is testing both the track and the toJSON method.
            assert.deepEqual(state[0], JSON.stringify({
              m: testMeta,
              i: {
                k: o1.keyName,
                f: o1.feature,
                t: o1.treatment,
                c: o1.changeNumber,
                m: o1.time
              }
            }));
            assert.deepEqual(state[1], JSON.stringify({
              m: testMeta,
              i: {
                k: o2.keyName,
                b: o2.bucketingKey,
                f: o2.feature,
                t: o2.treatment,
                r: o2.label,
                c: o2.changeNumber,
                m: o2.time
              }
            }));
            assert.deepEqual(state[2], JSON.stringify({
              m: testMeta,
              i: {
                k: o3.keyName,
                f: o3.feature,
                t: o3.treatment,
                c: o3.changeNumber,
                m: o3.time
              }
            }));
            _context.next = 23;
            return connection.del(impressionsKey);

          case 23:
            _context.next = 25;
            return connection.quit();

          case 25:
            assert.end();

          case 26:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('IMPRESSIONS CACHE IN REDIS / should not resolve track before calling expire', /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(assert) {
    var impressionsKey, settings, testMeta, redis, keys, c, i1, i2, spy1, spy2, originalExpire;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            impressionsKey = 'ut_impr_cache_2.SPLITIO.impressions';
            settings = (0, _settings.default)({
              storage: {
                type: 'REDIS',
                prefix: 'ut_impr_cache_2'
              }
            });
            testMeta = {
              thisIsTheMeta: true
            };
            redis = new _RedisAdapter.default(settings.storage.options);
            keys = new _Keys.default(settings);
            c = new _InRedis.default(keys, redis, testMeta);
            i1 = {
              feature: 'test4',
              keyName: 'nicolas@split.io',
              treatment: 'off',
              time: Date.now(),
              changeNumber: 1
            };
            i2 = {
              feature: 'test5',
              keyName: 'matias@split.io',
              treatment: 'on',
              time: Date.now(),
              changeNumber: 2
            };
            spy1 = _sinon.default.spy(redis, 'rpush');
            spy2 = _sinon.default.spy(redis, 'expire'); // Crap so we can reproduce the latency as we would have on a remote server.

            originalExpire = redis.expire;

            redis.expire = function patchedForTestRedisExpire() {
              var _arguments = arguments;
              return new Promise(function (res, rej) {
                setTimeout(function () {
                  originalExpire.apply(redis, _arguments).then(res).catch(rej);
                }, 150); // 150ms of delay on the expire
              });
            }; // cleanup prior to test.


            _context3.next = 14;
            return redis.del(impressionsKey);

          case 14:
            c.track([i1, i2]).then(function () {
              redis.quit(); // Try to disconnect right away.

              assert.ok(spy1.called, 'Redis rpush was called once before executing external callback.'); // Following assertion fails if the expire takes place after disconnected and throws unhandledPromiseRejection

              assert.ok(spy2.called, 'Redis expire was called once before executing external callback.');
            }).catch(function (e) {
              assert.fail("An error was generated from the redis expire tests: ".concat(e));
            }).then( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
              return _regenerator.default.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      // Finally clean up and wrap up.
                      spy1.restore();
                      spy2.restore();
                      assert.end();

                    case 3:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            })));

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());