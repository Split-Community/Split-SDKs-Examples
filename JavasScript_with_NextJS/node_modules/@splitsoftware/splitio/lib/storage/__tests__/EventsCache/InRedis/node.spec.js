"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _ioredis = _interopRequireDefault(require("ioredis"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _find = _interopRequireDefault(require("lodash/find"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _Keys = _interopRequireDefault(require("../../../Keys"));

var _InRedis = _interopRequireDefault(require("../../../EventsCache/InRedis"));

var _settings = _interopRequireDefault(require("../../../../utils/settings"));

/*eslint-disable require-atomic-updates*/
var settings = (0, _settings.default)({
  storage: {
    type: 'REDIS',
    prefix: 'UT_EVENTS_CACHE_PREFIX'
  }
});
(0, _tapeCatch.default)('EVENTS CACHE IN REDIS / should incrementally store values in redis', /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(assert) {
    var connection, keys, key, fakeMeta, fakeEvent1, fakeEvent2, fakeEvent3, redisValues, cache, faultyCache, findMatchingElem, foundEv1, foundEv2, foundEv3;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            connection = new _ioredis.default(settings.storage.options); // This piece is being tested elsewhere.

            keys = new _Keys.default(settings);
            key = keys.buildEventsKey();
            fakeMeta = {
              s: 'js_someversion',
              i: 'some_ip',
              n: 'some_hostname'
            };
            fakeEvent1 = {
              event: 1
            };
            fakeEvent2 = {
              event: '2'
            };
            fakeEvent3 = {
              event: null
            }; // Clean up in case there are still keys there.

            connection.del(key);
            _context.next = 10;
            return connection.lrange(key, 0, -1);

          case 10:
            redisValues = _context.sent;
            assert.equal(redisValues.length, 0, 'control assertion, there are no events previously queued.');
            cache = new _InRedis.default(keys, connection, fakeMeta); // I'll use a "bad" instance so I can force an issue with the rpush command. I'll store an integer and will make the cache try to use rpush there.

            _context.next = 15;
            return connection.set('non-list-key', 10);

          case 15:
            faultyCache = new _InRedis.default({
              buildEventsKey: function buildEventsKey() {
                return 'non-list-key';
              }
            }, connection, fakeMeta);
            _context.t0 = assert;
            _context.next = 19;
            return cache.track(fakeEvent1);

          case 19:
            _context.t1 = _context.sent;

            _context.t0.true.call(_context.t0, _context.t1, 'If the queueing operation was successful, it should resolve the returned promise with "true"');

            _context.t2 = assert;
            _context.next = 24;
            return cache.track(fakeEvent2);

          case 24:
            _context.t3 = _context.sent;

            _context.t2.true.call(_context.t2, _context.t3, 'If the queueing operation was successful, it should resolve the returned promise with "true"');

            _context.t4 = assert;
            _context.next = 29;
            return cache.track(fakeEvent3);

          case 29:
            _context.t5 = _context.sent;

            _context.t4.true.call(_context.t4, _context.t5, 'If the queueing operation was successful, it should resolve the returned promise with "true"');

            _context.t6 = assert;
            _context.next = 34;
            return faultyCache.track(fakeEvent1);

          case 34:
            _context.t7 = _context.sent;

            _context.t6.false.call(_context.t6, _context.t7, 'If the queueing operation was NOT successful, it should resolve the returned promise with "false" instead of rejecting it.');

            _context.t8 = assert;
            _context.next = 39;
            return faultyCache.track(fakeEvent2);

          case 39:
            _context.t9 = _context.sent;

            _context.t8.false.call(_context.t8, _context.t9, 'If the queueing operation was NOT successful, it should resolve the returned promise with "false" instead of rejecting it.');

            _context.t10 = assert;
            _context.next = 44;
            return faultyCache.track(fakeEvent3);

          case 44:
            _context.t11 = _context.sent;

            _context.t10.false.call(_context.t10, _context.t11, 'If the queueing operation was NOT successful, it should resolve the returned promise with "false" instead of rejecting it.');

            _context.next = 48;
            return connection.lrange(key, 0, -1);

          case 48:
            redisValues = _context.sent;
            assert.equal(redisValues.length, 3, 'After pushing we should have on Redis as many events as we have stored.');
            assert.equal((0, _typeof2.default)(redisValues[0]), 'string', 'All elements should be strings since those are stringified JSONs.');
            assert.equal((0, _typeof2.default)(redisValues[1]), 'string', 'All elements should be strings since those are stringified JSONs.');
            assert.equal((0, _typeof2.default)(redisValues[2]), 'string', 'All elements should be strings since those are stringified JSONs.');

            findMatchingElem = function findMatchingElem(event) {
              return (0, _find.default)(redisValues, function (elem) {
                var parsedElem = JSON.parse(elem);
                return (0, _isEqual.default)(parsedElem.e, event) && (0, _isEqual.default)(parsedElem.m, fakeMeta);
              });
            };
            /* If the elements are found, then the values are correct. */


            foundEv1 = findMatchingElem(fakeEvent1);
            foundEv2 = findMatchingElem(fakeEvent2);
            foundEv3 = findMatchingElem(fakeEvent3);
            assert.true(foundEv1, 'Events stored on redis matched the values we are expecting.');
            assert.true(foundEv2, 'Events stored on redis matched the values we are expecting.');
            assert.true(foundEv3, 'Events stored on redis matched the values we are expecting.'); // Clean up then end.

            _context.next = 62;
            return connection.del(key);

          case 62:
            _context.next = 64;
            return connection.quit();

          case 64:
            assert.end();

          case 65:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());