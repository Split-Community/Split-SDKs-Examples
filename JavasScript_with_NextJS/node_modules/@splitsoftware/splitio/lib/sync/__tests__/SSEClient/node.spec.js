"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _tape = _interopRequireDefault(require("tape"));

var _sinon = _interopRequireDefault(require("sinon"));

var _proxyquire = _interopRequireDefault(require("proxyquire"));

var _settings = _interopRequireDefault(require("../../../utils/settings"));

var _eventSourceMock = _interopRequireDefault(require("../mocks/eventSourceMock"));

var _dataMocks = require("../mocks/dataMocks");

var proxyquireStrict = _proxyquire.default.noCallThru();

var eventSourceReference; // Import the module, mocking getEventSource.

var SSClient = proxyquireStrict('../../SSEClient/index', {
  '../../services/getEventSource': function servicesGetEventSource() {
    return eventSourceReference;
  }
}).default;
var settings = (0, _settings.default)({
  core: {
    key: 'emi@split.io'
  }
});
(0, _tape.default)('SSClient', function (t) {
  t.test('getInstance', function (assert) {
    eventSourceReference = undefined;
    var instance = SSClient.getInstance(settings);
    assert.equal(instance, undefined, 'instance not created if EventSource not available');
    eventSourceReference = _eventSourceMock.default;
    instance = SSClient.getInstance(settings);
    assert.notEqual(instance, undefined, 'instance created if EventSource is available');
    assert.notEqual(instance.eventSource, _eventSourceMock.default, 'the instance EventSource');
    assert.end();
  });
  t.test('setEventHandler, open and close methods', function (assert) {
    // instance event handler
    var handler = {
      handleOpen: _sinon.default.stub(),
      handleError: _sinon.default.stub(),
      handleMessage: _sinon.default.stub()
    }; // instance SSEClient

    eventSourceReference = _eventSourceMock.default;
    var instance = SSClient.getInstance(settings);
    instance.setEventHandler(handler); // error on first open without authToken

    assert.throws(instance.reopen, 'throw error if reopen is invoked without a previous open call'); // open connection

    instance.open(_dataMocks.authDataSample);
    var esconnection = instance.connection; // instance of EventSource used to mock events

    esconnection.emitOpen();
    assert.ok(handler.handleOpen.calledOnce, 'handleOpen called when connection is opened');
    handler.handleOpen.resetHistory(); // emit message

    var message = 'message';
    esconnection.emitMessage(message);
    assert.ok(handler.handleMessage.calledWith(message), 'handleMessage called when message received');
    handler.handleMessage.resetHistory(); // emit error

    var error = 'error';
    esconnection.emitError(error);
    assert.ok(handler.handleError.calledWith(error), 'handleError called when error received');
    handler.handleError.resetHistory(); // close connection

    instance.close();
    assert.equal(instance.connection.readyState, 2, 'connection readyState is CLOSED'); // CLOSED (2)
    // open attempt without open event emitted

    instance.open(_dataMocks.authDataSample);
    assert.ok(handler.handleOpen.notCalled, 'handleOpen not called until open event is emitted'); // open a new connection

    instance.open(_dataMocks.authDataSample);
    instance.connection.emitOpen();
    assert.ok(handler.handleOpen.calledOnce, 'handleOpen called when connection is open'); // reopen the connection

    handler.handleOpen.resetHistory();
    instance.reopen();
    instance.connection.emitOpen();
    assert.ok(handler.handleOpen.calledOnce, 'handleOpen called if connection is reopen'); // remove event handler before opening a new connection

    handler.handleOpen.resetHistory();
    instance.setEventHandler(undefined);
    instance.open(_dataMocks.authDataSample);
    instance.connection.emitOpen();
    assert.ok(handler.handleOpen.notCalled, 'handleOpen not called if connection is open but the handler was removed');
    assert.end();
  });
  t.test('open method: URL', function (assert) {
    eventSourceReference = _eventSourceMock.default;
    var instance = SSClient.getInstance(settings);
    instance.open(_dataMocks.authDataSample);
    var EXPECTED_URL = settings.url('/sse') + '?channels=' + _dataMocks.channelsQueryParamSample + '&accessToken=' + _dataMocks.authDataSample.token + '&v=1.1&heartbeats=true';
    assert.equal(instance.connection.url, EXPECTED_URL, 'URL is properly set for streaming connection');
    assert.end();
  });
});