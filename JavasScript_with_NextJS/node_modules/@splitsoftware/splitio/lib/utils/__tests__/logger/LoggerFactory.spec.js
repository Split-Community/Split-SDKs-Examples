"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _LoggerFactory = require("../../logger/LoggerFactory");

var _indexSpec = require("./index.spec.js");

/* eslint-disable no-console */
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / setLogLevel utility function', function (assert) {
  assert.equal((0, _typeof2.default)(_LoggerFactory.setLogLevel), 'function', 'setLogLevel should be a function');
  assert.doesNotThrow(_LoggerFactory.setLogLevel, 'Calling setLogLevel should not throw an error.');
  assert.end();
});
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / LogLevels exposed mappings', function (assert) {
  assert.deepEqual(_LoggerFactory.LogLevels, _indexSpec.LOG_LEVELS, 'Exposed log levels should contain the levels we want.');
  assert.end();
});
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / Logger class shape', function (assert) {
  assert.equal((0, _typeof2.default)(_LoggerFactory.Logger), 'function', 'Logger should be a class we can instantiate.');
  var logger = new _LoggerFactory.Logger('test-category', {});
  assert.equal((0, _typeof2.default)(logger.debug), 'function', 'instance.debug should be a method.');
  assert.equal((0, _typeof2.default)(logger.info), 'function', 'instance.info should be a method.');
  assert.equal((0, _typeof2.default)(logger.warn), 'function', 'instance.warn should be a method.');
  assert.equal((0, _typeof2.default)(logger.error), 'function', 'instance.error should be a method.');
  assert.end();
});
var LOG_LEVELS_IN_ORDER = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'NONE'];
/* Utility function to avoid repeating too much code */

function testLogLevels(levelToTest, assert) {
  // Builds the expected message.
  var buildExpectedMessage = function buildExpectedMessage(lvl, category, msg, showLevel) {
    var res = '';
    if (showLevel) res += '[' + lvl + ']' + (lvl.length === 4 ? '  ' : ' ');
    res += category + ' => ';
    res += msg;
    return res;
  }; // Runs the suite with the given value for showLevel option.


  var runTests = function runTests(showLevel, displayAllErrors) {
    var logLevelLogsCounter = 0;
    var testForNoLog = false;
    var logMethod = levelToTest.toLowerCase();
    var logCategory = "test-category-".concat(logMethod).concat(displayAllErrors ? 'displayAllErrors' : '');
    var instance = new _LoggerFactory.Logger(logCategory, {
      showLevel: showLevel,
      displayAllErrors: displayAllErrors
    });
    LOG_LEVELS_IN_ORDER.forEach(function (logLevel, i) {
      var logMsg = "Test log for level ".concat(levelToTest, " (").concat(displayAllErrors ? 'But all errors are configured to display' : 'Errors not forced to display', ") with showLevel: ").concat(showLevel, " ").concat(logLevelLogsCounter);
      var expectedMessage = buildExpectedMessage(levelToTest, logCategory, logMsg, showLevel); // Log error should always be visible.

      if (logMethod === _indexSpec.LOG_LEVELS.ERROR.toLowerCase() && displayAllErrors) testForNoLog = false; // Set the logLevel for this iteration.

      (0, _LoggerFactory.setLogLevel)(_LoggerFactory.LogLevels[logLevel]); // Call the method

      instance[logMethod](logMsg); // Assert if console.log was called.

      assert[testForNoLog ? 'notOk' : 'ok'](console.log.calledWith(expectedMessage), "Calling ".concat(logMethod, " method should ").concat(testForNoLog ? 'NOT ' : '', "log with ").concat(logLevel, " log level. ").concat(displayAllErrors ? 'But all errors are configured to display.' : ''));

      if (LOG_LEVELS_IN_ORDER.indexOf(levelToTest) <= i) {
        testForNoLog = true;
      }

      logLevelLogsCounter++;
    });
  }; // Spy console.log


  _sinon.default.spy(console, 'log'); // Show logLevel


  runTests(true);
  runTests(true, true); // Hide logLevel

  runTests(false);
  runTests(false, true); // Restore stub.

  console.log.restore();
}

(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.debug', function (assert) {
  testLogLevels(_LoggerFactory.LogLevels.DEBUG, assert);
  assert.end();
});
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.info', function (assert) {
  testLogLevels(_LoggerFactory.LogLevels.INFO, assert);
  assert.end();
});
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.warn', function (assert) {
  testLogLevels(_LoggerFactory.LogLevels.WARN, assert);
  assert.end();
});
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.error', function (assert) {
  testLogLevels(_LoggerFactory.LogLevels.ERROR, assert, true);
  assert.end();
});