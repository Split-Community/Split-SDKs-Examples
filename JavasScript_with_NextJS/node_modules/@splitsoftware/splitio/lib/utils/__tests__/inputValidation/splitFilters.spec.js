"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _tape = _interopRequireDefault(require("tape"));

var _sinon = _interopRequireDefault(require("sinon"));

var _proxyquire = _interopRequireDefault(require("proxyquire"));

var _constants = require("../../constants");

var _fetchSpecificSplits = require("../../../__tests__/mocks/fetchSpecificSplits");

var proxyquireStrict = _proxyquire.default.noCallThru();

var loggerMock = {
  warn: _sinon.default.stub(),
  error: _sinon.default.stub(),
  debug: _sinon.default.stub()
};

function resetStubs() {
  loggerMock.warn.resetHistory();
  loggerMock.error.resetHistory();
  loggerMock.debug.resetHistory();
}

function LogFactoryMock() {
  return loggerMock;
}

// Import the module mocking the logger.
var validateSplitFilters = proxyquireStrict('../../inputValidation/splitFilters', {
  '../logger': LogFactoryMock
}).default; // Split filter and QueryStrings examples

(0, _tape.default)('INPUT VALIDATION for splitFilters', function (t) {
  var defaultOutput = {
    validFilters: [],
    queryString: null,
    groupedFilters: {}
  };
  t.test('Returns default output with empty values if `splitFilters` is an invalid object or `mode` is not \'standalone\'', function (assert) {
    assert.deepEqual(validateSplitFilters(undefined, _constants.STANDALONE_MODE), defaultOutput, 'splitFilters ignored if not a non-empty array');
    assert.deepEqual(validateSplitFilters(null, _constants.STANDALONE_MODE), defaultOutput, 'splitFilters ignored if not a non-empty array');
    assert.true(loggerMock.warn.notCalled);
    assert.deepEqual(validateSplitFilters(true, _constants.STANDALONE_MODE), defaultOutput, 'splitFilters ignored if not a non-empty array');
    assert.true(loggerMock.warn.getCall(0).calledWithExactly('Factory instantiation: splitFilters configuration must be a non-empty array of filter objects.'));
    assert.deepEqual(validateSplitFilters(15, _constants.STANDALONE_MODE), defaultOutput, 'splitFilters ignored if not a non-empty array');
    assert.true(loggerMock.warn.getCall(1).calledWithExactly('Factory instantiation: splitFilters configuration must be a non-empty array of filter objects.'));
    assert.deepEqual(validateSplitFilters('string', _constants.STANDALONE_MODE), defaultOutput, 'splitFilters ignored if not a non-empty array');
    assert.true(loggerMock.warn.getCall(2).calledWithExactly('Factory instantiation: splitFilters configuration must be a non-empty array of filter objects.'));
    assert.deepEqual(validateSplitFilters([], _constants.STANDALONE_MODE), defaultOutput, 'splitFilters ignored if not a non-empty array');
    assert.true(loggerMock.warn.getCall(3).calledWithExactly('Factory instantiation: splitFilters configuration must be a non-empty array of filter objects.'));
    assert.deepEqual(validateSplitFilters([{
      type: 'byName',
      values: ['split_1']
    }], _constants.CONSUMER_MODE), defaultOutput);
    assert.true(loggerMock.warn.calledWithExactly("Factory instantiation: split filters have been configured but will have no effect if mode is not 'standalone', since synchronization is being deferred to an external tool."));
    assert.true(loggerMock.debug.notCalled);
    assert.true(loggerMock.error.notCalled);
    resetStubs();
    assert.end();
  });
  t.test('Returns object with null queryString, if `splitFilters` contains invalid filters or contains filters with no values or invalid values', function (assert) {
    var splitFilters = [{
      type: 'byName',
      values: []
    }, {
      type: 'byName',
      values: []
    }, {
      type: 'byPrefix',
      values: []
    }];
    var output = {
      validFilters: [].concat(splitFilters),
      queryString: null,
      groupedFilters: {
        byName: [],
        byPrefix: []
      }
    };
    assert.deepEqual(validateSplitFilters(splitFilters, _constants.STANDALONE_MODE), output, 'filters without values');
    assert.true(loggerMock.debug.getCall(0).calledWithExactly("Factory instantiation: splits filtering criteria is 'null'."));
    loggerMock.debug.resetHistory();
    splitFilters.push({
      type: 'invalid',
      values: []
    }, {
      type: 'byName',
      values: 'invalid'
    }, {
      type: null,
      values: []
    }, {
      type: 'byName',
      values: [13]
    });
    output.validFilters.push({
      type: 'byName',
      values: [13]
    });
    assert.deepEqual(validateSplitFilters(splitFilters, _constants.STANDALONE_MODE), output, 'some filters are invalid');
    assert.true(loggerMock.debug.getCall(0).calledWithExactly("Factory instantiation: splits filtering criteria is 'null'."));
    assert.true(loggerMock.warn.getCall(0).calledWithExactly("Factory instantiation: split filter at position '3' is invalid. It must be an object with a valid filter type ('byName' or 'byPrefix') and a list of 'values'."), 'invalid value of `type` property');
    assert.true(loggerMock.warn.getCall(1).calledWithExactly("Factory instantiation: split filter at position '4' is invalid. It must be an object with a valid filter type ('byName' or 'byPrefix') and a list of 'values'."), 'invalid type of `values` property');
    assert.true(loggerMock.warn.getCall(2).calledWithExactly("Factory instantiation: split filter at position '5' is invalid. It must be an object with a valid filter type ('byName' or 'byPrefix') and a list of 'values'."), 'invalid type of `type` property');
    assert.equal(loggerMock.warn.callCount, 3);
    assert.true(loggerMock.error.notCalled);
    resetStubs();
    assert.end();
  });
  t.test('Returns object with a queryString, if `splitFilters` contains at least a valid `byName` or `byPrefix` filter with at least a valid value', function (assert) {
    var _loop = function _loop(i) {
      if (_fetchSpecificSplits.groupedFilters[i]) {
        // tests where validateSplitFilters executes normally
        var output = {
          validFilters: (0, _toConsumableArray2.default)(_fetchSpecificSplits.splitFilters[i]),
          queryString: _fetchSpecificSplits.queryStrings[i],
          groupedFilters: _fetchSpecificSplits.groupedFilters[i]
        };
        assert.deepEqual(validateSplitFilters(_fetchSpecificSplits.splitFilters[i], _constants.STANDALONE_MODE), output, "splitFilters #".concat(i));
        assert.true(loggerMock.debug.calledWith("Factory instantiation: splits filtering criteria is '".concat(_fetchSpecificSplits.queryStrings[i], "'.")));
      } else {
        // tests where validateSplitFilters throws an exception
        assert.throws(function () {
          return validateSplitFilters(_fetchSpecificSplits.splitFilters[i], _constants.STANDALONE_MODE);
        }, _fetchSpecificSplits.queryStrings[i]);
      }
    };

    for (var i = 0; i < _fetchSpecificSplits.splitFilters.length; i++) {
      _loop(i);
    }

    resetStubs();
    assert.end();
  });
});