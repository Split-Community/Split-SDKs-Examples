"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _proxyquire = _interopRequireDefault(require("proxyquire"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var proxyquireStrict = _proxyquire.default.noCallThru();

var contextMock = {
  get: _sinon.default.stub(),
  constants: {
    DESTROYED: 'is_destroyed',
    READY: 'is_ready',
    READY_FROM_CACHE: 'is_ready_from_cache'
  }
};
var loggerMock = {
  warn: _sinon.default.stub(),
  error: _sinon.default.stub()
};

function LogFactoryMock() {
  return loggerMock;
}

var _proxyquireStrict = proxyquireStrict('../../inputValidation/isOperational', {
  '../logger': LogFactoryMock
}),
    validateIfDestroyed = _proxyquireStrict.validateIfDestroyed,
    validateIfReady = _proxyquireStrict.validateIfReady;
/* We'll reset the history for the next test */


function resetStubs() {
  contextMock.get.reset();
  loggerMock.warn.resetHistory();
  loggerMock.error.resetHistory();
}

(0, _tapeCatch.default)('INPUT VALIDATION for the state of the client/factory', function (t) {
  t.test('validateIfDestroyed - Should return true if the client/factory evaluates as operational (not destroyed).', function (assert) {
    contextMock.get.returns(false);
    assert.true(validateIfDestroyed(contextMock), 'It should return true if the client is operational (it is NOT destroyed).');
    assert.true(contextMock.get.calledOnceWithExactly(contextMock.constants.DESTROYED, true), 'It checks for destroyed status using the context.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'Should not log any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('validateIfDestroyed - Should return false and log error if attributes map is invalid', function (assert) {
    contextMock.get.returns(true);
    assert.false(validateIfDestroyed(contextMock), 'It should return false if the client is NOT operational (it is destroyed).');
    assert.true(contextMock.get.calledOnceWithExactly(contextMock.constants.DESTROYED, true), 'It checks for destroyed status using the context.');
    assert.ok(loggerMock.error.calledOnceWithExactly('Client has already been destroyed - no calls possible.'), 'Should log an error.');
    assert.notOk(loggerMock.warn.called, 'But it should not log any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('validateIfReady - Should return true and log nothing if the SDK was ready.', function (assert) {
    contextMock.get.withArgs(contextMock.constants.READY).returns(true);
    contextMock.get.withArgs(contextMock.constants.READY_FROM_CACHE).returns(false);
    assert.true(validateIfReady(contextMock, 'test_method'), 'It should return true if SDK was ready.');
    assert.true(contextMock.get.calledOnceWithExactly(contextMock.constants.READY, true), 'It checks for readiness status using the context.');
    assert.notOk(loggerMock.warn.called, 'But it should not log any warnings.');
    assert.notOk(loggerMock.error.called, 'But it should not log any errors.');
    resetStubs();
    assert.end();
  });
  t.test('validateIfReady - Should return true and log nothing if the SDK was ready from cache.', function (assert) {
    contextMock.get.withArgs(contextMock.constants.READY).returns(false);
    contextMock.get.withArgs(contextMock.constants.READY_FROM_CACHE).returns(true);
    assert.true(validateIfReady(contextMock, 'test_method'), 'It should return true if SDK was ready.');
    assert.true(contextMock.get.calledTwice, 'It checks for readiness status using the context.');
    assert.true(contextMock.get.calledWithExactly(contextMock.constants.READY, true), 'It checks for SDK_READY status.');
    assert.true(contextMock.get.calledWithExactly(contextMock.constants.READY_FROM_CACHE, true), 'It checks for SDK_READY_FROM_CACHE status.');
    assert.notOk(loggerMock.warn.called, 'But it should not log any warnings.');
    assert.notOk(loggerMock.error.called, 'But it should not log any errors.');
    resetStubs();
    assert.end();
  });
  t.test('validateIfReady - Should return false and log a warning if the SDK was not ready.', function (assert) {
    contextMock.get.returns(false);
    assert.false(validateIfReady(contextMock, 'test_method'), 'It should return true if SDK was ready.');
    assert.true(contextMock.get.calledTwice, 'It checks for readiness status using the context.');
    assert.true(contextMock.get.calledWithExactly(contextMock.constants.READY, true), 'It checks for SDK_READY status.');
    assert.true(contextMock.get.calledWithExactly(contextMock.constants.READY_FROM_CACHE, true), 'It checks for SDK_READY_FROM_CACHE status.');
    assert.ok(loggerMock.warn.calledOnceWithExactly('test_method: the SDK is not ready, results may be incorrect. Make sure to wait for SDK readiness before using this method.'), 'It should log the expected warning.');
    assert.notOk(loggerMock.error.called, 'But it should not log any errors.');
    resetStubs();
    assert.end();
  });
});