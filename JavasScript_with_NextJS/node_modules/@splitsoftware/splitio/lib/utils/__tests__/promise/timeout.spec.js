"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _timeout = _interopRequireDefault(require("../../promise/timeout"));

var _Errors = require("../../lang/Errors");

var baseTimeoutInMs = 20;
var resolutionValue = 'random_Value';
(0, _tapeCatch.default)('Promise utils / timeout - What happens in the event of a timeout or no timeout at all', /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(assert) {
    var prom, ts, wrapperProm;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            prom = new Promise(function () {});
            assert.equal((0, _timeout.default)(0, prom), prom, 'If we set the timeout with a value less than 1, we just get the original promise (no timeout).');
            assert.equal((0, _timeout.default)(-1, prom), prom, 'If we set the timeout with a value less than 1, we just get the original promise (no timeout).');
            prom.then(function () {
              return assert.fail('This should not execute');
            }, function () {
              assert.pass('This should execute on timeout expiration.');
            });
            ts = Date.now();
            wrapperProm = (0, _timeout.default)(baseTimeoutInMs, prom);
            assert.notEqual(wrapperProm, prom, 'If we actually set a timeout it should return a wrapping promise.');
            _context.prev = 7;
            _context.next = 10;
            return wrapperProm;

          case 10:
            assert.fail('Should not execute');
            _context.next = 18;
            break;

          case 13:
            _context.prev = 13;
            _context.t0 = _context["catch"](7);
            // The promise was rejected not resolved. Give it an error margin of 10ms since it's not predictable
            assert.ok(Date.now() - ts < baseTimeoutInMs + 20, 'The timeout should have rejected the promise.');
            assert.ok(_context.t0 instanceof _Errors.SplitTimeoutError, 'The timeout should have rejected the promise with a Split Timeout Error.');
            assert.end();

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[7, 13]]);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('Promise utils / timeout - What happens if the promise resolves before the timeout.', /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(assert) {
    var promiseResolver, prom, wrapperProm, result;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            promiseResolver = null;
            prom = new Promise(function (res) {
              promiseResolver = res;
            });
            wrapperProm = (0, _timeout.default)(baseTimeoutInMs * 100, prom);
            assert.notEqual(wrapperProm, prom, 'If we actually set a timeout it should return a wrapping promise.');
            setTimeout(function () {
              // Resolve the promise before the timeout
              promiseResolver(resolutionValue);
            }, baseTimeoutInMs * 10); // This one should not reject but be resolved

            _context2.prev = 5;
            _context2.next = 8;
            return wrapperProm;

          case 8:
            result = _context2.sent;
            assert.equal(result, resolutionValue, 'The wrapper should resolve to the same value the original promise resolves.');
            assert.end();
            _context2.next = 16;
            break;

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](5);
            assert.fail('Should not execute');

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[5, 13]]);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('Promise utils / timeout - What happens if the promise rejects before the timeout.', /*#__PURE__*/function () {
  var _ref3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(assert) {
    var promiseRejecter, prom, wrapperProm;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            promiseRejecter = null;
            prom = new Promise(function (res, rej) {
              promiseRejecter = rej;
            });
            wrapperProm = (0, _timeout.default)(baseTimeoutInMs * 100, prom);
            assert.notEqual(wrapperProm, prom, 'If we actually set a timeout it should return a wrapping promise.');
            setTimeout(function () {
              // Reject the promise before the timeout
              promiseRejecter(resolutionValue);
            }, baseTimeoutInMs * 10); // This one should not resolve but be rejected

            _context3.prev = 5;
            _context3.next = 8;
            return wrapperProm;

          case 8:
            assert.fail('Should not execute');
            _context3.next = 15;
            break;

          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](5);
            assert.equal(_context3.t0, resolutionValue, 'The wrapper should reject to the same error than the original promise.');
            assert.end();

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[5, 11]]);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}());