"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _node = _interopRequireDefault(require("../node"));

var processOnSpy = _sinon.default.spy();

var processRemoveListenerSpy = _sinon.default.spy();

var processKillSpy = _sinon.default.spy();

_sinon.default.stub(process, 'on').callsFake(processOnSpy);

_sinon.default.stub(process, 'removeListener').callsFake(processRemoveListenerSpy);

_sinon.default.stub(process, 'kill').callsFake(processKillSpy);

(0, _tapeCatch.default)('Node JS / Signal Listener class methods and start/stop functionality', function (assert) {
  var listener = new _node.default();

  var handlerMock = _sinon.default.spy();

  listener.start(handlerMock); // Assigned right function to right signal.

  assert.ok(processOnSpy.calledOnce);
  assert.ok(processOnSpy.calledOnceWithExactly('SIGTERM', listener._sigtermHandler)); // pre-check and call stop

  assert.ok(processRemoveListenerSpy.notCalled);
  listener.stop(); // removed correct listener from correct signal on stop.

  assert.ok(processRemoveListenerSpy.calledOnce);
  assert.ok(processRemoveListenerSpy.calledOnceWithExactly('SIGTERM', listener._sigtermHandler));
  assert.end();
});
(0, _tapeCatch.default)('Node JS / Signal Listener SIGTERM callback with sync handler', function (assert) {
  var listener = new _node.default();

  var handlerMock = _sinon.default.spy();

  listener.start(handlerMock); // Stub stop function since we don't want side effects on test.

  _sinon.default.stub(listener, 'stop'); // Control asserts.


  assert.ok(listener.stop.notCalled);
  assert.ok(handlerMock.notCalled);
  assert.ok(processKillSpy.notCalled); // Call function

  listener._sigtermHandler(); // Handler was properly called.


  assert.ok(handlerMock.calledOnce); // Clean up is called.

  assert.ok(listener.stop.calledOnce); // It called for kill again, so the shutdown keeps going.

  assert.ok(processKillSpy.calledOnce);
  assert.ok(processKillSpy.calledOnceWithExactly(process.pid, 'SIGTERM')); // Reset the kill spy since it's used on other tests.

  processKillSpy.resetHistory();
  assert.end();
});
(0, _tapeCatch.default)('Node JS / Signal Listener SIGTERM callback with sync handler that throws an error', function (assert) {
  var listener = new _node.default();

  var handlerMock = _sinon.default.stub().throws();

  listener.start(handlerMock); // Stub stop function since we don't want side effects on test.

  _sinon.default.stub(listener, 'stop'); // Control asserts.


  assert.ok(listener.stop.notCalled);
  assert.ok(handlerMock.notCalled);
  assert.ok(processKillSpy.notCalled); // Call function.

  listener._sigtermHandler(); // Handler was properly called.


  assert.ok(handlerMock.calledOnce); // Even if the handler throws, clean up is called.

  assert.ok(listener.stop.calledOnce); // Even if the handler throws, it should call for kill again, so the shutdown keeps going.

  assert.ok(processKillSpy.calledOnce);
  assert.ok(processKillSpy.calledOnceWithExactly(process.pid, 'SIGTERM')); // Reset the kill spy since it's used on other tests.

  processKillSpy.resetHistory();
  assert.end();
});
(0, _tapeCatch.default)('Node JS / Signal Listener SIGTERM callback with async handler', /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(assert) {
    var listener, clock, fakePromise, handlerMock;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            listener = new _node.default();
            clock = _sinon.default.useFakeTimers();
            fakePromise = new Promise(function (res) {
              setTimeout(function () {
                res();
              }, 0);
            });
            handlerMock = _sinon.default.stub().returns(fakePromise); // Stub stop function since we don't want side effects on test.

            _sinon.default.stub(listener, 'stop'); // Start the listener


            listener.start(handlerMock); // Call function

            listener._sigtermHandler(); // Handler was properly called.


            assert.ok(handlerMock.calledOnce); // Check that the wrap up is waiting for the promise to be resolved.

            assert.ok(listener.stop.notCalled);
            assert.ok(processKillSpy.notCalled);
            fakePromise.then(function () {
              // Clean up is called even if there is an error.
              assert.ok(listener.stop.calledOnce); // It called for kill again, so the shutdown keeps going.

              assert.ok(processKillSpy.calledOnce);
              assert.ok(processKillSpy.calledOnceWithExactly(process.pid, 'SIGTERM')); // Reset the kill spy since it's used on other tests.

              processKillSpy.resetHistory();
              clock.restore();
              assert.end();
            }); // Ticking the clock, timer should execute and fake promise resolved.

            clock.next();
            return _context.abrupt("return", fakePromise);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('Node JS / Signal Listener SIGTERM callback with async handler that throws an error', /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(assert) {
    var listener, fakePromise, clock, handlerMock, handlerPromise;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            listener = new _node.default();
            fakePromise = new Promise(function (res, rej) {
              setTimeout(function () {
                rej();
              }, 0);
            });
            clock = _sinon.default.useFakeTimers();
            handlerMock = _sinon.default.stub().returns(fakePromise); // Stub stop function since we don't want side effects on test.

            _sinon.default.stub(listener, 'stop'); // Start the listener


            listener.start(handlerMock); // Call function

            handlerPromise = listener._sigtermHandler(); // Handler was properly called.

            assert.ok(handlerMock.calledOnce); // Check that the wrap up is waiting for the promise to be resolved.

            assert.ok(listener.stop.notCalled);
            assert.ok(processKillSpy.notCalled); // Calling .then since the wrapUp handler does not throw.

            handlerPromise.then(function () {
              // Clean up is called.
              assert.ok(listener.stop.calledOnce); // It called for kill again, so the shutdown keeps going.

              assert.ok(processKillSpy.calledOnce);
              assert.ok(processKillSpy.calledOnceWithExactly(process.pid, 'SIGTERM'));
              /* Clean up everything */

              clock.restore();
              process.on.restore();
              process.removeListener.restore();
              process.kill.restore();
              assert.end();
            }); // Ticking the clock, timer should execute and fake promise resolved.

            clock.next();
            return _context2.abrupt("return", handlerPromise);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());