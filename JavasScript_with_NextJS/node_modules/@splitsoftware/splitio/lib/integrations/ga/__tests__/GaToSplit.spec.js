"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _tape = _interopRequireDefault(require("tape"));

var _sinon = _interopRequireDefault(require("sinon"));

var _GaToSplit = _interopRequireWildcard(require("../GaToSplit"));

var _gaMock3 = require("./gaMock");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var hitSample = {
  hitType: 'pageview',
  page: '/path'
};
var modelSample = (0, _gaMock3.modelMock)(hitSample);
var expectedDefaultEvent = {
  eventTypeId: 'pageview',
  value: undefined,
  properties: {
    page: hitSample.page
  },
  timestamp: 0
};
(0, _tape.default)('validateIdentities', function (assert) {
  assert.deepEqual((0, _GaToSplit.validateIdentities)(undefined), []);
  assert.deepEqual((0, _GaToSplit.validateIdentities)(null), []);
  assert.deepEqual((0, _GaToSplit.validateIdentities)(123), []);
  assert.deepEqual((0, _GaToSplit.validateIdentities)(true), []);
  assert.deepEqual((0, _GaToSplit.validateIdentities)('something'), []);
  assert.deepEqual((0, _GaToSplit.validateIdentities)({}), []);
  assert.deepEqual((0, _GaToSplit.validateIdentities)(/asd/ig), []);
  assert.deepEqual((0, _GaToSplit.validateIdentities)(function () {}), []);
  assert.deepEqual((0, _GaToSplit.validateIdentities)([]), []);
  assert.deepEqual((0, _GaToSplit.validateIdentities)([undefined, /asd/ig, function () {}]), []);
  assert.deepEqual((0, _GaToSplit.validateIdentities)([{
    key: 'key',
    trafficType: 'user' // First occurence of this item

  }, {
    key: 'key',
    trafficType: function trafficType() {} // Invalid item (invalid TT)

  }, {
    key: 'keyu',
    trafficType: 'ser' // First occurence of this item

  }, {
    key: true,
    trafficType: 'user' // Invalid item (invalid key)

  }, {
    key: 'key2',
    trafficType: 'user2' // First occurence of this item

  }, {
    key: 12,
    trafficType: 'user' // First occurence of this item

  }, {
    key: 'key',
    trafficType: 'user' // Duplicated item

  }, {} // Invalid item (undefined key and traffic type)
  ]), [{
    key: 'key',
    trafficType: 'user'
  }, {
    key: 'keyu',
    trafficType: 'ser'
  }, {
    key: 'key2',
    trafficType: 'user2'
  }, {
    key: 12,
    trafficType: 'user'
  }]);
  assert.end();
});
(0, _tape.default)('validateEventData', function (assert) {
  assert.throws(function () {
    (0, _GaToSplit.validateEventData)(undefined);
  }, 'throws exception if passed object is undefined');
  assert.throws(function () {
    (0, _GaToSplit.validateEventData)(null);
  }, 'throws exception if passed object is null');
  assert.equal((0, _GaToSplit.validateEventData)({}), false, 'event must have a valid eventTypeId');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type'
  }), true, 'event must have a valid eventTypeId');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 123
  }), false, 'event must have a valid eventTypeId');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type',
    value: 'value'
  }), false, 'event must have a valid value if present');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type',
    value: 0
  }), true, 'event must have a valid value if present');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type',
    properties: ['prop1']
  }), false, 'event must have valid properties if present');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type',
    properties: {
      prop1: 'prop1'
    }
  }), true, 'event must have valid properties if present');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type',
    timestamp: true
  }), false, 'event must have a valid timestamp if present');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type',
    timestamp: Date.now()
  }), true, 'event must have a valid timestamp if present');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type',
    key: true
  }), false, 'event must have a valid key if present');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type',
    key: 'key'
  }), true, 'event must have a valid key if present');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type',
    trafficTypeName: true
  }), false, 'event must have a valid trafficTypeName if present');
  assert.equal((0, _GaToSplit.validateEventData)({
    eventTypeId: 'type',
    trafficTypeName: 'tt'
  }), true, 'event must have a valid trafficTypeName if present');
  assert.end();
});
(0, _tape.default)('fixEventTypeId', function (assert) {
  assert.equal((0, _GaToSplit.fixEventTypeId)(undefined), undefined);
  assert.equal((0, _GaToSplit.fixEventTypeId)(111), 111);
  assert.equal((0, _GaToSplit.fixEventTypeId)(''), '');
  assert.equal((0, _GaToSplit.fixEventTypeId)('()'), '');
  assert.equal((0, _GaToSplit.fixEventTypeId)('()+_'), '');
  assert.equal((0, _GaToSplit.fixEventTypeId)('  some   event '), 'some_event_');
  assert.equal((0, _GaToSplit.fixEventTypeId)('  -*- some  -.%^ event =+ '), 'some_-._event_');
  assert.end();
});
(0, _tape.default)('defaultMapper', function (assert) {
  var initTimestamp = Date.now();
  var defaultEvent = (0, _GaToSplit.defaultMapper)(modelSample);
  assert.equal(defaultEvent.eventTypeId, expectedDefaultEvent.eventTypeId, 'should return the corresponding default event instance for a given pageview hit');
  assert.equal(defaultEvent.value, expectedDefaultEvent.value);
  assert.deepEqual(defaultEvent.properties, expectedDefaultEvent.properties);
  assert.true(initTimestamp <= defaultEvent.timestamp && defaultEvent.timestamp <= Date.now());
  assert.end();
});
var sdkOptions = {
  type: 'GOOGLE_ANALYTICS_TO_SPLIT'
};
var coreSettings = {
  key: 'key',
  trafficType: 'user'
};
var fakeStorage = {
  events: {
    track: _sinon.default.stub()
  }
}; // Returns a new event by copying defaultEvent

function customMapper(model, defaultEvent) {
  return _objectSpread(_objectSpread({}, defaultEvent), {}, {
    properties: _objectSpread(_objectSpread({}, defaultEvent.properties), {}, {
      someProp: 'someProp'
    })
  });
} // Updates defaultEvent


function customMapper2(model, defaultEvent) {
  defaultEvent.properties.someProp2 = 'someProp2';
  return defaultEvent;
} // Updates defaultEvent adding a `key` and `TT`, to assert that `identities` plugin param is ignored.


function customMapper3(model, defaultEvent) {
  defaultEvent.key = 'someKey';
  defaultEvent.trafficTypeName = 'someTT';
  return defaultEvent;
}

function customFilter() {
  return true;
}

var customIdentities = [{
  key: 'key2',
  trafficType: 'tt2'
}];
(0, _tape.default)('GaToSplit', function (assert) {
  // test setup
  var _gaMock = (0, _gaMock3.gaMock)(),
      ga = _gaMock.ga,
      tracker = _gaMock.tracker; // provide SplitTracker plugin


  (0, _GaToSplit.default)(sdkOptions, fakeStorage, coreSettings);
  assert.true(ga.calledWith('provide', 'splitTracker'));
  var SplitTracker = ga.lastCall.args[2];
  assert.true(typeof SplitTracker === 'function');
  /** Default behavior */
  // init plugin on default tracker. equivalent to calling `ga('require', 'splitTracker')`

  new SplitTracker(tracker); // send hit and assert that it was properly tracked as a Split event

  window.ga('send', hitSample);
  var event = fakeStorage.events.track.lastCall.args[0];
  assert.deepEqual(event, _objectSpread(_objectSpread({}, expectedDefaultEvent), {}, {
    eventTypeId: _GaToSplit.defaultPrefix + '.' + expectedDefaultEvent.eventTypeId,
    key: coreSettings.key,
    trafficTypeName: coreSettings.trafficType,
    timestamp: event.timestamp
  }), 'should track an event using the default mapper and key and traffic type from the SDK config');
  /** Custom behavior: plugin options */
  // init plugin with custom options

  new SplitTracker(tracker, {
    mapper: customMapper,
    filter: customFilter,
    identities: customIdentities,
    prefix: ''
  }); // send hit and assert that it was properly tracked as a Split event

  window.ga('send', hitSample);
  event = fakeStorage.events.track.lastCall.args[0];
  assert.deepEqual(event, _objectSpread(_objectSpread({}, customMapper(modelSample, (0, _GaToSplit.defaultMapper)(modelSample))), {}, {
    key: customIdentities[0].key,
    trafficTypeName: customIdentities[0].trafficType,
    timestamp: event.timestamp
  }), 'should track an event using a custom mapper and identity from the plugin options');
  /** Custom behavior: SDK options */
  // provide a new SplitTracker plugin with custom SDK options

  (0, _GaToSplit.default)({
    type: 'GOOGLE_ANALYTICS_TO_SPLIT',
    mapper: customMapper2,
    filter: customFilter,
    identities: customIdentities,
    prefix: ''
  }, fakeStorage, coreSettings);
  assert.true(ga.lastCall.calledWith('provide', 'splitTracker'));
  SplitTracker = ga.lastCall.args[2];
  assert.true(typeof SplitTracker === 'function'); // init plugin

  new SplitTracker(tracker); // send hit and assert that it was properly tracked as a Split event

  window.ga('send', hitSample);
  event = fakeStorage.events.track.lastCall.args[0];
  assert.deepEqual(event, _objectSpread(_objectSpread({}, customMapper2(modelSample, (0, _GaToSplit.defaultMapper)(modelSample))), {}, {
    key: customIdentities[0].key,
    trafficTypeName: customIdentities[0].trafficType,
    timestamp: event.timestamp
  }), 'should track the event using a custom mapper and identity from the SDK options');
  /** Custom behavior: SDK options, including a customMapper that set events key and traffic type */
  // provide a new SplitTracker plugin with custom SDK options

  (0, _GaToSplit.default)({
    type: 'GOOGLE_ANALYTICS_TO_SPLIT',
    mapper: customMapper3,
    filter: customFilter,
    identities: customIdentities,
    prefix: ''
  }, fakeStorage, coreSettings);
  assert.true(ga.lastCall.calledWith('provide', 'splitTracker'));
  SplitTracker = ga.lastCall.args[2];
  assert.true(typeof SplitTracker === 'function'); // init plugin

  new SplitTracker(tracker); // send hit and assert that it was properly tracked as a Split event

  window.ga('send', hitSample);
  event = fakeStorage.events.track.lastCall.args[0];
  assert.deepEqual(event, _objectSpread(_objectSpread({}, customMapper3(modelSample, (0, _GaToSplit.defaultMapper)(modelSample))), {}, {
    timestamp: event.timestamp
  }), 'should track the event using a custom mapper and identity from the SDK options'); // test teardown

  (0, _gaMock3.gaRemove)();
  assert.end();
});
(0, _tape.default)('GaToSplit: `hits` flag param', function (assert) {
  // test setup
  var _gaMock2 = (0, _gaMock3.gaMock)(),
      ga = _gaMock2.ga,
      tracker = _gaMock2.tracker;

  (0, _GaToSplit.default)(sdkOptions, fakeStorage, coreSettings);
  var SplitTracker = ga.lastCall.args[2]; // init plugin with custom options

  new SplitTracker(tracker, {
    hits: false
  }); // send hit and assert that it was not tracked as a Split event

  fakeStorage.events.track.resetHistory();
  window.ga('send', hitSample);
  assert.true(fakeStorage.events.track.notCalled); // test teardown

  (0, _gaMock3.gaRemove)();
  assert.end();
});