import _regeneratorRuntime from "@babel/runtime/regenerator";
import _typeof from "@babel/runtime/helpers/esm/typeof";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";

/**
Copyright 2016 Split Software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
import tape from 'tape-catch';
import parser from '../../parser';
import keyParser from '../../../utils/key/parser'; //
// EQUAL_TO_SET
//

tape('PARSER / if user.permissions ["read", "write"] equal to set ["read", "write"] then split 100:on', /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            label = 'permissions = ["read", "write"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'write']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read', 'write']
            });

          case 4:
            evaluation = _context.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["write", "read"] equal to set ["read", "write"] then split 100:on', /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            label = 'permissions = ["read", "write"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'write']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context2.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['write', 'read']
            });

          case 4:
            evaluation = _context2.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["1", 2] equal to set ["1", "2"] then split 100:on', /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            label = 'permissions = ["1", "2"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['1', '2']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context3.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['1', 2]
            });

          case 4:
            evaluation = _context3.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', 'evaluator should return undefined');
            assert.equal(evaluation.label, label, 'label should be correct');
            assert.end();

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["read", "write", "delete"] equal to set ["read", "write"] then not match', /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            label = 'permissions = ["read", "write"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'write']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context4.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read', 'write', 'delete']
            });

          case 4:
            evaluation = _context4.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 8:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x4) {
    return _ref4.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["read"] equal to set ["read", "write"] then not match', /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            label = 'permissions = ["read", "write"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'write']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context5.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read']
            });

          case 4:
            evaluation = _context5.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function (_x5) {
    return _ref5.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["read", "delete"] equal to set ["read", "write"] then not match', /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            label = 'permissions = ["read", "write"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'write']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context6.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read', 'delete']
            });

          case 4:
            evaluation = _context6.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 8:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function (_x6) {
    return _ref6.apply(this, arguments);
  };
}());
tape('PARSER / if user.countries ["argentina", "usa"] equal to set ["usa","argentina"] then split 100:on', /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            label = 'countries = ["usa","argentina"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'countries'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['usa', 'argentina']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context7.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              countries: ['argentina', 'usa']
            });

          case 4:
            evaluation = _context7.sent;
            assert.equal(evaluation.treatment, 'on', "treatment should be 'on'");
            assert.equal(evaluation.label, label, 'label should match');
            assert.end();

          case 8:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function (_x7) {
    return _ref7.apply(this, arguments);
  };
}());
tape('PARSER / if attribute is not an array we should not match equal to set', /*#__PURE__*/function () {
  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            label = 'countries = ["usa","argentina"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'countries'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['usa', 'argentina']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context8.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 4:
            evaluation = _context8.sent;
            assert.equal(evaluation, undefined, 'evaluator should not match');
            _context8.next = 8;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              countries: 'argentina'
            });

          case 8:
            evaluation = _context8.sent;
            assert.equal(evaluation, undefined, 'evaluator should not match');
            assert.end();

          case 11:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));

  return function (_x8) {
    return _ref8.apply(this, arguments);
  };
}());
tape('PARSER / if attribute is an EMPTY array we should not match equal to set', /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            label = 'countries = ["usa","argentina"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'countries'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['usa', 'argentina']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context9.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              countries: []
            });

          case 4:
            evaluation = _context9.sent;
            assert.equal(evaluation, undefined, 'evaluator should not match');
            assert.end();

          case 7:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));

  return function (_x9) {
    return _ref9.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.permissions ["read", "write"] equal to set ["read", "write"] then split 100:on should not match', /*#__PURE__*/function () {
  var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            label = 'not permissions = ["read", "write"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'write']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context10.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read', 'write']
            });

          case 4:
            evaluation = _context10.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 7:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));

  return function (_x10) {
    return _ref10.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.permissions ["read"] equal to set ["read", "write"] false, then match', /*#__PURE__*/function () {
  var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            label = 'not permissions = ["read", "write"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'write']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context11.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read']
            });

          case 4:
            evaluation = _context11.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));

  return function (_x11) {
    return _ref11.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if attribute is not an array we should not match equal to set, so match', /*#__PURE__*/function () {
  var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            label = 'countries = ["usa","argentina"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'countries'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['usa', 'argentina']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context12.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 4:
            evaluation = _context12.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            _context12.next = 9;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              countries: 4
            });

          case 9:
            evaluation = _context12.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 13:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));

  return function (_x12) {
    return _ref12.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if attribute is an EMPTY array we should not match equal to set, so match', /*#__PURE__*/function () {
  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            label = 'countries = ["usa","argentina"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'countries'
                  },
                  matcherType: 'EQUAL_TO_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['usa', 'argentina']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context13.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              countries: []
            });

          case 4:
            evaluation = _context13.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee13);
  }));

  return function (_x13) {
    return _ref13.apply(this, arguments);
  };
}()); //
// CONTAINS_ALL_OF_SET
//

tape('PARSER / if user.permissions ["read", "edit", "delete"] contains all of set ["read", "edit"] then split 100:on', /*#__PURE__*/function () {
  var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            label = 'permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context14.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read', 'edit', 'delete']
            });

          case 4:
            evaluation = _context14.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14);
  }));

  return function (_x14) {
    return _ref14.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["edit", "read", "delete"] contains all of set ["read", "edit"] then split 100:on', /*#__PURE__*/function () {
  var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            label = 'permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context15.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['edit', 'read', 'delete']
            });

          case 4:
            evaluation = _context15.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15);
  }));

  return function (_x15) {
    return _ref15.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions [1, "edit", "delete"] contains all of set ["1", "edit"] then split 100:on', /*#__PURE__*/function () {
  var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            label = 'permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['1', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context16.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: [1, 'edit', 'delete']
            });

          case 4:
            evaluation = _context16.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16);
  }));

  return function (_x16) {
    return _ref16.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["read"] contains all of set ["read", "edit"] then not match', /*#__PURE__*/function () {
  var _ref17 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            label = 'permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context17.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read']
            });

          case 4:
            evaluation = _context17.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should not match');
            assert.end();

          case 8:
          case "end":
            return _context17.stop();
        }
      }
    }, _callee17);
  }));

  return function (_x17) {
    return _ref17.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["read", "delete", "manage"] contains all of set ["read", "edit"] then not match', /*#__PURE__*/function () {
  var _ref18 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee18$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            label = 'permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context18.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read', 'delete', 'manage']
            });

          case 4:
            evaluation = _context18.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should not match');
            assert.end();

          case 8:
          case "end":
            return _context18.stop();
        }
      }
    }, _callee18);
  }));

  return function (_x18) {
    return _ref18.apply(this, arguments);
  };
}());
tape('PARSER / if attribute is not an array we should not match contains all', /*#__PURE__*/function () {
  var _ref19 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            label = 'permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context19.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 4:
            evaluation = _context19.sent;
            assert.equal(evaluation, undefined, 'evaluator should not match');
            _context19.next = 8;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: {}
            });

          case 8:
            evaluation = _context19.sent;
            assert.equal(evaluation, undefined, 'evaluator should not match');
            assert.end();

          case 11:
          case "end":
            return _context19.stop();
        }
      }
    }, _callee19);
  }));

  return function (_x19) {
    return _ref19.apply(this, arguments);
  };
}());
tape('PARSER / if attribute is an EMPTY array we should not match contains all', /*#__PURE__*/function () {
  var _ref20 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee20$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            label = 'permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context20.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: []
            });

          case 4:
            evaluation = _context20.sent;
            assert.equal(evaluation, undefined, 'evaluator should not match');
            assert.end();

          case 7:
          case "end":
            return _context20.stop();
        }
      }
    }, _callee20);
  }));

  return function (_x20) {
    return _ref20.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.permissions ["read", "edit", "delete"] contains all of set ["read", "edit"] then split 100:on should not match', /*#__PURE__*/function () {
  var _ref21 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee21$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            label = 'not permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context21.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read', 'edit', 'delete']
            });

          case 4:
            evaluation = _context21.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 7:
          case "end":
            return _context21.stop();
        }
      }
    }, _callee21);
  }));

  return function (_x21) {
    return _ref21.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.permissions ["read"] contains all of set ["read", "edit"] false, so match', /*#__PURE__*/function () {
  var _ref22 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee22$(_context22) {
      while (1) {
        switch (_context22.prev = _context22.next) {
          case 0:
            label = 'not permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context22.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read']
            });

          case 4:
            evaluation = _context22.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context22.stop();
        }
      }
    }, _callee22);
  }));

  return function (_x22) {
    return _ref22.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if attribute is not an array we should not match contains all, so match', /*#__PURE__*/function () {
  var _ref23 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee23$(_context23) {
      while (1) {
        switch (_context23.prev = _context23.next) {
          case 0:
            label = 'not permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context23.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 4:
            evaluation = _context23.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            _context23.next = 9;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              countries: /asd/
            });

          case 9:
            evaluation = _context23.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 13:
          case "end":
            return _context23.stop();
        }
      }
    }, _callee23);
  }));

  return function (_x23) {
    return _ref23.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if attribute is an EMPTY array we should not match contains all, so match', /*#__PURE__*/function () {
  var _ref24 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee24$(_context24) {
      while (1) {
        switch (_context24.prev = _context24.next) {
          case 0:
            label = 'not permissions contains ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ALL_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context24.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: []
            });

          case 4:
            evaluation = _context24.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context24.stop();
        }
      }
    }, _callee24);
  }));

  return function (_x24) {
    return _ref24.apply(this, arguments);
  };
}()); //
// PART_OF_SET
//

tape('PARSER / if user.permissions ["read", "edit"] is part of set ["read", "edit", "delete"] then split 100:on', /*#__PURE__*/function () {
  var _ref25 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee25$(_context25) {
      while (1) {
        switch (_context25.prev = _context25.next) {
          case 0:
            label = 'permissions part of ["read", "edit", "delete"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'PART_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit', 'delete']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context25.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read', 'edit']
            });

          case 4:
            evaluation = _context25.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context25.stop();
        }
      }
    }, _callee25);
  }));

  return function (_x25) {
    return _ref25.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["edit", "read"] is part of set ["read", "edit", "delete"] then split 100:on', /*#__PURE__*/function () {
  var _ref26 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee26$(_context26) {
      while (1) {
        switch (_context26.prev = _context26.next) {
          case 0:
            label = 'permissions part of ["read", "edit", "delete"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'PART_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit', 'delete']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context26.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['edit', 'read']
            });

          case 4:
            evaluation = _context26.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context26.stop();
        }
      }
    }, _callee26);
  }));

  return function (_x26) {
    return _ref26.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions [1, "edit"] is part of set ["1", "edit", "delete"] then split 100:on', /*#__PURE__*/function () {
  var _ref27 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee27$(_context27) {
      while (1) {
        switch (_context27.prev = _context27.next) {
          case 0:
            label = 'permissions part of ["1", "edit", "delete"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'PART_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['1', 'edit', 'delete']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context27.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: [1, 'edit']
            });

          case 4:
            evaluation = _context27.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context27.stop();
        }
      }
    }, _callee27);
  }));

  return function (_x27) {
    return _ref27.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["admin", "magic"] is part of set ["read", "edit"] then not match', /*#__PURE__*/function () {
  var _ref28 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee28$(_context28) {
      while (1) {
        switch (_context28.prev = _context28.next) {
          case 0:
            label = 'permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'PART_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context28.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['admin', 'magic']
            });

          case 4:
            evaluation = _context28.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 8:
          case "end":
            return _context28.stop();
        }
      }
    }, _callee28);
  }));

  return function (_x28) {
    return _ref28.apply(this, arguments);
  };
}());
tape('PARSER / if attribute is not an array we should not match part of', /*#__PURE__*/function () {
  var _ref29 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee29$(_context29) {
      while (1) {
        switch (_context29.prev = _context29.next) {
          case 0:
            label = 'permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'PART_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context29.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 4:
            evaluation = _context29.sent;
            assert.equal(evaluation, undefined, 'evaluator should not match');
            _context29.next = 8;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: NaN
            });

          case 8:
            evaluation = _context29.sent;
            assert.equal(evaluation, undefined, 'evaluator should not match');
            assert.end();

          case 11:
          case "end":
            return _context29.stop();
        }
      }
    }, _callee29);
  }));

  return function (_x29) {
    return _ref29.apply(this, arguments);
  };
}());
tape('PARSER / if attribute is an EMPTY array we should not match part of', /*#__PURE__*/function () {
  var _ref30 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee30$(_context30) {
      while (1) {
        switch (_context30.prev = _context30.next) {
          case 0:
            label = 'permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'PART_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context30.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: []
            });

          case 4:
            evaluation = _context30.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 7:
          case "end":
            return _context30.stop();
        }
      }
    }, _callee30);
  }));

  return function (_x30) {
    return _ref30.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.permissions ["read", "edit"] is part of set ["read", "edit", "delete"] then split 100:on should not match', /*#__PURE__*/function () {
  var _ref31 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee31(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee31$(_context31) {
      while (1) {
        switch (_context31.prev = _context31.next) {
          case 0:
            label = 'not permissions part of ["read", "edit", "delete"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'PART_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit', 'delete']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context31.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['read', 'edit']
            });

          case 4:
            evaluation = _context31.sent;
            assert.equal(evaluation, undefined, 'evaluation should return treatment undefined');
            assert.end();

          case 7:
          case "end":
            return _context31.stop();
        }
      }
    }, _callee31);
  }));

  return function (_x31) {
    return _ref31.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.permissions ["admin", "magic"] is part of set ["read", "edit"] false, then match', /*#__PURE__*/function () {
  var _ref32 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee32(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee32$(_context32) {
      while (1) {
        switch (_context32.prev = _context32.next) {
          case 0:
            label = 'not permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'PART_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context32.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['admin', 'magic']
            });

          case 4:
            evaluation = _context32.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context32.stop();
        }
      }
    }, _callee32);
  }));

  return function (_x32) {
    return _ref32.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if attribute is not an array we should not match part of, so match', /*#__PURE__*/function () {
  var _ref33 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee33(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee33$(_context33) {
      while (1) {
        switch (_context33.prev = _context33.next) {
          case 0:
            label = 'not permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'PART_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context33.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 4:
            evaluation = _context33.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            _context33.next = 9;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              countries: function countries() {}
            });

          case 9:
            evaluation = _context33.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 13:
          case "end":
            return _context33.stop();
        }
      }
    }, _callee33);
  }));

  return function (_x33) {
    return _ref33.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if attribute is an EMPTY array we should not match part of, so match', /*#__PURE__*/function () {
  var _ref34 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee34(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee34$(_context34) {
      while (1) {
        switch (_context34.prev = _context34.next) {
          case 0:
            label = 'not permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'PART_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context34.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: []
            });

          case 4:
            evaluation = _context34.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context34.stop();
        }
      }
    }, _callee34);
  }));

  return function (_x34) {
    return _ref34.apply(this, arguments);
  };
}()); //
// CONTAINS_ANY_OF_SET
//

tape('PARSER / if user.permissions ["admin", "edit"] contains any of set ["read", "edit", "delete"] then split 100:on', /*#__PURE__*/function () {
  var _ref35 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee35(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee35$(_context35) {
      while (1) {
        switch (_context35.prev = _context35.next) {
          case 0:
            label = 'permissions part of ["read", "edit", "delete"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ANY_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit', 'delete']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context35.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['admin', 'edit']
            });

          case 4:
            evaluation = _context35.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context35.stop();
        }
      }
    }, _callee35);
  }));

  return function (_x35) {
    return _ref35.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["admin", 1] contains any of set ["read", "1", "delete"] then split 100:on', /*#__PURE__*/function () {
  var _ref36 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee36(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee36$(_context36) {
      while (1) {
        switch (_context36.prev = _context36.next) {
          case 0:
            label = 'permissions part of ["read", "1", "delete"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ANY_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', '1', 'delete']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context36.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['admin', 1]
            });

          case 4:
            evaluation = _context36.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context36.stop();
        }
      }
    }, _callee36);
  }));

  return function (_x36) {
    return _ref36.apply(this, arguments);
  };
}());
tape('PARSER / if user.permissions ["admin", "magic"] contains any of set ["read", "edit"] then not match', /*#__PURE__*/function () {
  var _ref37 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee37(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee37$(_context37) {
      while (1) {
        switch (_context37.prev = _context37.next) {
          case 0:
            label = 'permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ANY_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context37.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['admin', 'magic']
            });

          case 4:
            evaluation = _context37.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 8:
          case "end":
            return _context37.stop();
        }
      }
    }, _callee37);
  }));

  return function (_x37) {
    return _ref37.apply(this, arguments);
  };
}());
tape('PARSER / if attribute is not an array we should not match contains any', /*#__PURE__*/function () {
  var _ref38 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee38(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee38$(_context38) {
      while (1) {
        switch (_context38.prev = _context38.next) {
          case 0:
            label = 'permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ANY_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context38.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 4:
            evaluation = _context38.sent;
            assert.equal(evaluation, undefined, 'evaluator should not match');
            _context38.next = 8;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: null
            });

          case 8:
            evaluation = _context38.sent;
            assert.equal(evaluation, undefined, 'evaluator should not match');
            assert.end();

          case 11:
          case "end":
            return _context38.stop();
        }
      }
    }, _callee38);
  }));

  return function (_x38) {
    return _ref38.apply(this, arguments);
  };
}());
tape('PARSER / if attribute is an EMPTY array we should not match contains any', /*#__PURE__*/function () {
  var _ref39 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee39(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee39$(_context39) {
      while (1) {
        switch (_context39.prev = _context39.next) {
          case 0:
            label = 'permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ANY_OF_SET',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context39.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: []
            });

          case 4:
            evaluation = _context39.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 7:
          case "end":
            return _context39.stop();
        }
      }
    }, _callee39);
  }));

  return function (_x39) {
    return _ref39.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.permissions ["admin", "edit"] contains any of set ["read", "edit", "delete"] then split 100:on should not match', /*#__PURE__*/function () {
  var _ref40 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee40(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee40$(_context40) {
      while (1) {
        switch (_context40.prev = _context40.next) {
          case 0:
            label = 'not permissions part of ["read", "edit", "delete"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ANY_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit', 'delete']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context40.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['admin', 'edit']
            });

          case 4:
            evaluation = _context40.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 7:
          case "end":
            return _context40.stop();
        }
      }
    }, _callee40);
  }));

  return function (_x40) {
    return _ref40.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.permissions ["admin", "magic"] contains any of set ["read", "edit"] false, then should match', /*#__PURE__*/function () {
  var _ref41 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee41(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee41$(_context41) {
      while (1) {
        switch (_context41.prev = _context41.next) {
          case 0:
            label = 'not permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ANY_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context41.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: ['admin', 'magic']
            });

          case 4:
            evaluation = _context41.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context41.stop();
        }
      }
    }, _callee41);
  }));

  return function (_x41) {
    return _ref41.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if attribute is not an array we should not match contains any, then should match', /*#__PURE__*/function () {
  var _ref42 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee42(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee42$(_context42) {
      while (1) {
        switch (_context42.prev = _context42.next) {
          case 0:
            label = 'not permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ANY_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context42.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 4:
            evaluation = _context42.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context42.stop();
        }
      }
    }, _callee42);
  }));

  return function (_x42) {
    return _ref42.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if attribute is an EMPTY array we should not match contains any, then should match', /*#__PURE__*/function () {
  var _ref43 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee43(assert) {
    var label, evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee43$(_context43) {
      while (1) {
        switch (_context43.prev = _context43.next) {
          case 0:
            label = 'not permissions part of ["read", "edit"]';
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'permissions'
                  },
                  matcherType: 'CONTAINS_ANY_OF_SET',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  unaryStringMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['read', 'edit']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context43.next = 4;
            return evaluator(keyParser('a key'), 31, 100, 31, {
              permissions: []
            });

          case 4:
            evaluation = _context43.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context43.stop();
        }
      }
    }, _callee43);
  }));

  return function (_x43) {
    return _ref43.apply(this, arguments);
  };
}());