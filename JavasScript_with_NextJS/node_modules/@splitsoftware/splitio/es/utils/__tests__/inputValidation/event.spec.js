import tape from 'tape-catch';
import sinon from 'sinon';
import proxyquire from 'proxyquire';
var proxyquireStrict = proxyquire.noCallThru();
var loggerMock = {
  warn: sinon.stub(),
  error: sinon.stub()
};

function LogFactoryMock() {
  return loggerMock;
}

var _proxyquireStrict = proxyquireStrict('../../inputValidation/event', {
  '../logger': LogFactoryMock
}),
    validateEvent = _proxyquireStrict.validateEvent;
/* We'll reset the history for the next test */


function resetStubs() {
  loggerMock.warn.resetHistory();
  loggerMock.error.resetHistory();
}

var errorMsgs = {
  NULL_EVENT: function NULL_EVENT() {
    return 'you passed a null or undefined event_type, event_type must be a non-empty string.';
  },
  WRONG_TYPE_EVENT: function WRONG_TYPE_EVENT() {
    return 'you passed an invalid event_type, event_type must be a non-empty string.';
  },
  EMPTY_EVENT: function EMPTY_EVENT() {
    return 'you passed an empty event_type, event_type must be a non-empty string.';
  },
  WRONG_FORMAT_EVENT: function WRONG_FORMAT_EVENT(invalidEvent) {
    return "you passed \"".concat(invalidEvent, "\", event_type must adhere to the regular expression /^[a-zA-Z0-9][-_.:a-zA-Z0-9]{0,79}$/g. This means an event_type must be alphanumeric, cannot be more than 80 characters long, and can only include a dash, underscore, period, or colon as separators of alphanumeric characters.");
  }
};
var invalidEvents = [{
  event: [],
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: function event() {},
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: false,
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: true,
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: {},
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: Object.create({}),
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: 'something+withInvalidchars',
  msg: errorMsgs.WRONG_FORMAT_EVENT
}, {
  event: 'with spaces',
  msg: errorMsgs.WRONG_FORMAT_EVENT
}, {
  event: ' asd',
  msg: errorMsgs.WRONG_FORMAT_EVENT
}, {
  event: 'asd ',
  msg: errorMsgs.WRONG_FORMAT_EVENT
}, {
  event: '?',
  msg: errorMsgs.WRONG_FORMAT_EVENT
}, {
  event: '',
  msg: errorMsgs.EMPTY_EVENT
}, {
  event: NaN,
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: -Infinity,
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: Infinity,
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: new Promise(function (res) {
    return res;
  }),
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: Symbol('asd'),
  msg: errorMsgs.WRONG_TYPE_EVENT
}, {
  event: null,
  msg: errorMsgs.NULL_EVENT
}, {
  event: undefined,
  msg: errorMsgs.NULL_EVENT
}];
tape('INPUT VALIDATION for Event types', function (t) {
  t.test('Should return the provided event type if it is a valid string without logging any errors', function (assert) {
    assert.equal(validateEvent('valid:Too', 'some_method_eventType'), 'valid:Too', 'It should return the provided string if it is valid.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.equal(validateEvent('I.am.valid-string_ValUe', 'some_method_eventType'), 'I.am.valid-string_ValUe', 'It should return the provided string if it is valid.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.equal(validateEvent('a', 'some_method_eventType'), 'a', 'It should return the provided string if it is valid.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('Should return false and log error if event type is not a valid string', function (assert) {
    for (var i = 0; i < invalidEvents.length; i++) {
      var invalidValue = invalidEvents[i]['event'];
      var expectedLog = invalidEvents[i]['msg'](invalidValue);
      assert.equal(validateEvent(invalidValue, 'test_method'), false, 'Invalid event types should always return false.');
      assert.ok(loggerMock.error.calledWithMatch("test_method: ".concat(expectedLog)), 'Should log the error for the invalid event type.');
      loggerMock.error.resetHistory();
    }

    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
});