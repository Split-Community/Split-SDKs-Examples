import proxyquire from 'proxyquire';
import tape from 'tape-catch';
import sinon from 'sinon';
var proxyquireStrict = proxyquire.noCallThru();
var loggerMock = {
  warn: sinon.stub(),
  error: sinon.stub()
};

function LogFactoryMock() {
  return loggerMock;
}

var _proxyquireStrict = proxyquireStrict('../../inputValidation/attributes', {
  '../logger': LogFactoryMock
}),
    validateAttributes = _proxyquireStrict.validateAttributes;
/* We'll reset the history for the next test */


function resetStubs() {
  loggerMock.warn.resetHistory();
  loggerMock.error.resetHistory();
}

var invalidAttributes = [[], function () {}, false, true, 5, 'something', NaN, -Infinity, new Promise(function (res) {
  return res;
}), Symbol('asd'), NaN];
tape('INPUT VALIDATION for Attributes', function (t) {
  t.test('Should return the passed object if it is a valid attributes map without logging any errors', function (assert) {
    var validAttributes = {
      amIvalid: 'yes',
      'are_you_sure': true,
      howMuch: 10
    };
    assert.deepEqual(validateAttributes(validAttributes, 'some_method_attrs'), validAttributes, 'It should return the passed map if it is valid.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('Should return the passed value if it is null or undefined (since attributes are optional) without logging any errors', function (assert) {
    assert.equal(validateAttributes(null, 'some_method_attrs'), null, 'It should return the passed null.');
    assert.equal(validateAttributes(undefined, 'some_method_attrs'), undefined, 'It should return the passed undefined.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('Should return false and log error if attributes map is invalid', function (assert) {
    for (var i = 0; i < invalidAttributes.length; i++) {
      var invalidAttribute = invalidAttributes[i];
      assert.equal(validateAttributes(invalidAttribute, 'test_method'), false, 'Invalid attribute objects should return false.');
      assert.ok(loggerMock.error.calledWithExactly('test_method: attributes must be a plain object.'), 'The error should be logged for the invalid attributes map.');
      loggerMock.error.resetHistory();
    }

    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
});