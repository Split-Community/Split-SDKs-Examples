import _typeof from "@babel/runtime/helpers/esm/typeof";
import tape from 'tape-catch';
import sinon from 'sinon';
/* eslint-disable no-console */

import { Logger, LogLevels, setLogLevel } from '../../logger/LoggerFactory';
import { LOG_LEVELS } from './index.spec.js';
tape('SPLIT LOGGER FACTORY / setLogLevel utility function', function (assert) {
  assert.equal(_typeof(setLogLevel), 'function', 'setLogLevel should be a function');
  assert.doesNotThrow(setLogLevel, 'Calling setLogLevel should not throw an error.');
  assert.end();
});
tape('SPLIT LOGGER FACTORY / LogLevels exposed mappings', function (assert) {
  assert.deepEqual(LogLevels, LOG_LEVELS, 'Exposed log levels should contain the levels we want.');
  assert.end();
});
tape('SPLIT LOGGER FACTORY / Logger class shape', function (assert) {
  assert.equal(_typeof(Logger), 'function', 'Logger should be a class we can instantiate.');
  var logger = new Logger('test-category', {});
  assert.equal(_typeof(logger.debug), 'function', 'instance.debug should be a method.');
  assert.equal(_typeof(logger.info), 'function', 'instance.info should be a method.');
  assert.equal(_typeof(logger.warn), 'function', 'instance.warn should be a method.');
  assert.equal(_typeof(logger.error), 'function', 'instance.error should be a method.');
  assert.end();
});
var LOG_LEVELS_IN_ORDER = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'NONE'];
/* Utility function to avoid repeating too much code */

function testLogLevels(levelToTest, assert) {
  // Builds the expected message.
  var buildExpectedMessage = function buildExpectedMessage(lvl, category, msg, showLevel) {
    var res = '';
    if (showLevel) res += '[' + lvl + ']' + (lvl.length === 4 ? '  ' : ' ');
    res += category + ' => ';
    res += msg;
    return res;
  }; // Runs the suite with the given value for showLevel option.


  var runTests = function runTests(showLevel, displayAllErrors) {
    var logLevelLogsCounter = 0;
    var testForNoLog = false;
    var logMethod = levelToTest.toLowerCase();
    var logCategory = "test-category-".concat(logMethod).concat(displayAllErrors ? 'displayAllErrors' : '');
    var instance = new Logger(logCategory, {
      showLevel: showLevel,
      displayAllErrors: displayAllErrors
    });
    LOG_LEVELS_IN_ORDER.forEach(function (logLevel, i) {
      var logMsg = "Test log for level ".concat(levelToTest, " (").concat(displayAllErrors ? 'But all errors are configured to display' : 'Errors not forced to display', ") with showLevel: ").concat(showLevel, " ").concat(logLevelLogsCounter);
      var expectedMessage = buildExpectedMessage(levelToTest, logCategory, logMsg, showLevel); // Log error should always be visible.

      if (logMethod === LOG_LEVELS.ERROR.toLowerCase() && displayAllErrors) testForNoLog = false; // Set the logLevel for this iteration.

      setLogLevel(LogLevels[logLevel]); // Call the method

      instance[logMethod](logMsg); // Assert if console.log was called.

      assert[testForNoLog ? 'notOk' : 'ok'](console.log.calledWith(expectedMessage), "Calling ".concat(logMethod, " method should ").concat(testForNoLog ? 'NOT ' : '', "log with ").concat(logLevel, " log level. ").concat(displayAllErrors ? 'But all errors are configured to display.' : ''));

      if (LOG_LEVELS_IN_ORDER.indexOf(levelToTest) <= i) {
        testForNoLog = true;
      }

      logLevelLogsCounter++;
    });
  }; // Spy console.log


  sinon.spy(console, 'log'); // Show logLevel

  runTests(true);
  runTests(true, true); // Hide logLevel

  runTests(false);
  runTests(false, true); // Restore stub.

  console.log.restore();
}

tape('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.debug', function (assert) {
  testLogLevels(LogLevels.DEBUG, assert);
  assert.end();
});
tape('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.info', function (assert) {
  testLogLevels(LogLevels.INFO, assert);
  assert.end();
});
tape('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.warn', function (assert) {
  testLogLevels(LogLevels.WARN, assert);
  assert.end();
});
tape('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.error', function (assert) {
  testLogLevels(LogLevels.ERROR, assert, true);
  assert.end();
});