import _typeof from "@babel/runtime/helpers/esm/typeof";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import tape from 'tape-catch';
import sinon from 'sinon';
import EventTracker from '../event';
import { STORAGE, INTEGRATIONS_MANAGER } from '../../utils/context/constants';
/* Mocks start */

var generateContextMocks = function generateContextMocks() {
  // We are only mocking the pieces we care about
  var fakeStorage = {
    events: {
      track: sinon.stub()
    }
  };
  var fakeIntegrationsManager = {
    handleEvent: sinon.stub()
  };
  return {
    fakeStorage: fakeStorage,
    fakeIntegrationsManager: fakeIntegrationsManager
  };
};

var ContextMock = /*#__PURE__*/function () {
  function ContextMock(fakeStorage, fakeIntegrationsManager) {
    _classCallCheck(this, ContextMock);

    this.constants = {
      STORAGE: STORAGE,
      INTEGRATIONS_MANAGER: INTEGRATIONS_MANAGER
    };
    this.fakeStorage = fakeStorage;
    this.fakeIntegrationsManager = fakeIntegrationsManager;
  }

  _createClass(ContextMock, [{
    key: "get",
    value: function get(target) {
      switch (target) {
        case STORAGE:
          return this.fakeStorage;

        case INTEGRATIONS_MANAGER:
          return this.fakeIntegrationsManager;

        default:
          break;
      }
    }
  }]);

  return ContextMock;
}();
/* Mocks end */


tape('Event Tracker', function (t) {
  t.test('Tracker API', function (assert) {
    assert.equal(_typeof(EventTracker), 'function', 'The module should return a function which acts as a factory.');

    var _generateContextMocks = generateContextMocks(),
        fakeStorage = _generateContextMocks.fakeStorage;

    var contextMock = new ContextMock(fakeStorage);
    var instance = EventTracker(contextMock);
    assert.equal(_typeof(instance.track), 'function', 'The instance should implement the track method.');
    assert.end();
  });
  t.test('Propagate the event into the event cache and integrations manager, and return its result (a boolean or a promise that resolves to boolean)', function (assert) {
    var _generateContextMocks2 = generateContextMocks(),
        fakeStorage = _generateContextMocks2.fakeStorage,
        fakeIntegrationsManager = _generateContextMocks2.fakeIntegrationsManager;

    var fakeEvent = {
      eventTypeId: 'eventTypeId',
      trafficTypeName: 'trafficTypeName',
      value: 0,
      timestamp: Date.now(),
      key: 'matchingKey',
      properties: {
        prop1: 'prop1',
        prop2: 0
      }
    };
    fakeStorage.events.track.withArgs(fakeEvent, 1).returns(true);
    fakeStorage.events.track.withArgs(fakeEvent, 2).returns(Promise.resolve(false));
    fakeStorage.events.track.withArgs(fakeEvent, 3).returns(Promise.resolve(true));
    var contextMock = new ContextMock(fakeStorage, fakeIntegrationsManager);
    var tracker = EventTracker(contextMock);
    var result1 = tracker.track(fakeEvent, 1);
    assert.true(fakeStorage.events.track.calledWithExactly(sinon.match.same(fakeEvent), 1), 'Should be present in the event cache.');
    assert.true(!fakeIntegrationsManager.handleEvent.calledOnce, 'The integration manager handleEvent method should not be executed synchronously.');
    assert.true(result1, true, 'Should return the value of the event cache.');
    setTimeout(function () {
      assert.true(fakeIntegrationsManager.handleEvent.calledOnceWithExactly(fakeEvent), 'A copy of the tracked event should be sent to integration manager after the timeout wrapping make it to the queue stack.');
      assert.false(fakeIntegrationsManager.handleEvent.calledOnceWithExactly(sinon.match.same(fakeEvent)), 'Should not send the original event.');
      var result2 = tracker.track(fakeEvent, 2);
      assert.true(fakeStorage.events.track.calledWithExactly(sinon.match.same(fakeEvent), 2), 'Should be present in the event cache.');
      result2.then(function (tracked) {
        assert.equal(tracked, false, 'Should return the value of the event cache resolved promise.');
        setTimeout(function () {
          assert.true(fakeIntegrationsManager.handleEvent.calledOnce, 'Untracked event should not be sent to integration manager.');
          var result3 = tracker.track(fakeEvent, 3);
          assert.true(fakeStorage.events.track.calledWithExactly(sinon.match.same(fakeEvent), 3), 'Should be present in the event cache.');
          result3.then(function (tracked) {
            assert.false(fakeIntegrationsManager.handleEvent.calledTwice, 'Tracked event should not be sent to integration manager synchronously');
            assert.equal(tracked, true, 'Should return the value of the event cache resolved promise.');
            setTimeout(function () {
              assert.true(fakeIntegrationsManager.handleEvent.getCalls()[1].calledWithExactly(fakeEvent), 'A copy of tracked event should be sent to integration manager after the timeout wrapping make it to the queue stack.');
              assert.false(fakeIntegrationsManager.handleEvent.getCalls()[1].calledWithExactly(sinon.match.same(fakeEvent)), 'Should not send the original event.');
              assert.end();
            }, 0);
          });
        }, 0);
      });
    }, 0);
  });
});