import _regeneratorRuntime from "@babel/runtime/regenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { SplitFactory } from '../..';
import SettingsFactory from '../../utils/settings';
import splitChangesMock1 from '../mocks/splitchanges.since.-1.json';
import { DEBUG } from '../../utils/constants'; // Header keys and expected values. Expected values are obtained with the runtime function evaluated with IPAddressesEnabled in true.

var HEADER_SPLITSDKMACHINEIP = 'SplitSDKMachineIP';
var HEADER_SPLITSDKMACHINENAME = 'SplitSDKMachineName'; // Refresh rates are set to 1 second to finish the test quickly. Otherwise, it would finish in 1 minute (60 seconds is the default value)

var baseConfig = {
  scheduler: {
    metricsRefreshRate: 1,
    impressionsRefreshRate: 1,
    eventsPushRate: 1
  },
  streamingEnabled: false,
  sync: {
    impressionsMode: DEBUG
  }
}; // Config with IPAddressesEnabled set to false

var configWithIPAddressesDisabled = _objectSpread(_objectSpread({}, baseConfig), {}, {
  core: {
    authorizationKey: '<fake-token>',
    key: 'nicolas@split.io',
    IPAddressesEnabled: false
  },
  urls: {
    sdk: 'https://sdk.split-ipdisabled.io/api',
    events: 'https://events.split-ipdisabled.io/api'
  }
}); // Config with IPAddressesEnabled set to true


var configWithIPAddressesEnabled = _objectSpread(_objectSpread({}, baseConfig), {}, {
  core: {
    authorizationKey: '<fake-token>',
    key: 'nicolas@split.io',
    IPAddressesEnabled: true
  },
  urls: {
    sdk: 'https://sdk.split-ipenabled.io/api',
    events: 'https://events.split-ipenabled.io/api'
  }
}); // Config with default IPAddressesEnabled (true)


var configWithIPAddressesDefault = _objectSpread(_objectSpread({}, baseConfig), {}, {
  core: {
    authorizationKey: '<fake-token>',
    key: 'nicolas@split.io'
  },
  urls: {
    sdk: 'https://sdk.split-ipdefault.io/api',
    events: 'https://events.split-ipdefault.io/api'
  }
});

var configSamples = [configWithIPAddressesDisabled, configWithIPAddressesEnabled, configWithIPAddressesDefault];
var postEndpoints = ['/events/bulk', '/testImpressions/bulk', '/metrics/times', '/metrics/counters'];
export default function (fetchMock, assert) {
  // Generator to synchronize the call of assert.end() when all Splitio configurations are run.
  var finish = /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var CONFIG_SAMPLES_COUNT, i;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            CONFIG_SAMPLES_COUNT = configSamples.length;
            i = 0;

          case 2:
            if (!(i < CONFIG_SAMPLES_COUNT - 1)) {
              _context.next = 8;
              break;
            }

            _context.next = 5;
            return;

          case 5:
            i++;
            _context.next = 2;
            break;

          case 8:
            assert.end();

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })(); // Assert request headers


  function assertHeaders(IPAddressesEnabled, req) {
    assert.false(HEADER_SPLITSDKMACHINEIP in req.headers, "Request must not include ".concat(HEADER_SPLITSDKMACHINEIP, " header, no matters the value of IPAddressesEnabled."));
    assert.false(HEADER_SPLITSDKMACHINENAME in req.headers, "Request must not include ".concat(HEADER_SPLITSDKMACHINENAME, " header, no matters the value of IPAddressesEnabled."));
  }

  function mockAndAssertIPAddressesEnabled(config) {
    // Assert properties in impressions logged to impression listener
    config.impressionListener = {
      logImpression: function logImpression(impression) {
        assert.false(impression.ip, '"ip" property in impressions must be false, no matters the value of IPAddressesEnabled.');
        assert.false(impression.hostname, '"hostname" property in impressions must be false, no matters the value of IPAddressesEnabled.');
      }
    }; // Mock GET endpoints before creating the client

    var settings = SettingsFactory(config);
    fetchMock.getOnce(settings.url('/splitChanges?since=-1'), {
      status: 200,
      body: splitChangesMock1
    });
    fetchMock.getOnce(settings.url('/splitChanges?since=1457552620999'), {
      status: 200,
      body: {
        splits: [],
        since: 1457552620999,
        till: 1457552620999
      }
    });
    fetchMock.getOnce(settings.url("/mySegments/".concat(encodeURIComponent(config.core.key))), {
      status: 200,
      body: {
        mySegments: []
      }
    }); // Init Split client

    var splitio = SplitFactory(config);
    var client = splitio.client(); // Generator to synchronize the destruction of the client when all the post endpoints where called once.

    var finishConfig = /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var POST_ENDPOINTS_TO_TEST, i;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              POST_ENDPOINTS_TO_TEST = postEndpoints.length;
              i = 0;

            case 2:
              if (!(i < POST_ENDPOINTS_TO_TEST - 1)) {
                _context2.next = 8;
                break;
              }

              _context2.next = 5;
              return;

            case 5:
              i++;
              _context2.next = 2;
              break;

            case 8:
              client.destroy();
              finish.next();

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })(); // Mock and assert POST endpoints


    postEndpoints.forEach(function (postEndpoint) {
      fetchMock.postOnce(settings.url(postEndpoint), function (url, opts) {
        assertHeaders(settings.core.IPAddressesEnabled, opts);
        finishConfig.next();
        return 200;
      });
    }); // Run normal client flow

    client.ready().then(function () {
      client.getTreatment('hierarchical_splits_test');
      client.track('sometraffictype', 'someEvent', 10);
    });
  }

  configSamples.forEach(function (configSample) {
    return mockAndAssertIPAddressesEnabled(configSample);
  });
}