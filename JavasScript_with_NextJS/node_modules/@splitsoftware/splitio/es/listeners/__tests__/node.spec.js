import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import tape from 'tape-catch';
import sinon from 'sinon';
var processOnSpy = sinon.spy();
var processRemoveListenerSpy = sinon.spy();
var processKillSpy = sinon.spy();
sinon.stub(process, 'on').callsFake(processOnSpy);
sinon.stub(process, 'removeListener').callsFake(processRemoveListenerSpy);
sinon.stub(process, 'kill').callsFake(processKillSpy);
import NodeSignalListener from '../node';
tape('Node JS / Signal Listener class methods and start/stop functionality', function (assert) {
  var listener = new NodeSignalListener();
  var handlerMock = sinon.spy();
  listener.start(handlerMock); // Assigned right function to right signal.

  assert.ok(processOnSpy.calledOnce);
  assert.ok(processOnSpy.calledOnceWithExactly('SIGTERM', listener._sigtermHandler)); // pre-check and call stop

  assert.ok(processRemoveListenerSpy.notCalled);
  listener.stop(); // removed correct listener from correct signal on stop.

  assert.ok(processRemoveListenerSpy.calledOnce);
  assert.ok(processRemoveListenerSpy.calledOnceWithExactly('SIGTERM', listener._sigtermHandler));
  assert.end();
});
tape('Node JS / Signal Listener SIGTERM callback with sync handler', function (assert) {
  var listener = new NodeSignalListener();
  var handlerMock = sinon.spy();
  listener.start(handlerMock); // Stub stop function since we don't want side effects on test.

  sinon.stub(listener, 'stop'); // Control asserts.

  assert.ok(listener.stop.notCalled);
  assert.ok(handlerMock.notCalled);
  assert.ok(processKillSpy.notCalled); // Call function

  listener._sigtermHandler(); // Handler was properly called.


  assert.ok(handlerMock.calledOnce); // Clean up is called.

  assert.ok(listener.stop.calledOnce); // It called for kill again, so the shutdown keeps going.

  assert.ok(processKillSpy.calledOnce);
  assert.ok(processKillSpy.calledOnceWithExactly(process.pid, 'SIGTERM')); // Reset the kill spy since it's used on other tests.

  processKillSpy.resetHistory();
  assert.end();
});
tape('Node JS / Signal Listener SIGTERM callback with sync handler that throws an error', function (assert) {
  var listener = new NodeSignalListener();
  var handlerMock = sinon.stub().throws();
  listener.start(handlerMock); // Stub stop function since we don't want side effects on test.

  sinon.stub(listener, 'stop'); // Control asserts.

  assert.ok(listener.stop.notCalled);
  assert.ok(handlerMock.notCalled);
  assert.ok(processKillSpy.notCalled); // Call function.

  listener._sigtermHandler(); // Handler was properly called.


  assert.ok(handlerMock.calledOnce); // Even if the handler throws, clean up is called.

  assert.ok(listener.stop.calledOnce); // Even if the handler throws, it should call for kill again, so the shutdown keeps going.

  assert.ok(processKillSpy.calledOnce);
  assert.ok(processKillSpy.calledOnceWithExactly(process.pid, 'SIGTERM')); // Reset the kill spy since it's used on other tests.

  processKillSpy.resetHistory();
  assert.end();
});
tape('Node JS / Signal Listener SIGTERM callback with async handler', /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(assert) {
    var listener, clock, fakePromise, handlerMock;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            listener = new NodeSignalListener();
            clock = sinon.useFakeTimers();
            fakePromise = new Promise(function (res) {
              setTimeout(function () {
                res();
              }, 0);
            });
            handlerMock = sinon.stub().returns(fakePromise); // Stub stop function since we don't want side effects on test.

            sinon.stub(listener, 'stop'); // Start the listener

            listener.start(handlerMock); // Call function

            listener._sigtermHandler(); // Handler was properly called.


            assert.ok(handlerMock.calledOnce); // Check that the wrap up is waiting for the promise to be resolved.

            assert.ok(listener.stop.notCalled);
            assert.ok(processKillSpy.notCalled);
            fakePromise.then(function () {
              // Clean up is called even if there is an error.
              assert.ok(listener.stop.calledOnce); // It called for kill again, so the shutdown keeps going.

              assert.ok(processKillSpy.calledOnce);
              assert.ok(processKillSpy.calledOnceWithExactly(process.pid, 'SIGTERM')); // Reset the kill spy since it's used on other tests.

              processKillSpy.resetHistory();
              clock.restore();
              assert.end();
            }); // Ticking the clock, timer should execute and fake promise resolved.

            clock.next();
            return _context.abrupt("return", fakePromise);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
tape('Node JS / Signal Listener SIGTERM callback with async handler that throws an error', /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(assert) {
    var listener, fakePromise, clock, handlerMock, handlerPromise;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            listener = new NodeSignalListener();
            fakePromise = new Promise(function (res, rej) {
              setTimeout(function () {
                rej();
              }, 0);
            });
            clock = sinon.useFakeTimers();
            handlerMock = sinon.stub().returns(fakePromise); // Stub stop function since we don't want side effects on test.

            sinon.stub(listener, 'stop'); // Start the listener

            listener.start(handlerMock); // Call function

            handlerPromise = listener._sigtermHandler(); // Handler was properly called.

            assert.ok(handlerMock.calledOnce); // Check that the wrap up is waiting for the promise to be resolved.

            assert.ok(listener.stop.notCalled);
            assert.ok(processKillSpy.notCalled); // Calling .then since the wrapUp handler does not throw.

            handlerPromise.then(function () {
              // Clean up is called.
              assert.ok(listener.stop.calledOnce); // It called for kill again, so the shutdown keeps going.

              assert.ok(processKillSpy.calledOnce);
              assert.ok(processKillSpy.calledOnceWithExactly(process.pid, 'SIGTERM'));
              /* Clean up everything */

              clock.restore();
              process.on.restore();
              process.removeListener.restore();
              process.kill.restore();
              assert.end();
            }); // Ticking the clock, timer should execute and fake promise resolved.

            clock.next();
            return _context2.abrupt("return", handlerPromise);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());