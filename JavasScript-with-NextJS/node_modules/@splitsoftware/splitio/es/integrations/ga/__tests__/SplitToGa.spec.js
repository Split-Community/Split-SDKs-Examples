import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import tape from 'tape';
import SplitToGa from '../SplitToGa';
import { SPLIT_IMPRESSION, SPLIT_EVENT } from '../../../utils/constants';
import { gaMock, gaRemove } from './gaMock';
var fakeImpressionPayload = {
  impression: {
    feature: 'hierarchical_splits_test',
    keyName: 'nicolas@split.io',
    treatment: 'on',
    bucketingKey: undefined,
    label: 'expected label'
  },
  attributes: undefined,
  ip: 'ip',
  hostname: 'hostname',
  sdkLanguageVersion: 'version'
};
var fakeImpression = {
  type: SPLIT_IMPRESSION,
  payload: fakeImpressionPayload
};
var defaultImpressionFieldsObject = {
  hitType: 'event',
  eventCategory: 'split-impression',
  eventAction: 'Evaluate ' + fakeImpressionPayload.impression.feature,
  eventLabel: 'Treatment: ' + fakeImpressionPayload.impression.treatment + '. Targeting rule: ' + fakeImpressionPayload.impression.label + '.',
  nonInteraction: true
};
var fakeEventPayload = {
  eventTypeId: 'eventTypeId',
  trafficTypeName: 'trafficTypeName',
  value: 0,
  timestamp: Date.now(),
  key: 'key',
  properties: undefined
};
var fakeEvent = {
  type: SPLIT_EVENT,
  payload: fakeEventPayload
};
var defaultEventFieldsObject = {
  hitType: 'event',
  eventCategory: 'split-event',
  eventAction: fakeEventPayload.eventTypeId,
  eventValue: fakeEventPayload.value,
  nonInteraction: true
};
tape('SplitToGa', function (t) {
  t.test('SplitToGa.validateFieldsObject', function (assert) {
    assert.equal(SplitToGa.validateFieldsObject(undefined), false);
    assert.equal(SplitToGa.validateFieldsObject(null), false);
    assert.equal(SplitToGa.validateFieldsObject(123), false);
    assert.equal(SplitToGa.validateFieldsObject(true), false);
    assert.equal(SplitToGa.validateFieldsObject('something'), false);
    assert.equal(SplitToGa.validateFieldsObject(/asd/ig), false);
    assert.equal(SplitToGa.validateFieldsObject(function () {}), false);
    assert.equal(SplitToGa.validateFieldsObject({}), false, 'An empty object is an invalid FieldsObject instance');
    assert.equal(SplitToGa.validateFieldsObject({
      hitType: 10
    }), true, 'A fields object instance must have a HitType');
    assert.equal(SplitToGa.validateFieldsObject({
      hitType: 'event',
      ignoredProp: 'ignoredProp'
    }), true, 'A fields object instance must have a HitType');
    assert.end();
  });
  t.test('SplitToGa.defaultMapper', function (assert) {
    assert.deepEqual(SplitToGa.defaultMapper(fakeImpression), defaultImpressionFieldsObject, 'should return the corresponding FieldsObject for a given impression');
    assert.deepEqual(SplitToGa.defaultMapper(fakeEvent), defaultEventFieldsObject, 'should return the corresponding FieldsObject for a given event');
    assert.end();
  });
  t.test('SplitToGa.getGa', function (assert) {
    var _gaMock = gaMock(),
        ga = _gaMock.ga;

    assert.equal(SplitToGa.getGa(), ga, 'should return ga command queue if it exists');
    gaRemove();
    assert.equal(SplitToGa.getGa(), undefined, 'should return undefined if ga command queue does not exist');
    assert.end();
  });
  t.test('SplitToGa (constructor and queue method)', function (assert) {
    // test setup
    var _gaMock2 = gaMock(),
        ga = _gaMock2.ga;
    /** Default behaviour **/


    var instance = new SplitToGa();
    instance.queue(fakeImpression);
    assert.true(ga.lastCall.calledWithExactly('send', _objectSpread(_objectSpread({}, defaultImpressionFieldsObject), {}, {
      splitHit: true
    })), 'should queue `ga send` with the default mapped FieldsObject for impressions, appended with `splitHit` field');
    instance.queue(fakeEvent);
    assert.true(ga.lastCall.calledWithExactly('send', _objectSpread(_objectSpread({}, defaultEventFieldsObject), {}, {
      splitHit: true
    })), 'should queue `ga send` with the default mapped FieldsObject for events, appended with `splitHit` field');
    assert.equal(ga.callCount, 2);
    /** Custom behaviour **/
    // Custom filter

    function customFilter(data) {
      return data.type === SPLIT_EVENT;
    } // Custom mapper that returns a new FieldsObject instance


    function customMapper() {
      return {
        hitType: 'event',
        someField: 'someField'
      };
    }

    var trackerNames = ['', 'namedTracker'];
    var instance2 = new SplitToGa({
      filter: customFilter,
      mapper: customMapper,
      trackerNames: trackerNames
    });
    ga.resetHistory();
    instance2.queue(fakeImpression);
    assert.true(ga.notCalled, 'shouldn\'t queue `ga send` if a Split data (impression or event) is filtered');
    instance2.queue(fakeEvent);
    assert.true(ga.calledWithExactly('send', _objectSpread(_objectSpread({}, customMapper(fakeImpression, defaultImpressionFieldsObject)), {}, {
      splitHit: true
    })), 'should queue `ga send` with the custom trackerName and FieldsObject from customMapper, appended with `splitHit` field');
    assert.true(ga.calledWithExactly("".concat(trackerNames[1], ".send"), _objectSpread(_objectSpread({}, customMapper(fakeEvent, defaultEventFieldsObject)), {}, {
      splitHit: true
    })), 'should queue `ga send` with the custom trackerName and FieldsObject from customMapper, appended with `splitHit` field');
    assert.equal(ga.callCount, 2); // Custom mapper that returns the default FieldsObject

    function customMapper2(data, defaultFieldsObject) {
      return defaultFieldsObject;
    }

    var instance3 = new SplitToGa({
      mapper: customMapper2
    });
    ga.resetHistory();
    instance3.queue(fakeImpression);
    assert.true(ga.lastCall.calledWithExactly('send', _objectSpread(_objectSpread({}, customMapper2(fakeImpression, defaultImpressionFieldsObject)), {}, {
      splitHit: true
    })), 'should queue `ga send` with the custom FieldsObject from customMapper2, appended with `splitHit` field');
    assert.equal(ga.callCount, 1); // Custom mapper that throws an error

    function customMapper3() {
      throw 'some error';
    }

    var instance4 = new SplitToGa({
      mapper: customMapper3
    });
    ga.resetHistory();
    instance4.queue(fakeImpression);
    assert.true(ga.notCalled, 'shouldn\'t queue `ga send` if a custom mapper throw an exception'); // `impressions` flags

    var instance5 = new SplitToGa({
      impressions: false
    });
    ga.resetHistory();
    instance5.queue(fakeImpression);
    assert.true(ga.notCalled, 'shouldn\'t queue `ga send` for an impression if `impressions` flag is false'); // `impressions` flags

    var instance6 = new SplitToGa({
      events: false
    });
    ga.resetHistory();
    instance6.queue(fakeEvent);
    assert.true(ga.notCalled, 'shouldn\'t queue `ga send` for a event if `events` flag is false'); // test teardown

    gaRemove();
    assert.end();
  });
});