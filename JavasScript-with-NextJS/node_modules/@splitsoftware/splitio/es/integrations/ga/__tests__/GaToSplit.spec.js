import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import tape from 'tape';
import sinon from 'sinon';
import GaToSplit, { validateIdentities, defaultPrefix, defaultMapper, validateEventData, fixEventTypeId } from '../GaToSplit';
import { gaMock, gaRemove, modelMock } from './gaMock';
var hitSample = {
  hitType: 'pageview',
  page: '/path'
};
var modelSample = modelMock(hitSample);
var expectedDefaultEvent = {
  eventTypeId: 'pageview',
  value: undefined,
  properties: {
    page: hitSample.page
  },
  timestamp: 0
};
tape('validateIdentities', function (assert) {
  assert.deepEqual(validateIdentities(undefined), []);
  assert.deepEqual(validateIdentities(null), []);
  assert.deepEqual(validateIdentities(123), []);
  assert.deepEqual(validateIdentities(true), []);
  assert.deepEqual(validateIdentities('something'), []);
  assert.deepEqual(validateIdentities({}), []);
  assert.deepEqual(validateIdentities(/asd/ig), []);
  assert.deepEqual(validateIdentities(function () {}), []);
  assert.deepEqual(validateIdentities([]), []);
  assert.deepEqual(validateIdentities([undefined, /asd/ig, function () {}]), []);
  assert.deepEqual(validateIdentities([{
    key: 'key',
    trafficType: 'user' // First occurence of this item

  }, {
    key: 'key',
    trafficType: function trafficType() {} // Invalid item (invalid TT)

  }, {
    key: 'keyu',
    trafficType: 'ser' // First occurence of this item

  }, {
    key: true,
    trafficType: 'user' // Invalid item (invalid key)

  }, {
    key: 'key2',
    trafficType: 'user2' // First occurence of this item

  }, {
    key: 12,
    trafficType: 'user' // First occurence of this item

  }, {
    key: 'key',
    trafficType: 'user' // Duplicated item

  }, {} // Invalid item (undefined key and traffic type)
  ]), [{
    key: 'key',
    trafficType: 'user'
  }, {
    key: 'keyu',
    trafficType: 'ser'
  }, {
    key: 'key2',
    trafficType: 'user2'
  }, {
    key: 12,
    trafficType: 'user'
  }]);
  assert.end();
});
tape('validateEventData', function (assert) {
  assert.throws(function () {
    validateEventData(undefined);
  }, 'throws exception if passed object is undefined');
  assert.throws(function () {
    validateEventData(null);
  }, 'throws exception if passed object is null');
  assert.equal(validateEventData({}), false, 'event must have a valid eventTypeId');
  assert.equal(validateEventData({
    eventTypeId: 'type'
  }), true, 'event must have a valid eventTypeId');
  assert.equal(validateEventData({
    eventTypeId: 123
  }), false, 'event must have a valid eventTypeId');
  assert.equal(validateEventData({
    eventTypeId: 'type',
    value: 'value'
  }), false, 'event must have a valid value if present');
  assert.equal(validateEventData({
    eventTypeId: 'type',
    value: 0
  }), true, 'event must have a valid value if present');
  assert.equal(validateEventData({
    eventTypeId: 'type',
    properties: ['prop1']
  }), false, 'event must have valid properties if present');
  assert.equal(validateEventData({
    eventTypeId: 'type',
    properties: {
      prop1: 'prop1'
    }
  }), true, 'event must have valid properties if present');
  assert.equal(validateEventData({
    eventTypeId: 'type',
    timestamp: true
  }), false, 'event must have a valid timestamp if present');
  assert.equal(validateEventData({
    eventTypeId: 'type',
    timestamp: Date.now()
  }), true, 'event must have a valid timestamp if present');
  assert.equal(validateEventData({
    eventTypeId: 'type',
    key: true
  }), false, 'event must have a valid key if present');
  assert.equal(validateEventData({
    eventTypeId: 'type',
    key: 'key'
  }), true, 'event must have a valid key if present');
  assert.equal(validateEventData({
    eventTypeId: 'type',
    trafficTypeName: true
  }), false, 'event must have a valid trafficTypeName if present');
  assert.equal(validateEventData({
    eventTypeId: 'type',
    trafficTypeName: 'tt'
  }), true, 'event must have a valid trafficTypeName if present');
  assert.end();
});
tape('fixEventTypeId', function (assert) {
  assert.equal(fixEventTypeId(undefined), undefined);
  assert.equal(fixEventTypeId(111), 111);
  assert.equal(fixEventTypeId(''), '');
  assert.equal(fixEventTypeId('()'), '');
  assert.equal(fixEventTypeId('()+_'), '');
  assert.equal(fixEventTypeId('  some   event '), 'some_event_');
  assert.equal(fixEventTypeId('  -*- some  -.%^ event =+ '), 'some_-._event_');
  assert.end();
});
tape('defaultMapper', function (assert) {
  var initTimestamp = Date.now();
  var defaultEvent = defaultMapper(modelSample);
  assert.equal(defaultEvent.eventTypeId, expectedDefaultEvent.eventTypeId, 'should return the corresponding default event instance for a given pageview hit');
  assert.equal(defaultEvent.value, expectedDefaultEvent.value);
  assert.deepEqual(defaultEvent.properties, expectedDefaultEvent.properties);
  assert.true(initTimestamp <= defaultEvent.timestamp && defaultEvent.timestamp <= Date.now());
  assert.end();
});
var sdkOptions = {
  type: 'GOOGLE_ANALYTICS_TO_SPLIT'
};
var coreSettings = {
  key: 'key',
  trafficType: 'user'
};
var fakeStorage = {
  events: {
    track: sinon.stub()
  }
}; // Returns a new event by copying defaultEvent

function customMapper(model, defaultEvent) {
  return _objectSpread(_objectSpread({}, defaultEvent), {}, {
    properties: _objectSpread(_objectSpread({}, defaultEvent.properties), {}, {
      someProp: 'someProp'
    })
  });
} // Updates defaultEvent


function customMapper2(model, defaultEvent) {
  defaultEvent.properties.someProp2 = 'someProp2';
  return defaultEvent;
} // Updates defaultEvent adding a `key` and `TT`, to assert that `identities` plugin param is ignored.


function customMapper3(model, defaultEvent) {
  defaultEvent.key = 'someKey';
  defaultEvent.trafficTypeName = 'someTT';
  return defaultEvent;
}

function customFilter() {
  return true;
}

var customIdentities = [{
  key: 'key2',
  trafficType: 'tt2'
}];
tape('GaToSplit', function (assert) {
  // test setup
  var _gaMock = gaMock(),
      ga = _gaMock.ga,
      tracker = _gaMock.tracker; // provide SplitTracker plugin


  GaToSplit(sdkOptions, fakeStorage, coreSettings);
  assert.true(ga.calledWith('provide', 'splitTracker'));
  var SplitTracker = ga.lastCall.args[2];
  assert.true(typeof SplitTracker === 'function');
  /** Default behavior */
  // init plugin on default tracker. equivalent to calling `ga('require', 'splitTracker')`

  new SplitTracker(tracker); // send hit and assert that it was properly tracked as a Split event

  window.ga('send', hitSample);
  var event = fakeStorage.events.track.lastCall.args[0];
  assert.deepEqual(event, _objectSpread(_objectSpread({}, expectedDefaultEvent), {}, {
    eventTypeId: defaultPrefix + '.' + expectedDefaultEvent.eventTypeId,
    key: coreSettings.key,
    trafficTypeName: coreSettings.trafficType,
    timestamp: event.timestamp
  }), 'should track an event using the default mapper and key and traffic type from the SDK config');
  /** Custom behavior: plugin options */
  // init plugin with custom options

  new SplitTracker(tracker, {
    mapper: customMapper,
    filter: customFilter,
    identities: customIdentities,
    prefix: ''
  }); // send hit and assert that it was properly tracked as a Split event

  window.ga('send', hitSample);
  event = fakeStorage.events.track.lastCall.args[0];
  assert.deepEqual(event, _objectSpread(_objectSpread({}, customMapper(modelSample, defaultMapper(modelSample))), {}, {
    key: customIdentities[0].key,
    trafficTypeName: customIdentities[0].trafficType,
    timestamp: event.timestamp
  }), 'should track an event using a custom mapper and identity from the plugin options');
  /** Custom behavior: SDK options */
  // provide a new SplitTracker plugin with custom SDK options

  GaToSplit({
    type: 'GOOGLE_ANALYTICS_TO_SPLIT',
    mapper: customMapper2,
    filter: customFilter,
    identities: customIdentities,
    prefix: ''
  }, fakeStorage, coreSettings);
  assert.true(ga.lastCall.calledWith('provide', 'splitTracker'));
  SplitTracker = ga.lastCall.args[2];
  assert.true(typeof SplitTracker === 'function'); // init plugin

  new SplitTracker(tracker); // send hit and assert that it was properly tracked as a Split event

  window.ga('send', hitSample);
  event = fakeStorage.events.track.lastCall.args[0];
  assert.deepEqual(event, _objectSpread(_objectSpread({}, customMapper2(modelSample, defaultMapper(modelSample))), {}, {
    key: customIdentities[0].key,
    trafficTypeName: customIdentities[0].trafficType,
    timestamp: event.timestamp
  }), 'should track the event using a custom mapper and identity from the SDK options');
  /** Custom behavior: SDK options, including a customMapper that set events key and traffic type */
  // provide a new SplitTracker plugin with custom SDK options

  GaToSplit({
    type: 'GOOGLE_ANALYTICS_TO_SPLIT',
    mapper: customMapper3,
    filter: customFilter,
    identities: customIdentities,
    prefix: ''
  }, fakeStorage, coreSettings);
  assert.true(ga.lastCall.calledWith('provide', 'splitTracker'));
  SplitTracker = ga.lastCall.args[2];
  assert.true(typeof SplitTracker === 'function'); // init plugin

  new SplitTracker(tracker); // send hit and assert that it was properly tracked as a Split event

  window.ga('send', hitSample);
  event = fakeStorage.events.track.lastCall.args[0];
  assert.deepEqual(event, _objectSpread(_objectSpread({}, customMapper3(modelSample, defaultMapper(modelSample))), {}, {
    timestamp: event.timestamp
  }), 'should track the event using a custom mapper and identity from the SDK options'); // test teardown

  gaRemove();
  assert.end();
});
tape('GaToSplit: `hits` flag param', function (assert) {
  // test setup
  var _gaMock2 = gaMock(),
      ga = _gaMock2.ga,
      tracker = _gaMock2.tracker;

  GaToSplit(sdkOptions, fakeStorage, coreSettings);
  var SplitTracker = ga.lastCall.args[2]; // init plugin with custom options

  new SplitTracker(tracker, {
    hits: false
  }); // send hit and assert that it was not tracked as a Split event

  fakeStorage.events.track.resetHistory();
  window.ga('send', hitSample);
  assert.true(fakeStorage.events.track.notCalled); // test teardown

  gaRemove();
  assert.end();
});