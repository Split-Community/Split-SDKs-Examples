import tape from 'tape-catch';
import sinon from 'sinon';
import proxyquire from 'proxyquire';
var proxyquireStrict = proxyquire.noCallThru();
var loggerMock = {
  warn: sinon.stub(),
  error: sinon.stub()
};

function LogFactoryMock() {
  return loggerMock;
}

var _proxyquireStrict = proxyquireStrict('../../inputValidation/key', {
  '../logger': LogFactoryMock
}),
    validateKey = _proxyquireStrict.validateKey;
/* We'll reset the history for the next test */


function resetStubs() {
  loggerMock.warn.resetHistory();
  loggerMock.error.resetHistory();
}

var errorMsgs = {
  EMPTY_KEY: function EMPTY_KEY(keyType) {
    return "you passed an empty string, ".concat(keyType, " must be a non-empty string.");
  },
  LONG_KEY: function LONG_KEY(keyType) {
    return "".concat(keyType, " too long, ").concat(keyType, " must be 250 characters or less.");
  },
  NULL_KEY: function NULL_KEY(keyType) {
    return "you passed a null or undefined ".concat(keyType, ", ").concat(keyType, " must be a non-empty string.");
  },
  WRONG_TYPE_KEY: function WRONG_TYPE_KEY(keyType) {
    return "you passed an invalid ".concat(keyType, " type, ").concat(keyType, " must be a non-empty string.");
  },
  NUMERIC_KEY: function NUMERIC_KEY(keyType, value) {
    return "".concat(keyType, " \"").concat(value, "\" is not of type string, converting.");
  },
  WRONG_KEY_PROPS: 'Key must be an object with bucketingKey and matchingKey with valid string properties.'
};
var invalidKeys = [{
  key: '',
  msg: errorMsgs.EMPTY_KEY
}, {
  key: 'a'.repeat(251),
  msg: errorMsgs.LONG_KEY
}, {
  key: null,
  msg: errorMsgs.NULL_KEY
}, {
  key: undefined,
  msg: errorMsgs.NULL_KEY
}, {
  key: function key() {},
  msg: errorMsgs.WRONG_TYPE_KEY
}, {
  key: new Promise(function (r) {
    return r();
  }),
  msg: errorMsgs.WRONG_TYPE_KEY
}, {
  key: Symbol('asd'),
  msg: errorMsgs.WRONG_TYPE_KEY
}, {
  key: [],
  msg: errorMsgs.WRONG_TYPE_KEY
}, {
  key: true,
  msg: errorMsgs.WRONG_TYPE_KEY
}, {
  key: NaN,
  msg: errorMsgs.WRONG_TYPE_KEY
}, {
  key: Infinity,
  msg: errorMsgs.WRONG_TYPE_KEY
}, {
  key: -Infinity,
  msg: errorMsgs.WRONG_TYPE_KEY
}];
var stringifyableKeys = [{
  key: 200,
  msg: errorMsgs.NUMERIC_KEY
}, {
  key: 1235891238571295,
  msg: errorMsgs.NUMERIC_KEY
}, {
  key: 0,
  msg: errorMsgs.NUMERIC_KEY
}];
var invalidKeyObjects = [{}, {
  matchingKey: 'asd'
}, {
  bucketingKey: 'asd'
}, {
  key: 'asd',
  bucketingKey: 'asdf'
}, {
  random: 'asd'
}];
tape('INPUT VALIDATION for Key', function (t) {
  t.test('String and Object keys / Should return the key with no errors logged if the key is correct', function (assert) {
    var validKey = 'validKey';
    var validObjKey = {
      matchingKey: 'valid',
      bucketingKey: 'alsoValid'
    };
    assert.deepEqual(validateKey(validKey, 'some_method_keys'), validKey, 'It will return the valid key.');
    assert.notOk(loggerMock.error.called, 'No errors should be logged.');
    assert.deepEqual(validateKey(validObjKey, 'some_method_keys'), validObjKey, 'It will return the valid key.');
    assert.notOk(loggerMock.error.called, 'No errors should be logged.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('String key / Should return false and log error if key is invalid', function (assert) {
    for (var i = 0; i < invalidKeys.length; i++) {
      var invalidKey = invalidKeys[i]['key'];
      var expectedLog = invalidKeys[i]['msg']('key');
      assert.equal(validateKey(invalidKey, 'test_method'), false, 'Invalid keys should return false.');
      assert.ok(loggerMock.error.calledWithExactly("test_method: ".concat(expectedLog)), 'The error should be logged for the invalid key.');
      loggerMock.error.resetHistory();
    }

    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('String key / Should return stringified version of the key if it is convertible to one and log a warning.', function (assert) {
    for (var i = 0; i < stringifyableKeys.length; i++) {
      var invalidKey = stringifyableKeys[i]['key'];
      var expectedLog = stringifyableKeys[i]['msg']('key', invalidKey);
      validateKey(invalidKey, 'test_method');
      assert.ok(loggerMock.warn.calledWithExactly("test_method: ".concat(expectedLog)), 'But if the logger allows for warnings, it should be logged.');
      loggerMock.warn.resetHistory();
    }

    assert.notOk(loggerMock.error.called, 'It should have not logged any errors.');
    resetStubs();
    assert.end();
  });
  t.test('Object key / Should return false and log error if a part of the key is invalid', function (assert) {
    // Test invalid object format
    for (var i = 0; i < invalidKeyObjects.length; i++) {
      assert.equal(validateKey(invalidKeyObjects[i], 'test_method'), false, 'Invalid key objects should return false.');
      assert.ok(loggerMock.error.calledWithExactly("test_method: ".concat(errorMsgs.WRONG_KEY_PROPS)), 'The error should be logged for the invalid key.');
      loggerMock.error.resetHistory();
    }

    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs(); // Test invalid matchingKey

    for (var _i = 0; _i < invalidKeys.length; _i++) {
      var _invalidKey = {
        matchingKey: invalidKeys[_i]['key'],
        bucketingKey: 'thisIsValid'
      };

      var expectedLog = invalidKeys[_i]['msg']('matchingKey');

      assert.equal(validateKey(_invalidKey, 'test_method'), false, 'Invalid keys should return false.');
      assert.ok(loggerMock.error.calledWithExactly("test_method: ".concat(expectedLog)), 'The error should be logged for the invalid key.');
      loggerMock.error.resetHistory();
    }

    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs(); // Test invalid bucketingKey

    for (var _i2 = 0; _i2 < invalidKeys.length; _i2++) {
      var _invalidKey2 = {
        matchingKey: 'thisIsValidToo',
        bucketingKey: invalidKeys[_i2]['key']
      };

      var _expectedLog = invalidKeys[_i2]['msg']('bucketingKey');

      assert.equal(validateKey(_invalidKey2, 'test_method'), false, 'Invalid keys should return false.');
      assert.ok(loggerMock.error.calledWithExactly("test_method: ".concat(_expectedLog)), 'The error should be logged for the invalid key.');
      loggerMock.error.resetHistory();
    }

    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs(); // Just one test that if both are invalid we get the log for both.

    var invalidKey = {
      matchingKey: invalidKeys[0]['key'],
      bucketingKey: invalidKeys[1]['key']
    };
    var expectedLogMK = invalidKeys[0]['msg']('matchingKey');
    var expectedLogBK = invalidKeys[1]['msg']('bucketingKey');
    assert.equal(validateKey(invalidKey, 'test_method'), false, 'Invalid keys should return false.');
    assert.ok(loggerMock.error.calledWithExactly("test_method: ".concat(expectedLogMK)), 'The error should be logged for the invalid key property.');
    assert.ok(loggerMock.error.calledWithMatch("test_method: ".concat(expectedLogBK)), 'The error should be logged for the invalid key property.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('Object key / Should return stringified version of the key props if those are convertible and log the corresponding warnings', function (assert) {
    var invalidKey = {
      matchingKey: stringifyableKeys[0]['key'],
      bucketingKey: stringifyableKeys[1]['key']
    };
    var expectedKey = {
      matchingKey: String(invalidKey.matchingKey),
      bucketingKey: String(invalidKey.bucketingKey)
    };
    var expectedLogMK = stringifyableKeys[0]['msg']('matchingKey', invalidKey.matchingKey);
    var expectedLogBK = stringifyableKeys[1]['msg']('bucketingKey', invalidKey.bucketingKey);
    assert.deepEqual(validateKey(invalidKey, 'test_method'), expectedKey, 'If a key object had stringifyable values, those will be stringified and Key returned.');
    assert.ok(loggerMock.warn.calledWithExactly("test_method: ".concat(expectedLogMK)), 'The warning should be logged for the stringified prop if warnings are enabled.');
    assert.ok(loggerMock.warn.calledWithExactly("test_method: ".concat(expectedLogBK)), 'The warning should be logged for the stringified prop if warnings are enabled.');
    assert.notOk(loggerMock.error.called, 'It should have not logged any errors.');
    resetStubs();
    assert.end();
  });
});