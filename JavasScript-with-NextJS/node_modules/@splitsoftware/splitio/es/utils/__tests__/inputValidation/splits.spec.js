import proxyquire from 'proxyquire';
import tape from 'tape-catch';
import sinon from 'sinon';
import uniq from 'lodash/uniq';
import startsWith from 'lodash/startsWith';
var proxyquireStrict = proxyquire.noCallThru();
var loggerMock = {
  warn: sinon.stub(),
  error: sinon.stub()
};

function LogFactoryMock() {
  return loggerMock;
}

var validateSplitValue = sinon.stub().returnsArg(0);

var _proxyquireStrict = proxyquireStrict('../../inputValidation/splits', {
  '../logger': LogFactoryMock,
  './split': {
    validateSplit: validateSplitValue
  }
}),
    validateSplits = _proxyquireStrict.validateSplits;
/* We'll reset the history for the next test */


function resetStubs() {
  loggerMock.warn.resetHistory();
  loggerMock.error.resetHistory();
  validateSplitValue.resetHistory();
}

var invalidSplits = [[], {}, Object.create({}), function () {}, false, true, 5, 'something', NaN, -Infinity, new Promise(function (res) {
  return res;
}), Symbol('asd'), null, undefined, NaN];
tape('INPUT VALIDATION for Split names', function (t) {
  t.test('Should return the provided array if it is a valid splits names array without logging any errors', function (assert) {
    var validArr = ['splitName1', 'split_name_2', 'split-name-3'];
    assert.deepEqual(validateSplits(validArr, 'some_method_splits'), validArr, 'It should return the provided array without changes if it is valid.');
    assert.equal(validateSplitValue.callCount, validArr.length, 'Should have validated each value independently.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors on the collection.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('Should return the provided array if it is a valid splits names array removing duplications, without logging any errors', function (assert) {
    var validArr = ['split_name', 'split_name', 'split-name'];
    assert.deepEqual(validateSplits(validArr, 'some_method_splits'), uniq(validArr), 'It should return the provided array without changes if it is valid.');
    assert.equal(validateSplitValue.callCount, validArr.length, 'Should have validated each value independently.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors on the collection.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('Should return false and log an error for the array if it is invalid', function (assert) {
    for (var i = 0; i < invalidSplits.length; i++) {
      assert.false(validateSplits(invalidSplits[i], 'test_method'), 'It will return false as the array is of an incorrect type.');
      assert.ok(loggerMock.error.calledOnceWithExactly('test_method: split_names must be a non-empty array.'), 'Should log the error for the collection.');
      assert.false(validateSplitValue.called, 'Should not try to validate any inner value if there is no valid array.');
      loggerMock.error.resetHistory();
    }

    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('Should strip out any invalid value from the array', function (assert) {
    validateSplitValue.resetBehavior(); // We use a mock function for individual validation.

    validateSplitValue.callsFake(function (value) {
      return startsWith(value, 'invalid') ? false : value;
    });
    var myArr = ['valid_name', 'invalid_name', 'invalid_val_2', 'something_valid'];
    assert.deepEqual(validateSplits(myArr, 'test_method'), ['valid_name', 'something_valid'], 'It will return the array without the invalid values.');

    for (var i = 0; i < myArr.length; i++) {
      assert.true(validateSplitValue.calledWithExactly(myArr[i], 'test_method', 'split name'), 'Should validate any inner value independently.');
    }

    assert.false(loggerMock.error.called, 'Should not log any error for the collection.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings for the collection.');
    resetStubs();
    assert.end();
  });
});