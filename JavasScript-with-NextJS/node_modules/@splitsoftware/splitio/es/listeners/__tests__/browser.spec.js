import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import tape from 'tape-catch';
import sinon from 'sinon';
import BrowserSignalListener from '../browser';
import { DEBUG } from '../../utils/constants';
import ImpressionsCounter from '../../impressions/counter';
var UNLOAD_DOM_EVENT = 'unload';
var windowAddEventListenerSpy = sinon.spy(window, 'addEventListener');
var windowRemoveEventListenerSpy = sinon.spy(window, 'removeEventListener');
var sendBeaconSpy = sinon.spy(window.navigator, 'sendBeacon');
/* Mocks start */

var generateContextMocks = function generateContextMocks() {
  // We are only mocking the pieces we care about
  var fakeImpression = {
    feature: 'splitName',
    keyName: 'facundo@split.io',
    treatment: 'off',
    time: Date.now(),
    bucketingKey: null,
    label: null,
    changeNumber: null
  };
  var fakeEvent = {
    eventTypeId: 'someEvent',
    trafficTypeName: 'sometraffictype',
    value: null,
    timestamp: null,
    key: 'facundo@split.io',
    properties: null
  };
  var fakeSettings = {
    url: sinon.stub(),
    core: {
      labelsEnabled: true
    }
  };
  var fakeStorage = {
    impressions: {
      isEmpty: sinon.stub(),
      clear: sinon.stub(),
      queue: [fakeImpression],
      state: function state() {
        return this.queue;
      }
    },
    events: {
      isEmpty: sinon.stub(),
      clear: sinon.stub(),
      queue: [fakeEvent],
      toJSON: function toJSON() {
        return this.queue;
      }
    }
  };
  return {
    fakeSettings: fakeSettings,
    fakeStorage: fakeStorage
  };
};

var ContextMock = /*#__PURE__*/function () {
  function ContextMock(fakeStorage, fakeSettings, shouldCreateImpressionsCounter) {
    _classCallCheck(this, ContextMock);

    this.constants = {
      STORAGE: 'storage',
      SETTINGS: 'settings',
      IMPRESSIONS_COUNTER: 'impressions_counter'
    };
    this.fakeStorage = fakeStorage;
    this.fakeSettings = fakeSettings;
    this.impressionsCounter = shouldCreateImpressionsCounter ? new ImpressionsCounter() : undefined;
  }

  _createClass(ContextMock, [{
    key: "get",
    value: function get(target) {
      switch (target) {
        case 'storage':
          return this.fakeStorage;

        case 'settings':
          return this.fakeSettings;

        case 'impressions_counter':
          return this.impressionsCounter;

        default:
          break;
      }
    }
  }]);

  return ContextMock;
}();
/* Mocks end */


function triggerUnloadEvent() {
  var event = document.createEvent('HTMLEvents');
  event.initEvent('unload', true, true);
  event.eventName = 'unload';
  window.dispatchEvent(event);
}

tape('Browser JS / Browser listener class constructor, start and stop methods', function (assert) {
  var _generateContextMocks = generateContextMocks(),
      fakeStorage = _generateContextMocks.fakeStorage,
      fakeSettings = _generateContextMocks.fakeSettings;

  var contextMock = new ContextMock(fakeStorage, fakeSettings, true);
  var listener = new BrowserSignalListener(contextMock);
  listener.start(); // Assigned right function to right signal.

  assert.ok(windowAddEventListenerSpy.calledOnce);
  assert.ok(windowAddEventListenerSpy.calledOnceWithExactly(UNLOAD_DOM_EVENT, listener.flushData));
  triggerUnloadEvent();
  setTimeout(function () {
    // Unload event was triggered. Thus sendBeacon method should have been called three times.
    assert.equal(sendBeaconSpy.callCount, 3); // pre-check and call stop

    assert.ok(windowRemoveEventListenerSpy.notCalled);
    listener.stop(); // removed correct listener from correct signal on stop.

    assert.ok(windowRemoveEventListenerSpy.calledOnce);
    assert.ok(windowRemoveEventListenerSpy.calledOnceWithExactly(UNLOAD_DOM_EVENT, listener.flushData));
    assert.end();
  }, 0);
});
tape('Browser JS Debug Mode / Browser listener class constructor, start and stop methods', function (assert) {
  var _generateContextMocks2 = generateContextMocks(),
      fakeStorage = _generateContextMocks2.fakeStorage,
      fakeSettings = _generateContextMocks2.fakeSettings;

  fakeSettings.sync = {
    impressionsMode: DEBUG
  };
  var contextMock = new ContextMock(fakeStorage, fakeSettings, false);
  var listener = new BrowserSignalListener(contextMock);
  listener.start(); // Assigned right function to right signal.

  assert.ok(windowAddEventListenerSpy.calledOnce);
  assert.ok(windowAddEventListenerSpy.calledOnceWithExactly(UNLOAD_DOM_EVENT, listener.flushData));
  triggerUnloadEvent();
  setTimeout(function () {
    // Unload event was triggered. Thus sendBeacon method should have been called twice.
    assert.equal(sendBeaconSpy.callCount, 2); // pre-check and call stop

    assert.ok(windowRemoveEventListenerSpy.notCalled);
    listener.stop(); // removed correct listener from correct signal on stop.

    assert.ok(windowRemoveEventListenerSpy.calledOnce);
    assert.ok(windowRemoveEventListenerSpy.calledOnceWithExactly(UNLOAD_DOM_EVENT, listener.flushData));
    assert.end();
  }, 0);
});