import tape from 'tape';
import fetchMock from '../../../__tests__/testUtils/fetchMock';
import authenticate from '../../AuthClient';
import SettingsFactory from '../../../utils/settings/index';
import { authDataResponseSample, authDataSample, jwtSampleInvalid, jwtSampleNoChannels, jwtSampleNoIat } from '../mocks/dataMocks';
var settings = SettingsFactory({
  core: {
    authorizationKey: 'SDK_KEY'
  }
});
tape('authenticate', function (t) {
  t.test('success in node (200)', function (assert) {
    fetchMock.getOnce(settings.url('/auth'), function (url, opts) {
      assert.equal(opts.headers['Authorization'], "Bearer ".concat(settings.core.authorizationKey), 'auth request must contain Authorization header with config authorizationKey');
      return {
        status: 200,
        body: authDataResponseSample
      };
    });
    authenticate(settings).then(function (data) {
      assert.deepEqual(data, authDataSample, 'if success, authorization must return data with token and decoded token');
      assert.end();
    }).catch(function (error) {
      assert.fail(error);
    });
  });
  t.test('success in browser (200)', function (assert) {
    var userKeys = ['emi@split.io', 'maldo@split.io'];
    fetchMock.getOnce(settings.url('/auth?users=emi%40split.io&users=maldo%40split.io'), function (url, opts) {
      assert.equal(opts.headers['Authorization'], "Bearer ".concat(settings.core.authorizationKey), 'auth request must contain Authorization header with config authorizationKey');
      return {
        status: 200,
        body: authDataResponseSample
      };
    });
    authenticate(settings, userKeys).then(function (data) {
      assert.deepEqual(data, authDataSample, 'if success, authorization must return data with token and decoded token');
      assert.end();
    }).catch(function (error) {
      assert.fail(error);
    });
  });
  t.test('bad request in browser due to no user keys (400)', function (assert) {
    fetchMock.getOnce(settings.url('/auth'), {
      status: 400,
      body: '"no user specified"'
    });
    authenticate(settings, []).then(function () {
      assert.fail('if bad request, promise is rejected');
    }).catch(function (error) {
      assert.equal(error.statusCode, 400, 'if bad request, status code is 400');
      assert.end();
    });
  });
  t.test('Invalid credentials (401)', function (assert) {
    fetchMock.getOnce(settings.url('/auth'), {
      status: 401,
      body: '"Invalid credentials"'
    });
    authenticate(settings, []).then(function () {
      assert.fail('if invalid credential, promise is rejected');
    }).catch(function (error) {
      assert.equal(error.statusCode, 401, 'if invalid credential, status code is 401');
      assert.end();
    });
  });
  t.test('HTTP error (other than 401)', function (assert) {
    var NOT_OK_STATUS_CODE = 500;
    fetchMock.getOnce(settings.url('/auth'), {
      status: NOT_OK_STATUS_CODE,
      body: 'some error message'
    });
    authenticate(settings, []).then(function () {
      assert.fail('if an HTTP error, promise is rejected');
    }).catch(function (error) {
      assert.equal(error.statusCode, NOT_OK_STATUS_CODE, 'if an HTTP error, status code is the HTTP status code');
      assert.end();
    });
  });
  t.test('Network error (e.g., timeout)', function (assert) {
    fetchMock.getOnce(settings.url('/auth'), {
      throws: new TypeError('Network error')
    });
    authenticate(settings, []).then(function () {
      assert.fail('if network error, promise is rejected');
    }).catch(function (error) {
      assert.equal(error.statusCode, undefined, 'if network error, status code is `undefined`');
      assert.end();
    });
  });
  t.test('Error parsing token', function (assert) {
    fetchMock.getOnce(settings.url('/auth'), {
      status: 200,
      body: {
        pushEnabled: true,
        token: jwtSampleInvalid
      }
    });
    fetchMock.getOnce(settings.url('/auth'), {
      status: 200,
      body: {
        pushEnabled: true,
        token: jwtSampleNoChannels
      }
    });
    fetchMock.getOnce(settings.url('/auth'), {
      status: 200,
      body: {
        pushEnabled: true,
        token: jwtSampleNoIat
      }
    });
    authenticate(settings).then(function () {
      assert.fail('if invalid token, promise is rejected');
    }).catch(function (error) {
      assert.pass(error);
      authenticate(settings).then(function () {
        assert.fail('if invalid token, promise is rejected');
      }).catch(function (error) {
        assert.pass(error);
        authenticate(settings).then(function () {
          assert.fail('if invalid token, promise is rejected');
        }).catch(function (error) {
          assert.pass(error);
          assert.end();
        });
      });
    });
  });
});