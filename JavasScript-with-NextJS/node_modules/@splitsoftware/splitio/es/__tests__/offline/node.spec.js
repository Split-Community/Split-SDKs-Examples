import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* eslint-disable no-console */
import path from 'path';
import tape from 'tape-catch';
import sinon from 'sinon';
import fetchMock from '../testUtils/fetchMock';
import { SplitFactory } from '../../';
import SettingsFactory from '../../utils/settings';
var settings = SettingsFactory({
  core: {
    key: 'facundo@split.io'
  }
});
var spySplitChanges = sinon.spy();
var spySegmentChanges = sinon.spy();
var spyMySegments = sinon.spy();
var spyEventsBulk = sinon.spy();
var spyTestImpressionsBulk = sinon.spy();
var spyTestImpressionsCount = sinon.spy();
var spyMetricsTimes = sinon.spy();
var spyMetricsCounters = sinon.spy();
var spyAny = sinon.spy(); // helper function that should call the spy function and return a 200 to keep
// going the fetch request flow

var replySpy = function replySpy(spy) {
  spy();
  return 200;
};

var configMocks = function configMocks() {
  fetchMock.mock(new RegExp("".concat(settings.url('/splitChanges/'), ".*")), function () {
    return replySpy(spySplitChanges);
  });
  fetchMock.mock(new RegExp("".concat(settings.url('/segmentChanges/'), ".*")), function () {
    return replySpy(spySegmentChanges);
  });
  fetchMock.mock(new RegExp("".concat(settings.url('/mySegments/'), ".*")), function () {
    return replySpy(spyMySegments);
  });
  fetchMock.mock(settings.url('/events/bulk'), function () {
    return replySpy(spyEventsBulk);
  });
  fetchMock.mock(settings.url('/testImpressions/bulk'), function () {
    return replySpy(spyTestImpressionsBulk);
  });
  fetchMock.mock(settings.url('/testImpressions/count'), function () {
    return replySpy(spyTestImpressionsCount);
  });
  fetchMock.mock(settings.url('/metrics/times'), function () {
    return replySpy(spyMetricsTimes);
  });
  fetchMock.mock(settings.url('/metrics/counters'), function () {
    return replySpy(spyMetricsCounters);
  });
  fetchMock.mock('*', function () {
    return replySpy(spyAny);
  });
};

var settingsGenerator = function settingsGenerator(mockFileName) {
  return {
    core: {
      authorizationKey: 'localhost'
    },
    scheduler: {
      impressionsRefreshRate: 0.01,
      eventsPushRate: 0.01,
      metricsRefreshRate: 0.01,
      offlineRefreshRate: 0.3
    },
    startup: {
      eventsFirstPushWindow: 0,
      readyTimeout: 3,
      retriesOnFailureBeforeReady: 0
    },
    features: path.join(__dirname, mockFileName)
  };
};

tape('NodeJS Offline Mode', function (t) {
  t.test('Old format evaluations - .split', DotSplitTests);
  t.test('New format evaluations - .yaml extension', DotYAMLTests.bind(null, 'split', 'yaml'));
  t.test('New format evaluations - .yml extension', DotYAMLTests.bind(null, 'split2', 'yml'));
  t.test('Old format manager - .split extension', ManagerDotSplitTests);
  t.test('New format manager - .yaml extension', ManagerDotYamlTests.bind(null, 'split.yaml'));
  t.test('New format manager - .yml extension', ManagerDotYamlTests.bind(null, 'split2.yml'));
  t.test('Trying to specify an invalid extension it will timeout', function (assert) {
    var config = settingsGenerator('.forbidden');
    sinon.spy(console, 'log');
    var factory = SplitFactory(_objectSpread(_objectSpread({}, config), {}, {
      debug: 'ERROR'
    })); // enable error level logs to check the message.

    var client = factory.client();
    client.on(client.Event.SDK_READY, function () {
      assert.fail('If tried to load a file with invalid extension, we should not get SDK_READY.');
      client.destroy();
      assert.end();
    });
    client.on(client.Event.SDK_READY_TIMED_OUT, function () {
      assert.pass('If tried to load a file with invalid extension, we should emit SDK_READY_TIMED_OUT.');
      assert.ok(console.log.calledWithMatch("[ERROR] splitio-producer:offline => There was an issue loading the mock Splits data, no changes will be applied to the current cache. Invalid extension specified for Splits mock file. Accepted extensions are \".yml\" and \".yaml\". Your specified file is ".concat(config.features)));
      console.log.restore();
      client.destroy();
      assert.end();
    });
  });
});

function networkAssertions(client, assert) {
  return client.destroy().then(function () {
    // We test the breakdown instead of just the misc because it's faster to spot where the issue is
    assert.notOk(spySplitChanges.called, 'On offline mode we should not call the splitChanges endpoint.');
    assert.notOk(spySegmentChanges.called, 'On offline mode we should not call the segmentChanges endpoint.');
    assert.notOk(spyMySegments.called, 'On offline mode we should not call the mySegments endpoint.');
    assert.notOk(spyEventsBulk.called, 'On offline mode we should not call the events endpoint.');
    assert.notOk(spyTestImpressionsBulk.called, 'On offline mode we should not call the impressions endpoint.');
    assert.notOk(spyTestImpressionsCount.called, 'On offline mode we should not call the impressions count endpoint.');
    assert.notOk(spyMetricsTimes.called, 'On offline mode we should not call the metric times endpoint.');
    assert.notOk(spyMetricsCounters.called, 'On offline mode we should not call the metric counters endpoint.');
    assert.notOk(spyAny.called, 'On offline mode we should NOT call to ANY endpoint, we are completely isolated from BE.');
  });
}

function DotSplitTests(assert) {
  configMocks();
  var config = settingsGenerator('.split');
  var factory = SplitFactory(config);
  var client = factory.client(); // Tracking some events to test they are not flushed.

  client.track('a_key', 'a_tt', 'an_ev_id');
  client.track('another_key', 'another_tt', 'another_ev_id', 25);
  client.on(client.Event.SDK_READY, function () {
    assert.equal(client.getTreatment('qa-user', 'testing_split'), 'on');
    assert.equal(client.getTreatment('qa-user', 'testing_split_2'), 'control');
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split'), {
      treatment: 'on',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_2'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatments('qa-user', ['testing_split', 'testing_split2', 'testing_split3', 'testing_not_exist']), {
      testing_split: 'on',
      testing_split2: 'off',
      testing_split3: 'custom_treatment',
      testing_not_exist: 'control'
    });
    assert.deepEqual(client.getTreatmentsWithConfig('qa-user', ['testing_split', 'testing_split2', 'testing_split3', 'testing_not_exist']), {
      testing_split: {
        treatment: 'on',
        config: null
      },
      testing_split2: {
        treatment: 'off',
        config: null
      },
      testing_split3: {
        treatment: 'custom_treatment',
        config: null
      },
      testing_not_exist: {
        treatment: 'control',
        config: null
      }
    });
    setTimeout(function () {
      factory.settings.features = path.join(__dirname, '.split');
    }, 290);
    setTimeout(function () {
      factory.settings.features = path.join(__dirname, '.split');
    }, 590);
    setTimeout(function () {
      factory.settings.features = path.join(__dirname, '.split');
    }, 890);
    setTimeout(function () {
      factory.settings.features = path.join(__dirname, 'update.split');
    }, 1000);
    client.once(client.Event.SDK_UPDATE, function () {
      assert.equal(client.getTreatment('qa-user', 'testing_split4'), 'updated_treatment');
      networkAssertions(client, assert).then(function () {
        client.destroy().then(assert.end);
      });
    });
  });
}

function DotYAMLTests(mockFileName, mockFileExt, assert) {
  configMocks();
  var config = settingsGenerator("".concat(mockFileName, ".").concat(mockFileExt));
  var factory = SplitFactory(config);
  var client = factory.client(); // Tracking some events to test they are not flushed.

  assert.true(client.track('a_key', 'a_tt', 'an_ev_id'));
  assert.true(client.track('another_key', 'another_tt', 'another_ev_id', 25));
  assert.false(client.track('wasa', {}, [], 'invalid_stuff'));
  client.on(client.Event.SDK_READY, function () {
    assert.equal(client.getTreatment('qa-user', 'testing_split_on'), 'on');
    assert.equal(client.getTreatment('qa-user', 'testing_split_only_wl'), 'control');
    assert.equal(client.getTreatment('key_for_wl', 'testing_split_only_wl'), 'whitelisted');
    assert.equal(client.getTreatment('qa-user', 'testing_split_with_wl'), 'not_in_whitelist');
    assert.equal(client.getTreatment('key_for_wl', 'testing_split_with_wl'), 'one_key_wl');
    assert.equal(client.getTreatment('key_for_wl_1', 'testing_split_with_wl'), 'multi_key_wl');
    assert.equal(client.getTreatment('key_for_wl_2', 'testing_split_with_wl'), 'multi_key_wl');
    assert.equal(client.getTreatment('qa-user', 'testing_split_off_with_config'), 'off');
    assert.equal(client.getTreatment('qa-user', 'not_existent'), 'control');
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_on'), {
      treatment: 'on',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_only_wl'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl', 'testing_split_only_wl'), {
      treatment: 'whitelisted',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_with_wl'), {
      treatment: 'not_in_whitelist',
      config: '{"color": "green"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl', 'testing_split_with_wl'), {
      treatment: 'one_key_wl',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl_1', 'testing_split_with_wl'), {
      treatment: 'multi_key_wl',
      config: '{"color": "brown"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl_2', 'testing_split_with_wl'), {
      treatment: 'multi_key_wl',
      config: '{"color": "brown"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_off_with_config'), {
      treatment: 'off',
      config: '{"color": "green"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'not_existent'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatments('qa-user', ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config', 'testing_not_exist']), {
      testing_split_on: 'on',
      testing_split_only_wl: 'control',
      testing_split_with_wl: 'not_in_whitelist',
      testing_split_off_with_config: 'off',
      testing_not_exist: 'control'
    });
    assert.deepEqual(client.getTreatmentsWithConfig('key_for_wl', ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config', 'testing_not_exist']), {
      testing_split_on: {
        treatment: 'on',
        config: null
      },
      testing_split_only_wl: {
        treatment: 'whitelisted',
        config: null
      },
      testing_split_with_wl: {
        treatment: 'one_key_wl',
        config: null
      },
      testing_split_off_with_config: {
        treatment: 'off',
        config: '{"color": "green"}'
      },
      testing_not_exist: {
        treatment: 'control',
        config: null
      }
    });
    var readyTimestamp = Date.now();
    setTimeout(function () {
      factory.settings.features = path.join(__dirname, "".concat(mockFileName, ".").concat(mockFileExt));
    }, 290);
    setTimeout(function () {
      factory.settings.features = path.join(__dirname, "".concat(mockFileName, ".").concat(mockFileExt));
    }, 590);
    setTimeout(function () {
      factory.settings.features = path.join(__dirname, "".concat(mockFileName, ".").concat(mockFileExt));
    }, 890);
    setTimeout(function () {
      factory.settings.features = path.join(__dirname, "update.".concat(mockFileName, ".").concat(mockFileExt));
    }, 1000);
    client.once(client.Event.SDK_UPDATE, function () {
      assert.equal(client.getTreatment('qa-user', 'testing_split_update'), 'updated_treatment', 'the update should be properly processed');
      assert.true(Date.now() - readyTimestamp > 1000);
      networkAssertions(client, assert).then(function () {
        client.destroy().then(assert.end);
      });
    });
  });
}

function ManagerDotSplitTests(assert) {
  configMocks();
  var config = settingsGenerator('.split');
  var factory = SplitFactory(config);
  var client = factory.client();
  var manager = factory.manager();
  manager.on(manager.Event.SDK_READY, function () {
    assert.deepEqual(manager.names(), ['testing_split', 'testing_split2', 'testing_split3']);
    var expectedView1 = {
      name: 'testing_split',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['on'],
      configs: {}
    };
    var expectedView2 = {
      name: 'testing_split2',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['off'],
      configs: {}
    };
    var expectedView3 = {
      name: 'testing_split3',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['custom_treatment'],
      configs: {}
    };
    assert.deepEqual(manager.split('testing_split'), expectedView1);
    assert.deepEqual(manager.split('testing_split2'), expectedView2);
    assert.deepEqual(manager.split('testing_split3'), expectedView3);
    assert.equal(manager.split('split_not_existent'), null);
    assert.deepEqual(manager.splits(), [expectedView1, expectedView2, expectedView3]);
    networkAssertions(client, assert).then(function () {
      client.destroy().then(assert.end);
    });
  });
}

function ManagerDotYamlTests(mockFileName, assert) {
  configMocks();
  var config = settingsGenerator(mockFileName);
  var factory = SplitFactory(config);
  var client = factory.client();
  var manager = factory.manager();
  manager.on(manager.Event.SDK_READY, function () {
    assert.deepEqual(manager.names(), ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config']);
    var expectedView1 = {
      name: 'testing_split_on',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['on'],
      configs: {}
    };
    var expectedView2 = {
      name: 'testing_split_only_wl',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['whitelisted'],
      configs: {}
    };
    var expectedView3 = {
      name: 'testing_split_with_wl',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['not_in_whitelist', 'one_key_wl', 'multi_key_wl'],
      configs: {
        not_in_whitelist: '{"color": "green"}',
        multi_key_wl: '{"color": "brown"}'
      }
    };
    var expectedView4 = {
      name: 'testing_split_off_with_config',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['off'],
      configs: {
        off: '{"color": "green"}'
      }
    };
    assert.deepEqual(manager.split('testing_split_on'), expectedView1);
    assert.deepEqual(manager.split('testing_split_only_wl'), expectedView2);
    assert.deepEqual(manager.split('testing_split_with_wl'), expectedView3);
    assert.deepEqual(manager.split('testing_split_off_with_config'), expectedView4);
    assert.equal(manager.split('not_existent'), null);
    assert.deepEqual(manager.splits(), [expectedView1, expectedView2, expectedView3, expectedView4]);
    networkAssertions(client, assert).then(function () {
      client.destroy().then(assert.end);
    });
  });
}