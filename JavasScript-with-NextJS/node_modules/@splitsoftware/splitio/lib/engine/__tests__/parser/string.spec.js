"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _parser = _interopRequireDefault(require("../../parser"));

var _parser2 = _interopRequireDefault(require("../../../utils/key/parser"));

/**
Copyright 2016 Split Software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
//
// STARTS WITH
//
(0, _tapeCatch.default)('PARSER / if user.email starts with ["nico"] then split 100:on', /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            label = 'email starts with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nicolas.zelaya@split.io'
            });

          case 4:
            evaluation = _context.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email = 123, starts with ["1"] then split 100:on should match', /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            label = 'email starts with ["1"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['1']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context2.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 123
            });

          case 4:
            evaluation = _context2.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email starts with ["nico", "marcio", "facu"] then split 100:on', /*#__PURE__*/function () {
  var _ref3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            label = 'email starts with ["nico", "marcio", "facu"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico', 'marcio', 'facu']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context3.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'facundo@split.io'
            });

          case 4:
            evaluation = _context3.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email starts with ["nico", "marcio", "facu"] then split 100:on', /*#__PURE__*/function () {
  var _ref4 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            label = 'email starts with ["nico", "marcio", "facu"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico', 'marcio', 'facu']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context4.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'marciomisi@split.io'
            });

          case 4:
            evaluation = _context4.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x4) {
    return _ref4.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email does not start with ["nico"] then not match', /*#__PURE__*/function () {
  var _ref5 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(assert) {
    var evaluator, evaluation;
    return _regenerator.default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            // const label = 'email starts with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context5.next = 3;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'facundo@split.io'
            });

          case 3:
            evaluation = _context5.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 7:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function (_x5) {
    return _ref5.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email is an EMPTY string, start with ["nico"] should not match', /*#__PURE__*/function () {
  var _ref6 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(assert) {
    var evaluator, evaluation;
    return _regenerator.default.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            // const label = 'email starts with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context6.next = 3;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: ''
            });

          case 3:
            evaluation = _context6.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 6:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function (_x6) {
    return _ref6.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email is not a string, start with ["nico"] should not match', /*#__PURE__*/function () {
  var _ref7 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(assert) {
    var evaluator, evaluation;
    return _regenerator.default.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            // const label = 'email starts with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context7.next = 3;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: {}
            });

          case 3:
            evaluation = _context7.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            _context7.next = 7;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31);

          case 7:
            evaluation = _context7.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 10:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function (_x7) {
    return _ref7.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email starts with ["nico"] then split 100:on, so not match', /*#__PURE__*/function () {
  var _ref8 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            label = 'not email starts with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context8.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nicolas.zelaya@split.io'
            });

          case 4:
            evaluation = _context8.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 8:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));

  return function (_x8) {
    return _ref8.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email does not start with ["nico"] should not match, then match', /*#__PURE__*/function () {
  var _ref9 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            label = 'not email starts with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context9.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'facundo@split.io'
            });

          case 4:
            evaluation = _context9.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));

  return function (_x9) {
    return _ref9.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email is an EMPTY string, start with ["nico"] should not match, so negation should', /*#__PURE__*/function () {
  var _ref10 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            label = 'not email starts with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context10.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: ''
            });

          case 4:
            evaluation = _context10.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));

  return function (_x10) {
    return _ref10.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email is not a string, start with ["nico"] should not match, so negation should', /*#__PURE__*/function () {
  var _ref11 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            label = 'not email starts with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'STARTS_WITH',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context11.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: /asd4?/
            });

          case 4:
            evaluation = _context11.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            _context11.next = 9;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31);

          case 9:
            evaluation = _context11.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 13:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));

  return function (_x11) {
    return _ref11.apply(this, arguments);
  };
}()); //
// ENDS WITH
//

(0, _tapeCatch.default)('PARSER / if user.email ends with ["split.io"] then split 100:on', /*#__PURE__*/function () {
  var _ref12 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            label = 'email ends with ["split.io"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['split.io']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context12.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nicolas.zelaya@split.io'
            });

          case 4:
            evaluation = _context12.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, "evaluator should return label ''");
            assert.end();

          case 9:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));

  return function (_x12) {
    return _ref12.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email = 123, ends with ["3"] then split 100:on should match', /*#__PURE__*/function () {
  var _ref13 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            label = 'email starts with ["3"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['3']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context13.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 123
            });

          case 4:
            evaluation = _context13.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee13);
  }));

  return function (_x13) {
    return _ref13.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email ends with ["gmail.com", "split.io", "hotmail.com"] then split 100:on', /*#__PURE__*/function () {
  var _ref14 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            label = 'email ends with ["gmail.com", "split.io", "hotmail.com"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['gmail.com', 'split.io', 'hotmail.com']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context14.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nicolas.zelaya@split.io'
            });

          case 4:
            evaluation = _context14.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, "evaluator should return label ''");
            assert.end();

          case 9:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14);
  }));

  return function (_x14) {
    return _ref14.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email ends with ["gmail.com", "split.io", "hotmail.com"] then split 100:on', /*#__PURE__*/function () {
  var _ref15 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            label = 'email ends with ["gmail.com", "split.io", "hotmail.com"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['gmail.com', 'split.io', 'hotmail.com']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context15.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nicolas.zelaya@hotmail.com'
            });

          case 4:
            evaluation = _context15.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, "evaluator should return label ''");
            assert.end();

          case 9:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15);
  }));

  return function (_x15) {
    return _ref15.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email ends with ["gmail.com", "split.io", "hotmail.com"] but attribute is "" then split 100:on', /*#__PURE__*/function () {
  var _ref16 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            label = 'email ends with ["gmail.com", "split.io", "hotmail.com"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['gmail.com', 'split.io', 'hotmail.com']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context16.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: ''
            });

          case 4:
            evaluation = _context16.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 8:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16);
  }));

  return function (_x16) {
    return _ref16.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email does not end with ["split.io"] then not match', /*#__PURE__*/function () {
  var _ref17 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            label = 'email ends with ["split.io"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['split.io']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context17.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'facundo@gmail.io'
            });

          case 4:
            evaluation = _context17.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 8:
          case "end":
            return _context17.stop();
        }
      }
    }, _callee17);
  }));

  return function (_x17) {
    return _ref17.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email is an EMPTY string, end with ["nico"] should not match', /*#__PURE__*/function () {
  var _ref18 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18(assert) {
    var evaluator, evaluation;
    return _regenerator.default.wrap(function _callee18$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            // const label = 'email ends with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context18.next = 3;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: ''
            });

          case 3:
            evaluation = _context18.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 6:
          case "end":
            return _context18.stop();
        }
      }
    }, _callee18);
  }));

  return function (_x18) {
    return _ref18.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email is not a string, end with ["nico"] should not match', /*#__PURE__*/function () {
  var _ref19 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee19(assert) {
    var evaluator, evaluation;
    return _regenerator.default.wrap(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            // const label = 'email ends with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context19.next = 3;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: []
            });

          case 3:
            evaluation = _context19.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            _context19.next = 7;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nicole'
            });

          case 7:
            evaluation = _context19.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 10:
          case "end":
            return _context19.stop();
        }
      }
    }, _callee19);
  }));

  return function (_x19) {
    return _ref19.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email ends with ["split.io"] then split 100:on, so not match', /*#__PURE__*/function () {
  var _ref20 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee20(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee20$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            label = 'not email ends with ["split.io"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['split.io']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context20.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nicolas.zelaya@split.io'
            });

          case 4:
            evaluation = _context20.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 7:
          case "end":
            return _context20.stop();
        }
      }
    }, _callee20);
  }));

  return function (_x20) {
    return _ref20.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email does not end with ["split.io"] then no match, so match', /*#__PURE__*/function () {
  var _ref21 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee21(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee21$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            label = 'not email ends with ["split.io"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['split.io']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context21.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'facundo@gmail.io'
            });

          case 4:
            evaluation = _context21.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context21.stop();
        }
      }
    }, _callee21);
  }));

  return function (_x21) {
    return _ref21.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email is an EMPTY string, end with ["nico"] should not match, so negation should', /*#__PURE__*/function () {
  var _ref22 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee22(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee22$(_context22) {
      while (1) {
        switch (_context22.prev = _context22.next) {
          case 0:
            label = 'not email ends with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context22.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: ''
            });

          case 4:
            evaluation = _context22.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context22.stop();
        }
      }
    }, _callee22);
  }));

  return function (_x22) {
    return _ref22.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email is not a string, end with ["nico"] should not match, so negation should', /*#__PURE__*/function () {
  var _ref23 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee23(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee23$(_context23) {
      while (1) {
        switch (_context23.prev = _context23.next) {
          case 0:
            label = 'not email ends with ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'ENDS_WITH',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context23.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: NaN
            });

          case 4:
            evaluation = _context23.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            _context23.next = 9;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31);

          case 9:
            evaluation = _context23.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 13:
          case "end":
            return _context23.stop();
        }
      }
    }, _callee23);
  }));

  return function (_x23) {
    return _ref23.apply(this, arguments);
  };
}()); //
// CONTAINS STRING
//

(0, _tapeCatch.default)('PARSER / if user.email contains ["@split"] then split 100:on', /*#__PURE__*/function () {
  var _ref24 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee24(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee24$(_context24) {
      while (1) {
        switch (_context24.prev = _context24.next) {
          case 0:
            label = 'email contains ["@split"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['@split']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context24.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nicolas.zelaya@split.io'
            });

          case 4:
            evaluation = _context24.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, "evaluator should return label ''");
            assert.end();

          case 9:
          case "end":
            return _context24.stop();
        }
      }
    }, _callee24);
  }));

  return function (_x24) {
    return _ref24.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email = 123, contains ["2"] then split 100:on should match', /*#__PURE__*/function () {
  var _ref25 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee25(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee25$(_context25) {
      while (1) {
        switch (_context25.prev = _context25.next) {
          case 0:
            label = 'email contains ["2"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['2']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context25.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 123
            });

          case 4:
            evaluation = _context25.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 9:
          case "end":
            return _context25.stop();
        }
      }
    }, _callee25);
  }));

  return function (_x25) {
    return _ref25.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email contains ["@split"] (beginning) then split 100:on', /*#__PURE__*/function () {
  var _ref26 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee26(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee26$(_context26) {
      while (1) {
        switch (_context26.prev = _context26.next) {
          case 0:
            label = 'email contains ["@split"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['@split']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context26.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: '@split.io.com.ar'
            });

          case 4:
            evaluation = _context26.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, "evaluator should return label ''");
            assert.end();

          case 9:
          case "end":
            return _context26.stop();
        }
      }
    }, _callee26);
  }));

  return function (_x26) {
    return _ref26.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email contains ["@split"] (end) then split 100:on', /*#__PURE__*/function () {
  var _ref27 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee27(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee27$(_context27) {
      while (1) {
        switch (_context27.prev = _context27.next) {
          case 0:
            label = 'email contains ["@split"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['@split']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context27.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nicolas.zelaya@split'
            });

          case 4:
            evaluation = _context27.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, "evaluator should return label ''");
            assert.end();

          case 9:
          case "end":
            return _context27.stop();
        }
      }
    }, _callee27);
  }));

  return function (_x27) {
    return _ref27.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email contains ["@split"] (whole string matches) then split 100:on', /*#__PURE__*/function () {
  var _ref28 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee28(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee28$(_context28) {
      while (1) {
        switch (_context28.prev = _context28.next) {
          case 0:
            label = 'email contains ["@split"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['@split']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context28.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: '@split'
            });

          case 4:
            evaluation = _context28.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, "evaluator should return label ''");
            assert.end();

          case 9:
          case "end":
            return _context28.stop();
        }
      }
    }, _callee28);
  }));

  return function (_x28) {
    return _ref28.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email contains ["@split", "@gmail", "@hotmail"] then split 100:on', /*#__PURE__*/function () {
  var _ref29 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee29(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee29$(_context29) {
      while (1) {
        switch (_context29.prev = _context29.next) {
          case 0:
            label = 'email contains ["@split", "@gmail", "@hotmail"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['@split', '@gmail', '@hotmail']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context29.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nico@hotmail.com'
            });

          case 4:
            evaluation = _context29.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, "evaluator should return label ''");
            assert.end();

          case 9:
          case "end":
            return _context29.stop();
        }
      }
    }, _callee29);
  }));

  return function (_x29) {
    return _ref29.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email contains ["@split", "@gmail", "@hotmail"] then split 100:on', /*#__PURE__*/function () {
  var _ref30 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee30(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee30$(_context30) {
      while (1) {
        switch (_context30.prev = _context30.next) {
          case 0:
            label = 'email contains ["@split", "@gmail", "@hotmail"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['@split', '@gmail', '@hotmail']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context30.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nico@gmail.com'
            });

          case 4:
            evaluation = _context30.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, "evaluator should return label ''");
            assert.end();

          case 9:
          case "end":
            return _context30.stop();
        }
      }
    }, _callee30);
  }));

  return function (_x30) {
    return _ref30.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email does not contain ["@split"] then not match', /*#__PURE__*/function () {
  var _ref31 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee31(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee31$(_context31) {
      while (1) {
        switch (_context31.prev = _context31.next) {
          case 0:
            label = 'email contains ["@split"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['@split']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context31.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'facundo@gmail.io'
            });

          case 4:
            evaluation = _context31.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 8:
          case "end":
            return _context31.stop();
        }
      }
    }, _callee31);
  }));

  return function (_x31) {
    return _ref31.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email is an EMPTY string, contains ["nico"] should not match', /*#__PURE__*/function () {
  var _ref32 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee32(assert) {
    var evaluator, evaluation;
    return _regenerator.default.wrap(function _callee32$(_context32) {
      while (1) {
        switch (_context32.prev = _context32.next) {
          case 0:
            // const label = 'email contains ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context32.next = 3;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: ''
            });

          case 3:
            evaluation = _context32.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 6:
          case "end":
            return _context32.stop();
        }
      }
    }, _callee32);
  }));

  return function (_x32) {
    return _ref32.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / if user.email is not a string, contains ["nico"] should not match', /*#__PURE__*/function () {
  var _ref33 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee33(assert) {
    var evaluator, evaluation;
    return _regenerator.default.wrap(function _callee33$(_context33) {
      while (1) {
        switch (_context33.prev = _context33.next) {
          case 0:
            // const label = 'email contains ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context33.next = 3;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: null
            });

          case 3:
            evaluation = _context33.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            _context33.next = 7;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: new Set()
            });

          case 7:
            evaluation = _context33.sent;
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 10:
          case "end":
            return _context33.stop();
        }
      }
    }, _callee33);
  }));

  return function (_x33) {
    return _ref33.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email contains ["@split"] then split 100:on, then no match', /*#__PURE__*/function () {
  var _ref34 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee34(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee34$(_context34) {
      while (1) {
        switch (_context34.prev = _context34.next) {
          case 0:
            label = 'not email contains ["@split"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['@split']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context34.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'nicolas.zelaya@split.io'
            });

          case 4:
            evaluation = _context34.sent;
            assert.equal((0, _typeof2.default)(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 8:
          case "end":
            return _context34.stop();
        }
      }
    }, _callee34);
  }));

  return function (_x34) {
    return _ref34.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email does not contain ["@split"] then not match, so match', /*#__PURE__*/function () {
  var _ref35 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee35(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee35$(_context35) {
      while (1) {
        switch (_context35.prev = _context35.next) {
          case 0:
            label = 'email contains ["@split"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['@split']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context35.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: 'facundo@gmail.io'
            });

          case 4:
            evaluation = _context35.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, "evaluator should return label ''");
            assert.end();

          case 8:
          case "end":
            return _context35.stop();
        }
      }
    }, _callee35);
  }));

  return function (_x35) {
    return _ref35.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email is an EMPTY string, contains ["nico"] should not match, so negation should', /*#__PURE__*/function () {
  var _ref36 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee36(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee36$(_context36) {
      while (1) {
        switch (_context36.prev = _context36.next) {
          case 0:
            label = 'not email contains ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context36.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: ''
            });

          case 4:
            evaluation = _context36.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 8:
          case "end":
            return _context36.stop();
        }
      }
    }, _callee36);
  }));

  return function (_x36) {
    return _ref36.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('PARSER / NEGATED if user.email is not a string, contains ["nico"] should not match, so negation should', /*#__PURE__*/function () {
  var _ref37 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee37(assert) {
    var label, evaluator, evaluation;
    return _regenerator.default.wrap(function _callee37$(_context37) {
      while (1) {
        switch (_context37.prev = _context37.next) {
          case 0:
            label = 'not email contains ["nico"]';
            evaluator = (0, _parser.default)([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'email'
                  },
                  matcherType: 'CONTAINS_STRING',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['nico']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: label
            }]);
            _context37.next = 4;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31, {
              email: function email() {}
            });

          case 4:
            evaluation = _context37.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            _context37.next = 9;
            return evaluator((0, _parser2.default)('a key'), 31, 100, 31);

          case 9:
            evaluation = _context37.sent;
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, label, 'evaluator should return correct label');
            assert.end();

          case 13:
          case "end":
            return _context37.stop();
        }
      }
    }, _callee37);
  }));

  return function (_x37) {
    return _ref37.apply(this, arguments);
  };
}());