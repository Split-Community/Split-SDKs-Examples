"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _tape = _interopRequireDefault(require("tape"));

var _evaluator = require("../../evaluator");

var LabelsConstants = _interopRequireWildcard(require("../../../utils/labels"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var splitsMock = {
  regular: '{"changeNumber":1487277320548,"trafficAllocationSeed":1667452163,"trafficAllocation":100,"trafficTypeName":"user","name":"always-on","seed":1684183541,"configurations":{},"status":"ACTIVE","killed":false,"defaultTreatment":"off","conditions":[{"conditionType":"ROLLOUT","matcherGroup":{"combiner":"AND","matchers":[{"keySelector":{"trafficType":"user","attribute":""},"matcherType":"ALL_KEYS","negate":false,"userDefinedSegmentMatcherData":{"segmentName":""},"unaryNumericMatcherData":{"dataType":"","value":0},"whitelistMatcherData":{"whitelist":null},"betweenMatcherData":{"dataType":"","start":0,"end":0}}]},"partitions":[{"treatment":"on","size":100},{"treatment":"off","size":0}],"label":"in segment all"}]}',
  config: '{"changeNumber":1487277320548,"trafficAllocationSeed":1667452163,"trafficAllocation":100,"trafficTypeName":"user","name":"always-on","seed":1684183541,"configurations":{"on":"{color:\'black\'}"},"status":"ACTIVE","killed":false,"defaultTreatment":"off","conditions":[{"conditionType":"ROLLOUT","matcherGroup":{"combiner":"AND","matchers":[{"keySelector":{"trafficType":"user","attribute":""},"matcherType":"ALL_KEYS","negate":false,"userDefinedSegmentMatcherData":{"segmentName":""},"unaryNumericMatcherData":{"dataType":"","value":0},"whitelistMatcherData":{"whitelist":null},"betweenMatcherData":{"dataType":"","start":0,"end":0}}]},"partitions":[{"treatment":"on","size":100},{"treatment":"off","size":0}],"label":"in segment all"}]}',
  killed: '{"changeNumber":1487277320548,"trafficAllocationSeed":1667452163,"trafficAllocation":100,"trafficTypeName":"user","name":"always-on2","seed":1684183541,"configurations":{},"status":"ACTIVE","killed":true,"defaultTreatment":"off","conditions":[{"conditionType":"ROLLOUT","matcherGroup":{"combiner":"AND","matchers":[{"keySelector":{"trafficType":"user","attribute":""},"matcherType":"ALL_KEYS","negate":false,"userDefinedSegmentMatcherData":{"segmentName":""},"unaryNumericMatcherData":{"dataType":"","value":0},"whitelistMatcherData":{"whitelist":null},"betweenMatcherData":{"dataType":"","start":0,"end":0}}]},"partitions":[{"treatment":"on","size":100},{"treatment":"off","size":0}],"label":"in segment all"}]}',
  archived: '{"changeNumber":1487277320548,"trafficAllocationSeed":1667452163,"trafficAllocation":100,"trafficTypeName":"user","name":"always-on3","seed":1684183541,"configurations":{},"status":"ARCHIVED","killed":false,"defaultTreatment":"off","conditions":[{"conditionType":"ROLLOUT","matcherGroup":{"combiner":"AND","matchers":[{"keySelector":{"trafficType":"user","attribute":""},"matcherType":"ALL_KEYS","negate":false,"userDefinedSegmentMatcherData":{"segmentName":""},"unaryNumericMatcherData":{"dataType":"","value":0},"whitelistMatcherData":{"whitelist":null},"betweenMatcherData":{"dataType":"","start":0,"end":0}}]},"partitions":[{"treatment":"on","size":100},{"treatment":"off","size":0}],"label":"in segment all"}]}',
  trafficAlocation1: '{"changeNumber":1487277320548,"trafficAllocationSeed":-1667452163,"trafficAllocation":1,"trafficTypeName":"user","name":"always-on4","seed":1684183541,"configurations":{},"status":"ACTIVE","killed":false,"defaultTreatment":"off","conditions":[{"conditionType":"ROLLOUT","matcherGroup":{"combiner":"AND","matchers":[{"keySelector":{"trafficType":"user","attribute":""},"matcherType":"ALL_KEYS","negate":false,"userDefinedSegmentMatcherData":{"segmentName":""},"unaryNumericMatcherData":{"dataType":"","value":0},"whitelistMatcherData":{"whitelist":null},"betweenMatcherData":{"dataType":"","start":0,"end":0}}]},"partitions":[{"treatment":"on","size":100},{"treatment":"off","size":0}],"label":"in segment all"}]}',
  killedWithConfig: '{"changeNumber":1487277320548,"trafficAllocationSeed":1667452163,"trafficAllocation":100,"trafficTypeName":"user","name":"always-on5","seed":1684183541,"configurations":{"off":"{color:\'black\'}"},"status":"ACTIVE","killed":true,"defaultTreatment":"off","conditions":[{"conditionType":"ROLLOUT","matcherGroup":{"combiner":"AND","matchers":[{"keySelector":{"trafficType":"user","attribute":""},"matcherType":"ALL_KEYS","negate":false,"userDefinedSegmentMatcherData":{"segmentName":""},"unaryNumericMatcherData":{"dataType":"","value":0},"whitelistMatcherData":{"whitelist":null},"betweenMatcherData":{"dataType":"","start":0,"end":0}}]},"partitions":[{"treatment":"on","size":100},{"treatment":"off","size":0}],"label":"in segment all"}]}',
  archivedWithConfig: '{"changeNumber":1487277320548,"trafficAllocationSeed":1667452163,"trafficAllocation":100,"trafficTypeName":"user","name":"always-on5","seed":1684183541,"configurations":{"off":"{color:\'black\'}"},"status":"ARCHIVED","killed":false,"defaultTreatment":"off","conditions":[{"conditionType":"ROLLOUT","matcherGroup":{"combiner":"AND","matchers":[{"keySelector":{"trafficType":"user","attribute":""},"matcherType":"ALL_KEYS","negate":false,"userDefinedSegmentMatcherData":{"segmentName":""},"unaryNumericMatcherData":{"dataType":"","value":0},"whitelistMatcherData":{"whitelist":null},"betweenMatcherData":{"dataType":"","start":0,"end":0}}]},"partitions":[{"treatment":"on","size":100},{"treatment":"off","size":0}],"label":"in segment all"}]}',
  trafficAlocation1WithConfig: '{"changeNumber":1487277320548,"trafficAllocationSeed":-1667452163,"trafficAllocation":1,"trafficTypeName":"user","name":"always-on6","seed":1684183541,"configurations":{"off":"{color:\'black\'}"},"status":"ACTIVE","killed":false,"defaultTreatment":"off","conditions":[{"conditionType":"ROLLOUT","matcherGroup":{"combiner":"AND","matchers":[{"keySelector":{"trafficType":"user","attribute":""},"matcherType":"ALL_KEYS","negate":false,"userDefinedSegmentMatcherData":{"segmentName":""},"unaryNumericMatcherData":{"dataType":"","value":0},"whitelistMatcherData":{"whitelist":null},"betweenMatcherData":{"dataType":"","start":0,"end":0}}]},"partitions":[{"treatment":"on","size":100},{"treatment":"off","size":0}],"label":"in segment all"}]}'
};
var mockStorage = {
  splits: {
    getSplit: function getSplit(name) {
      if (name === 'throw_exception') throw new Error('Error');
      if (splitsMock[name]) return splitsMock[name];
      return null;
    }
  }
};
(0, _tape.default)('EVALUATOR / should return label exception, treatment control and config null on error', /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(assert) {
    var expectedOutput, evaluationPromise, evaluation;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            expectedOutput = {
              treatment: 'control',
              label: LabelsConstants.EXCEPTION,
              config: null
            };
            evaluationPromise = (0, _evaluator.evaluateFeature)('fake-key', 'throw_exception', null, mockStorage); // This validation is async because the only exception possible when retrieving a Split would happen with Async storages.

            _context.next = 4;
            return evaluationPromise;

          case 4:
            evaluation = _context.sent;
            assert.deepEqual(evaluation, expectedOutput, 'If there was an error on the getSplits we should get the results for exception.');
            assert.end();

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
(0, _tape.default)('EVALUATOR / should return right label, treatment and config if storage returns without errors.', /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(assert) {
    var expectedOutput, expectedOutputControl, evaluationWithConfig, evaluationNotFound, evaluation, evaluationKilled, evaluationArchived, evaluationtrafficAlocation1, evaluationKilledWithConfig, evaluationArchivedWithConfig, evaluationtrafficAlocation1WithConfig;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            expectedOutput = {
              treatment: 'on',
              label: 'in segment all',
              config: '{color:\'black\'}',
              changeNumber: 1487277320548
            };
            expectedOutputControl = {
              treatment: 'control',
              label: LabelsConstants.SPLIT_NOT_FOUND,
              config: null
            };
            evaluationWithConfig = (0, _evaluator.evaluateFeature)('fake-key', 'config', null, mockStorage);
            assert.deepEqual(evaluationWithConfig, expectedOutput, 'If the split is retrieved successfully we should get the right evaluation result, label and config.');
            evaluationNotFound = (0, _evaluator.evaluateFeature)('fake-key', 'not_existent_split', null, mockStorage);
            assert.deepEqual(evaluationNotFound, expectedOutputControl, 'If the split is not retrieved successfully because it does not exist, we should get the right evaluation result, label and config.');
            evaluation = (0, _evaluator.evaluateFeature)('fake-key', 'regular', null, mockStorage);
            assert.deepEqual(evaluation, _objectSpread(_objectSpread({}, expectedOutput), {}, {
              config: null
            }), 'If the split is retrieved successfully we should get the right evaluation result, label and config. If Split has no config it should have config equal null.');
            evaluationKilled = (0, _evaluator.evaluateFeature)('fake-key', 'killed', null, mockStorage);
            assert.deepEqual(evaluationKilled, _objectSpread(_objectSpread({}, expectedOutput), {}, {
              treatment: 'off',
              config: null,
              label: LabelsConstants.SPLIT_KILLED
            }), 'If the split is retrieved but is killed, we should get the right evaluation result, label and config.');
            evaluationArchived = (0, _evaluator.evaluateFeature)('fake-key', 'archived', null, mockStorage);
            assert.deepEqual(evaluationArchived, _objectSpread(_objectSpread({}, expectedOutput), {}, {
              treatment: 'control',
              label: LabelsConstants.SPLIT_ARCHIVED,
              config: null
            }), 'If the split is retrieved but is archived, we should get the right evaluation result, label and config.');
            evaluationtrafficAlocation1 = (0, _evaluator.evaluateFeature)('fake-key', 'trafficAlocation1', null, mockStorage);
            assert.deepEqual(evaluationtrafficAlocation1, _objectSpread(_objectSpread({}, expectedOutput), {}, {
              label: LabelsConstants.NOT_IN_SPLIT,
              config: null,
              treatment: 'off'
            }), 'If the split is retrieved but is not in split (out of Traffic Allocation), we should get the right evaluation result, label and config.');
            evaluationKilledWithConfig = (0, _evaluator.evaluateFeature)('fake-key', 'killedWithConfig', null, mockStorage);
            assert.deepEqual(evaluationKilledWithConfig, _objectSpread(_objectSpread({}, expectedOutput), {}, {
              treatment: 'off',
              label: LabelsConstants.SPLIT_KILLED
            }), 'If the split is retrieved but is killed, we should get the right evaluation result, label and config.');
            evaluationArchivedWithConfig = (0, _evaluator.evaluateFeature)('fake-key', 'archivedWithConfig', null, mockStorage);
            assert.deepEqual(evaluationArchivedWithConfig, _objectSpread(_objectSpread({}, expectedOutput), {}, {
              treatment: 'control',
              label: LabelsConstants.SPLIT_ARCHIVED,
              config: null
            }), 'If the split is retrieved but is archived, we should get the right evaluation result, label and config.');
            evaluationtrafficAlocation1WithConfig = (0, _evaluator.evaluateFeature)('fake-key', 'trafficAlocation1WithConfig', null, mockStorage);
            assert.deepEqual(evaluationtrafficAlocation1WithConfig, _objectSpread(_objectSpread({}, expectedOutput), {}, {
              label: LabelsConstants.NOT_IN_SPLIT,
              treatment: 'off'
            }), 'If the split is retrieved but is not in split (out of Traffic Allocation), we should get the right evaluation result, label and config.');
            assert.end();

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());