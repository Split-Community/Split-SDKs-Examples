"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _ = require("../../");

var _splitchangesReal = _interopRequireDefault(require("../mocks/splitchanges.real.json"));

var _map = _interopRequireDefault(require("lodash/map"));

function _default(_x, _x2, _x3) {
  return _ref.apply(this, arguments);
}

function _ref() {
  _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(settings, fetchMock, assert) {
    var mockSplits, splitio, client, manager, manager2, splitNames, splitObj, expectedSplitObj, splitObjects;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            fetchMock.get({
              url: settings.url('/splitChanges?since=-1'),
              overwriteRoutes: true
            }, {
              status: 200,
              body: _splitchangesReal.default
            });
            mockSplits = _splitchangesReal.default;
            splitio = (0, _.SplitFactory)({
              core: {
                authorizationKey: '<fake-token-1>'
              },
              streamingEnabled: false
            });
            client = splitio.client();
            manager = splitio.manager();
            manager2 = splitio.manager();
            assert.equal(manager, manager2, 'Does not matter how many times you call .manager(), you get the same instance for the same factory.');
            assert.equal(manager.ready, client.ready, 'And it shares all readiness methods with the main client.');
            assert.equal(manager.on, client.on, 'And it shares all readiness methods with the main client.');
            assert.equal(manager.once, client.once, 'And it shares all readiness methods with the main client.');
            assert.equal(manager.Event, client.Event, 'And it shares all readiness constants with the main client.');
            _context.next = 13;
            return manager.ready();

          case 13:
            splitNames = manager.names();
            assert.equal(splitNames.length, mockSplits.splits.length, 'The manager.splits() method should return all split names on the factory storage.');
            assert.deepEqual(splitNames, (0, _map.default)(mockSplits.splits, function (split) {
              return split.name;
            }), 'The manager.splits() method should return all split names on the factory storage.');
            splitObj = manager.split(splitNames[0]);

            expectedSplitObj = function expectedSplitObj(index) {
              return {
                'trafficType': mockSplits.splits[index].trafficTypeName,
                'name': mockSplits.splits[index].name,
                'killed': mockSplits.splits[index].killed,
                'changeNumber': mockSplits.splits[index].changeNumber,
                'treatments': (0, _map.default)(mockSplits.splits[index].conditions[0].partitions, function (partition) {
                  return partition.treatment;
                }),
                'configs': mockSplits.splits[index].configurations || {}
              };
            };

            assert.equal(manager.split('non_existent'), null, 'Trying to get a manager.split() of a Split that does not exist returns null.');
            assert.deepEqual(splitObj, expectedSplitObj(0), 'If we ask for an existent one we receive the expected split view.');
            splitObjects = manager.splits();
            assert.equal(splitObjects.length, mockSplits.splits.length, 'The manager.splits() returns the full collection of split views.');
            assert.deepEqual(splitObjects[0], expectedSplitObj(0), 'And the split views should match the items of the collection in split view format.');
            assert.deepEqual(splitObjects[1], expectedSplitObj(1), 'And the split views should match the items of the collection in split view format.');
            client.destroy();
            assert.end();

          case 26:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _ref.apply(this, arguments);
}