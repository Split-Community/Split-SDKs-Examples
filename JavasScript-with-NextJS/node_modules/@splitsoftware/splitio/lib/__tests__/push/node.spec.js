"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _fetchMock = _interopRequireDefault(require("../testUtils/fetchMock"));

var _pushInitializationNopush = require("../nodeSuites/push-initialization-nopush.spec");

var _pushInitializationRetries = require("../nodeSuites/push-initialization-retries.spec");

var _pushSynchronization = require("../nodeSuites/push-synchronization.spec");

var _pushSynchronizationRetries = require("../nodeSuites/push-synchronization-retries.spec");

var _pushFallbacking = require("../nodeSuites/push-fallbacking.spec");

var _pushRefreshToken = require("../nodeSuites/push-refresh-token.spec");

_fetchMock.default.config.overwriteRoutes = false;
(0, _tapeCatch.default)('## Node JS - E2E CI Tests for PUSH ##', /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(assert) {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assert.test('E2E / PUSH initialization: auth with push disabled', _pushInitializationNopush.testAuthWithPushDisabled.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH initialization: auth with 401', _pushInitializationNopush.testAuthWith401.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH initialization: auth with 400', _pushInitializationNopush.testAuthWith400.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH initialization: fallback to polling if EventSource is not available', _pushInitializationNopush.testNoEventSource.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH initialization: auth failures and then success', _pushInitializationRetries.testAuthRetries.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH initialization: SSE connection failures and then success', _pushInitializationRetries.testSSERetries.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH disconnection: SDK destroyed while authenticating', _pushInitializationRetries.testSdkDestroyWhileAuthSuccess.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH disconnection: SDK destroyed while auth was retrying', _pushInitializationRetries.testSdkDestroyWhileAuthRetries.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH synchronization: happy paths', _pushSynchronization.testSynchronization.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH synchronization: retries', _pushSynchronizationRetries.testSynchronizationRetries.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH fallbacking', _pushFallbacking.testFallbacking.bind(null, _fetchMock.default));
            assert.test('E2E / PUSH refresh token', _pushRefreshToken.testRefreshToken.bind(null, _fetchMock.default));
            assert.end();

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());