"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _ = require("../../");

var _splitchangesSince = _interopRequireDefault(require("../mocks/splitchanges.since.-1.json"));

var _splitchangesSince2 = _interopRequireDefault(require("../mocks/splitchanges.since.1457552620999.json"));

var _mysegmentsNicolasSplitIo = _interopRequireDefault(require("../mocks/mysegments.nicolas@split.io.json"));

var _browser = require("../../storage/browser");

var _testUtils = require("../testUtils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var alwaysOnSplitInverted = JSON.stringify({
  'environment': null,
  'trafficTypeId': null,
  'trafficTypeName': null,
  'name': 'always_on',
  'seed': -790401604,
  'status': 'ACTIVE',
  'killed': false,
  'defaultTreatment': 'off',
  'conditions': [{
    'matcherGroup': {
      'combiner': 'AND',
      'matchers': [{
        'keySelector': {
          'trafficType': 'user',
          'attribute': null
        },
        'matcherType': 'ALL_KEYS',
        'negate': false,
        'userDefinedSegmentMatcherData': null,
        'whitelistMatcherData': null,
        'unaryNumericMatcherData': null,
        'betweenMatcherData': null
      }]
    },
    'partitions': [{
      'treatment': 'off',
      'size': 100
    }]
  }]
});
var splitDeclarations = {
  p1__split: {
    'name': 'p1__split',
    'status': 'ACTIVE',
    'conditions': []
  },
  p2__split: {
    'name': 'p2__split',
    'status': 'ACTIVE',
    'conditions': []
  },
  p3__split: {
    'name': 'p3__split',
    'status': 'ACTIVE',
    'conditions': []
  }
};
var baseConfig = {
  core: {
    authorizationKey: '<fake-token-rfc>',
    key: 'nicolas@split.io'
  },
  scheduler: {
    featuresRefreshRate: 3000,
    segmentsRefreshRate: 3000,
    metricsRefreshRate: 3000,
    impressionsRefreshRate: 3000
  },
  startup: {
    readyTimeout: 10,
    requestTimeoutBeforeReady: 10,
    eventsFirstPushWindow: 3000
  },
  streamingEnabled: false
};

function _default(fetchMock, assert) {
  assert.test(function (t) {
    // Testing when we start from scratch
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCacheEmpty',
      events: 'https://events.baseurl/readyFromCacheEmpty'
    };
    localStorage.clear();
    t.plan(3);
    fetchMock.get(testUrls.sdk + '/splitChanges?since=-1', {
      status: 200,
      body: _splitchangesSince.default
    });
    fetchMock.get(testUrls.sdk + '/splitChanges?since=1457552620999', {
      status: 200,
      body: _splitchangesSince2.default
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas%40split.io', {
      status: 200,
      body: _mysegmentsNicolasSplitIo.default
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas2%40split.io', {
      status: 200,
      body: {
        'mySegments': []
      }
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas3%40split.io', {
      status: 200,
      body: {
        'mySegments': []
      }
    });
    var splitio = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, baseConfig), {}, {
      core: _objectSpread(_objectSpread({}, baseConfig.core), {}, {
        authorizationKey: '<fake-token-rfc2>'
      }),
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_1'
      },
      urls: testUrls
    }));
    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('It should not timeout in this scenario.');
      t.end();
    });
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.fail('It should not emit SDK_READY_FROM_CACHE if there is no cache.');
      t.end();
    });
    client.on(client.Event.SDK_READY, function () {
      t.pass('It should emit SDK_READY alone, since there was no cache.');
    });
    client2.on(client.Event.SDK_READY, function () {
      t.pass('It should emit SDK_READY alone, since there was no cache.');
    });
    client3.on(client.Event.SDK_READY, function () {
      t.pass('It should emit SDK_READY alone, since there was no cache.');
    });
  });
  assert.test(function (t) {
    // Testing when we start with cached data but without lastUpdate item (previous version)
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCacheWithData',
      events: 'https://events.baseurl/readyFromCacheWithData'
    };
    localStorage.clear();
    t.plan(12 * 2 + 3);
    fetchMock.get(testUrls.sdk + '/splitChanges?since=25', function () {
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: _objectSpread(_objectSpread({}, _splitchangesSince.default), {}, {
              since: 25
            }),
            headers: {}
          });
        }, 200);
      }); // 400ms is how long it'll take to reply with Splits, no SDK_READY should be emitted before that.
    });
    fetchMock.get(testUrls.sdk + '/splitChanges?since=1457552620999', {
      status: 200,
      body: _splitchangesSince2.default
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas%40split.io', function () {
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: _mysegmentsNicolasSplitIo.default,
            headers: {}
          });
        }, 400);
      }); // First client gets segments before splits. No segment cache loading (yet)
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas2%40split.io', function () {
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: {
              'mySegments': []
            },
            headers: {}
          });
        }, 700);
      }); // Second client gets segments after 700ms
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas3%40split.io', function () {
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: {
              'mySegments': []
            },
            headers: {}
          });
        }, 1000);
      }); // Third client mySegments will come after 1s
    });
    fetchMock.postOnce(testUrls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(testUrls.events + '/testImpressions/count', 200);
    localStorage.setItem('some_user_item', 'user_item');
    localStorage.setItem('readyFromCache_2.SPLITIO.splits.till', 25);
    localStorage.setItem('readyFromCache_2.SPLITIO.split.always_on', alwaysOnSplitInverted);
    var startTime = Date.now();
    var splitio = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, baseConfig), {}, {
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_2'
      },
      startup: {
        readyTimeout: 0.85
      },
      urls: testUrls,
      debug: true
    }));
    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    t.equal(client.getTreatment('always_on'), 'control', 'It should evaluate control treatments if not ready neither by cache nor the cloud');
    t.equal(client3.getTreatment('always_on'), 'control', 'It should evaluate control treatments if not ready neither by cache nor the cloud');
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('It should not timeout in this scenario.');
      t.end();
    });
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.true(Date.now() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client2.once(client2.Event.SDK_READY_FROM_CACHE, function () {
      t.true(Date.now() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client2.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client3.once(client3.Event.SDK_READY_FROM_CACHE, function () {
      t.true(Date.now() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client3.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client.on(client.Event.SDK_READY, function () {
      t.true(Date.now() - startTime >= 400, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client.ready().then(function () {
      t.true(Date.now() - startTime >= 400, 'It should resolve ready promise after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client2.on(client2.Event.SDK_READY, function () {
      t.true(Date.now() - startTime >= 700, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client2.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client2.ready().then(function () {
      t.true(Date.now() - startTime >= 700, 'It should resolve ready promise after syncing with the cloud.');
      t.equal(client2.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client3.on(client3.Event.SDK_READY, function () {
      client3.ready().then(function () {
        t.true(Date.now() - startTime >= 1000, 'It should resolve ready promise after syncing with the cloud.');
        t.equal(client3.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.'); // Last cb: destroy clients and check that localstorage has the expected items

        Promise.all([client3.destroy(), client2.destroy(), client.destroy()]).then(function () {
          t.equal(localStorage.getItem('some_user_item'), 'user_item', 'user items at localStorage must not be changed');
          t.equal(localStorage.getItem('readyFromCache_2.SPLITIO.splits.till'), '1457552620999', 'splits.till must correspond to the till of the last successfully fetched Splits');
          t.true((0, _testUtils.nearlyEqual)(parseInt(localStorage.getItem('readyFromCache_2.SPLITIO.splits.lastUpdated')), Date.now() - 800
          /* 800 ms between last Split and MySegments fetch */
          ), 'lastUpdated is added and must correspond to the timestamp of the last successfully fetched Splits');
        });
      });
      t.true(Date.now() - startTime >= 1000, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client3.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client3.on(client3.Event.SDK_READY_TIMED_OUT, function () {
      client3.ready().catch(function () {
        t.true(Date.now() - startTime >= 850, 'It should reject ready promise before syncing mySegments data with the cloud.');
        t.equal(client3.getTreatment('always_on'), 'on', 'It should evaluate treatments with mySegments data from cache.');
      });
      t.true(Date.now() - startTime >= 850, 'It should emit SDK_READY_TIMED_OUT before syncing mySegments data with the cloud.');
      t.equal(client3.getTreatment('always_on'), 'on', 'It should evaluate treatments with mySegments data from cache.');
    });
  });
  assert.test(function (t) {
    // Testing when we start with cached data and not expired (lastUpdate item higher than expirationTimestamp)
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCacheWithData3',
      events: 'https://events.baseurl/readyFromCacheWithData3'
    };
    localStorage.clear();
    t.plan(12 * 2 + 4);
    fetchMock.get(testUrls.sdk + '/splitChanges?since=25', function () {
      t.equal(localStorage.getItem('readyFromCache_3.SPLITIO.split.always_on'), alwaysOnSplitInverted, 'splits must not be cleaned from cache');
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: _objectSpread(_objectSpread({}, _splitchangesSince.default), {}, {
              since: 25
            }),
            headers: {}
          });
        }, 200);
      }); // 400ms is how long it'll take to reply with Splits, no SDK_READY should be emitted before that.
    });
    fetchMock.get(testUrls.sdk + '/splitChanges?since=1457552620999', {
      status: 200,
      body: _splitchangesSince2.default
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas%40split.io', function () {
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: _mysegmentsNicolasSplitIo.default,
            headers: {}
          });
        }, 400);
      }); // First client gets segments before splits. No segment cache loading (yet)
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas2%40split.io', function () {
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: {
              'mySegments': []
            },
            headers: {}
          });
        }, 700);
      }); // Second client gets segments after 700ms
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas3%40split.io', function () {
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: {
              'mySegments': []
            },
            headers: {}
          });
        }, 1000);
      }); // Third client mySegments will come after 1s
    });
    fetchMock.postOnce(testUrls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(testUrls.events + '/testImpressions/count', 200);
    localStorage.setItem('some_user_item', 'user_item');
    localStorage.setItem('readyFromCache_3.SPLITIO.splits.till', 25);
    localStorage.setItem('readyFromCache_3.SPLITIO.splits.lastUpdated', Date.now());
    localStorage.setItem('readyFromCache_3.SPLITIO.split.always_on', alwaysOnSplitInverted);
    var startTime = Date.now();
    var splitio = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, baseConfig), {}, {
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_3'
      },
      startup: {
        readyTimeout: 0.85
      },
      urls: testUrls,
      debug: true
    }));
    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    t.equal(client.getTreatment('always_on'), 'control', 'It should evaluate control treatments if not ready neither by cache nor the cloud');
    t.equal(client3.getTreatment('always_on'), 'control', 'It should evaluate control treatments if not ready neither by cache nor the cloud');
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('It should not timeout in this scenario.');
      t.end();
    });
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.true(Date.now() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client2.once(client2.Event.SDK_READY_FROM_CACHE, function () {
      t.true(Date.now() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client2.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client3.once(client3.Event.SDK_READY_FROM_CACHE, function () {
      t.true(Date.now() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client3.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client.on(client.Event.SDK_READY, function () {
      t.true(Date.now() - startTime >= 400, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client.ready().then(function () {
      t.true(Date.now() - startTime >= 400, 'It should resolve ready promise after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client2.on(client2.Event.SDK_READY, function () {
      t.true(Date.now() - startTime >= 700, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client2.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client2.ready().then(function () {
      t.true(Date.now() - startTime >= 700, 'It should resolve ready promise after syncing with the cloud.');
      t.equal(client2.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client3.on(client3.Event.SDK_READY, function () {
      client3.ready().then(function () {
        t.true(Date.now() - startTime >= 1000, 'It should resolve ready promise after syncing with the cloud.');
        t.equal(client3.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.'); // Last cb: destroy clients and check that localstorage has the expected items

        Promise.all([client3.destroy(), client2.destroy(), client.destroy()]).then(function () {
          t.equal(localStorage.getItem('some_user_item'), 'user_item', 'user items at localStorage must not be changed');
          t.equal(localStorage.getItem('readyFromCache_3.SPLITIO.splits.till'), '1457552620999', 'splits.till must correspond to the till of the last successfully fetched Splits');
          t.true((0, _testUtils.nearlyEqual)(parseInt(localStorage.getItem('readyFromCache_3.SPLITIO.splits.lastUpdated')), Date.now() - 800
          /* 800 ms between last Split and MySegments fetch */
          ), 'lastUpdated must correspond to the timestamp of the last successfully fetched Splits');
        });
      });
      t.true(Date.now() - startTime >= 1000, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client3.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client3.on(client3.Event.SDK_READY_TIMED_OUT, function () {
      client3.ready().catch(function () {
        t.true(Date.now() - startTime >= 850, 'It should reject ready promise before syncing mySegments data with the cloud.');
        t.equal(client3.getTreatment('always_on'), 'on', 'It should evaluate treatments with mySegments data from cache.');
      });
      t.true(Date.now() - startTime >= 850, 'It should emit SDK_READY_TIMED_OUT before syncing mySegments data with the cloud.');
      t.equal(client3.getTreatment('always_on'), 'on', 'It should evaluate treatments with mySegments data from cache.');
    });
  });
  assert.test(function (t) {
    // Testing when we start with cached data but expired (lastUpdate item lower than expirationTimestamp)
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCacheWithData4',
      events: 'https://events.baseurl/readyFromCacheWithData4'
    };
    localStorage.clear();
    t.plan(9 * 2 + 5);
    fetchMock.get(testUrls.sdk + '/splitChanges?since=-1', function () {
      t.equal(localStorage.getItem('some_user_item'), 'user_item', 'user items at localStorage must not be changed');
      t.equal(localStorage.length, 1, 'split cache data must be cleaned from localStorage');
      return {
        status: 200,
        body: _splitchangesSince.default
      };
    });
    fetchMock.get(testUrls.sdk + '/splitChanges?since=1457552620999', {
      status: 200,
      body: _splitchangesSince2.default
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas%40split.io', function () {
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: _mysegmentsNicolasSplitIo.default,
            headers: {}
          });
        }, 400);
      }); // First client gets segments before splits. No segment cache loading (yet)
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas2%40split.io', function () {
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: {
              'mySegments': []
            },
            headers: {}
          });
        }, 700);
      }); // Second client gets segments after 700ms
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas3%40split.io', function () {
      return new Promise(function (res) {
        setTimeout(function () {
          return res({
            status: 200,
            body: {
              'mySegments': []
            },
            headers: {}
          });
        }, 1000);
      }); // Third client mySegments will come after 1s
    });
    fetchMock.postOnce(testUrls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(testUrls.events + '/testImpressions/count', 200);
    localStorage.setItem('some_user_item', 'user_item');
    localStorage.setItem('readyFromCache_4.SPLITIO.splits.till', 25);
    localStorage.setItem('readyFromCache_4.SPLITIO.splits.lastUpdated', Date.now() - _browser.DEFAULT_CACHE_EXPIRATION_IN_MILLIS - 1); // -1 to ensure having an expired lastUpdated item

    localStorage.setItem('readyFromCache_4.SPLITIO.split.always_on', alwaysOnSplitInverted);
    var startTime = Date.now();
    var splitio = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, baseConfig), {}, {
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_4'
      },
      startup: {
        readyTimeout: 0.85
      },
      urls: testUrls,
      debug: true
    }));
    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    t.equal(client.getTreatment('always_on'), 'control', 'It should evaluate control treatments if not ready neither by cache nor the cloud');
    t.equal(client3.getTreatment('always_on'), 'control', 'It should evaluate control treatments if not ready neither by cache nor the cloud');
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('It should not timeout in this scenario.');
      t.end();
    });
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.fail('It should not emit SDK_READY_FROM_CACHE if there is expired cache.');
      t.end();
    });
    client2.once(client2.Event.SDK_READY_FROM_CACHE, function () {
      t.fail('It should not emit SDK_READY_FROM_CACHE if there is expired cache.');
      t.end();
    });
    client3.once(client3.Event.SDK_READY_FROM_CACHE, function () {
      t.fail('It should not emit SDK_READY_FROM_CACHE if there is expired cache.');
      t.end();
    });
    client.on(client.Event.SDK_READY, function () {
      t.true(Date.now() - startTime >= 400, 'It should emit SDK_READY after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client.ready().then(function () {
      t.true(Date.now() - startTime >= 400, 'It should resolve ready promise after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client2.on(client2.Event.SDK_READY, function () {
      t.true(Date.now() - startTime >= 700, 'It should emit SDK_READY after syncing with the cloud.');
      t.equal(client2.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client2.ready().then(function () {
      t.true(Date.now() - startTime >= 700, 'It should resolve ready promise after syncing with the cloud.');
      t.equal(client2.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client3.on(client3.Event.SDK_READY, function () {
      client3.ready().then(function () {
        t.true(Date.now() - startTime >= 1000, 'It should resolve ready promise after syncing with the cloud.');
        t.equal(client3.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.'); // Last cb: destroy clients and check that localstorage has the expected items

        Promise.all([client3.destroy(), client2.destroy(), client.destroy()]).then(function () {
          t.equal(localStorage.getItem('some_user_item'), 'user_item', 'user items at localStorage must not be changed');
          t.equal(localStorage.getItem('readyFromCache_4.SPLITIO.splits.till'), '1457552620999', 'splits.till must correspond to the till of the last successfully fetched Splits');
          t.true((0, _testUtils.nearlyEqual)(parseInt(localStorage.getItem('readyFromCache_4.SPLITIO.splits.lastUpdated')), Date.now() - 1000
          /* 1000 ms between last Split and MySegments fetch */
          ), 'lastUpdated must correspond to the timestamp of the last successfully fetched Splits');
        });
      });
      t.true(Date.now() - startTime >= 1000, 'It should emit SDK_READY after syncing with the cloud.');
      t.equal(client3.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client3.on(client3.Event.SDK_READY_TIMED_OUT, function () {
      client3.ready().catch(function () {
        t.true(Date.now() - startTime >= 850, 'It should reject ready promise before syncing mySegments data with the cloud.');
        t.equal(client3.getTreatment('always_on'), 'control', 'It should not evaluate treatments with mySegments data from cache.');
      });
      t.true(Date.now() - startTime >= 850, 'It should emit SDK_READY_TIMED_OUT before syncing mySegments data with the cloud.');
      t.equal(client3.getTreatment('always_on'), 'control', 'It should evaluate treatments with mySegments data from cache.');
    });
  });
  /** Fetch specific splits **/

  assert.test(function (t) {
    // Testing when we start with cached data without split filter, and a valid split filter config
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCache_5',
      events: 'https://events.baseurl/readyFromCache_5'
    };
    localStorage.clear();
    t.plan(7);
    fetchMock.getOnce(testUrls.sdk + '/splitChanges?since=-1&names=p1__split,p2__split', {
      status: 200,
      body: {
        splits: [splitDeclarations.p1__split, splitDeclarations.p2__split],
        since: -1,
        till: 1457552620999
      }
    }, {
      delay: 10
    }); // short delay to let emit SDK_READY_FROM_CACHE
    // fetchMock.getOnce(testUrls.sdk + '/splitChanges?since=1457552620999&names=p1__split', { status: 200, body: { splits: [], since: 1457552620999, till: 1457552620999 } });

    fetchMock.getOnce(testUrls.sdk + '/mySegments/nicolas%40split.io', {
      status: 200,
      body: {
        mySegments: []
      }
    });
    localStorage.setItem('some_user_item', 'user_item');
    localStorage.setItem('readyFromCache_5.SPLITIO.splits.till', 25);
    localStorage.setItem('readyFromCache_5.SPLITIO.split.p2__split', JSON.stringify(splitDeclarations.p2__split));
    localStorage.setItem('readyFromCache_5.SPLITIO.split.p3__split', JSON.stringify(splitDeclarations.p3__split));
    var splitio = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, baseConfig), {}, {
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_5'
      },
      urls: testUrls,
      sync: {
        splitFilters: [{
          type: 'byName',
          values: ['p2__split', 'p1__split']
        }, {
          type: 'byName',
          values: ['p2__split', null]
        }]
      },
      debug: true
    }));
    var client = splitio.client();
    var manager = splitio.manager();
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.deepEqual(manager.names(), ['p2__split'], 'stored p3__split must be removed because doesn\'t match the filter');
    });
    client.once(client.Event.SDK_READY, function () {
      t.deepEqual(manager.names(), ['p1__split', 'p2__split'], 'p1__split should be added for evaluation');
      client.destroy().then(function () {
        t.equal(localStorage.getItem('some_user_item'), 'user_item', 'user items at localStorage must not be changed');
        t.equal(localStorage.getItem('readyFromCache_5.SPLITIO.splits.till'), '1457552620999', 'splits.till must correspond to the till of the last successfully fetched Splits');
        t.equal(localStorage.getItem('readyFromCache_5.SPLITIO.split.p1__split'), JSON.stringify(splitDeclarations.p1__split), 'split declarations must be cached');
        t.equal(localStorage.getItem('readyFromCache_5.SPLITIO.split.p2__split'), JSON.stringify(splitDeclarations.p2__split), 'split declarations must be cached');
        t.equal(localStorage.getItem('readyFromCache_5.SPLITIO.splits.filterQuery'), '&names=p1__split,p2__split', 'splits.filterQuery must correspond to the split filter query');
        t.end();
      });
    });
  });
  assert.test(function (t) {
    // Testing when we start from scratch, and a valid split filter config
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCache_5B',
      events: 'https://events.baseurl/readyFromCache_5B'
    };
    localStorage.clear();
    t.plan(5);
    fetchMock.getOnce(testUrls.sdk + '/splitChanges?since=-1&names=p1__split,p2__split', {
      status: 200,
      body: {
        splits: [splitDeclarations.p1__split, splitDeclarations.p2__split],
        since: -1,
        till: 1457552620999
      }
    }, {
      delay: 10
    }); // short delay to let emit SDK_READY_FROM_CACHE

    fetchMock.getOnce(testUrls.sdk + '/mySegments/nicolas%40split.io', {
      status: 200,
      body: {
        mySegments: []
      }
    });
    var splitio = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, baseConfig), {}, {
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_5B'
      },
      urls: testUrls,
      sync: {
        splitFilters: [{
          type: 'byName',
          values: ['p2__split', 'p1__split']
        }, {
          type: 'byName',
          values: ['p2__split', null]
        }]
      },
      debug: true
    }));
    var client = splitio.client();
    var manager = splitio.manager();
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.fail('It should not emit SDK_READY_FROM_CACHE if cache is empty.');
      t.end();
    });
    client.once(client.Event.SDK_READY, function () {
      t.deepEqual(manager.names(), ['p1__split', 'p2__split'], 'p1__split should be added for evaluation');
      client.destroy().then(function () {
        t.equal(localStorage.getItem('readyFromCache_5B.SPLITIO.splits.till'), '1457552620999', 'splits.till must correspond to the till of the last successfully fetched Splits');
        t.equal(localStorage.getItem('readyFromCache_5B.SPLITIO.split.p1__split'), JSON.stringify(splitDeclarations.p1__split), 'split declarations must be cached');
        t.equal(localStorage.getItem('readyFromCache_5B.SPLITIO.split.p2__split'), JSON.stringify(splitDeclarations.p2__split), 'split declarations must be cached');
        t.equal(localStorage.getItem('readyFromCache_5B.SPLITIO.splits.filterQuery'), '&names=p1__split,p2__split', 'splits.filterQuery must correspond to the split filter query');
        t.end();
      });
    });
  });
  assert.test(function (t) {
    // Testing when we start with cached data with split filter, and the same split filter config
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCache_6',
      events: 'https://events.baseurl/readyFromCache_6'
    };
    localStorage.clear();
    t.plan(7);
    fetchMock.getOnce(testUrls.sdk + '/splitChanges?since=25&names=p2__split&prefixes=p1', {
      status: 200,
      body: {
        splits: [splitDeclarations.p1__split, splitDeclarations.p2__split],
        since: 25,
        till: 1457552620999
      }
    }, {
      delay: 10
    }); // short delay to let emit SDK_READY_FROM_CACHE

    fetchMock.getOnce(testUrls.sdk + '/mySegments/nicolas%40split.io', {
      status: 200,
      body: {
        mySegments: []
      }
    });
    localStorage.setItem('some_user_item', 'user_item');
    localStorage.setItem('readyFromCache_6.SPLITIO.splits.till', 25);
    localStorage.setItem('readyFromCache_6.SPLITIO.split.p1__split', JSON.stringify(splitDeclarations.p1__split));
    localStorage.setItem('readyFromCache_6.SPLITIO.split.p2__split', JSON.stringify(splitDeclarations.p2__split));
    localStorage.setItem('readyFromCache_6.SPLITIO.splits.filterQuery', '&names=p2__split&prefixes=p1');
    var splitio = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, baseConfig), {}, {
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_6'
      },
      urls: testUrls,
      sync: {
        splitFilters: [{
          type: 'byName',
          values: [undefined, true, 'p2__split']
        }, {
          type: 'byPrefix',
          values: ['p1']
        }, {
          type: 'byName',
          values: ['p2__split']
        }]
      },
      debug: true
    }));
    var client = splitio.client();
    var manager = splitio.manager();
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.deepEqual(manager.names(), ['p2__split', 'p1__split'], 'splits shouldn\'t be removed for evaluation');
    });
    client.once(client.Event.SDK_READY, function () {
      t.deepEqual(manager.names(), ['p2__split', 'p1__split'], 'active splits should be present for evaluation');
      client.destroy().then(function () {
        t.equal(localStorage.getItem('some_user_item'), 'user_item', 'user items at localStorage must not be changed');
        t.equal(localStorage.getItem('readyFromCache_6.SPLITIO.splits.till'), '1457552620999', 'splits.till must correspond to the till of the last successfully fetched Splits');
        t.equal(localStorage.getItem('readyFromCache_6.SPLITIO.split.p1__split'), JSON.stringify(splitDeclarations.p1__split), 'split declarations must be cached');
        t.equal(localStorage.getItem('readyFromCache_6.SPLITIO.split.p2__split'), JSON.stringify(splitDeclarations.p2__split), 'split declarations must be cached');
        t.equal(localStorage.getItem('readyFromCache_6.SPLITIO.splits.filterQuery'), '&names=p2__split&prefixes=p1', 'splits.filterQuery must correspond to the split filter query');
        t.end();
      });
    });
  });
  assert.test(function (t) {
    // Testing when we start with cached data with split filter but expired, and the same split filter config
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCache_7',
      events: 'https://events.baseurl/readyFromCache_7'
    };
    localStorage.clear();
    t.plan(6);
    fetchMock.getOnce(testUrls.sdk + '/splitChanges?since=-1&prefixes=p1,p2', {
      status: 200,
      body: {
        splits: [splitDeclarations.p1__split, splitDeclarations.p2__split],
        since: -1,
        till: 1457552620999
      }
    }, {
      delay: 10
    }); // short delay to let emit SDK_READY_FROM_CACHE

    fetchMock.getOnce(testUrls.sdk + '/mySegments/nicolas%40split.io', {
      status: 200,
      body: {
        mySegments: []
      }
    });
    localStorage.setItem('some_user_item', 'user_item');
    localStorage.setItem('readyFromCache_7.SPLITIO.splits.till', 25);
    localStorage.setItem('readyFromCache_7.SPLITIO.split.p1__split', JSON.stringify(splitDeclarations.p1__split));
    localStorage.setItem('readyFromCache_7.SPLITIO.split.p2__split', JSON.stringify(splitDeclarations.p2__split));
    localStorage.setItem('readyFromCache_7.SPLITIO.splits.filterQuery', '&prefixes=p1,p2');
    localStorage.setItem('readyFromCache_7.SPLITIO.splits.lastUpdated', Date.now() - _browser.DEFAULT_CACHE_EXPIRATION_IN_MILLIS - 1); // -1 to ensure having an expired lastUpdated item

    var splitio = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, baseConfig), {}, {
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_7'
      },
      urls: testUrls,
      sync: {
        splitFilters: [{
          type: 'byPrefix',
          values: ['p2']
        }, {
          type: 'byPrefix',
          values: ['p1', '']
        }, {
          type: '',
          values: []
        }, {}, {
          type: 'byPrefix'
        }]
      },
      debug: true
    }));
    var client = splitio.client();
    var manager = splitio.manager();
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.fail('It should not emit SDK_READY_FROM_CACHE if cache has expired.');
      t.end();
    });
    client.once(client.Event.SDK_READY, function () {
      t.deepEqual(manager.names(), ['p2__split', 'p1__split'], 'active splits should be present for evaluation');
      client.destroy().then(function () {
        t.equal(localStorage.getItem('some_user_item'), 'user_item', 'user items at localStorage must not be changed');
        t.equal(localStorage.getItem('readyFromCache_7.SPLITIO.splits.till'), '1457552620999', 'splits.till must correspond to the till of the last successfully fetched Splits');
        t.equal(localStorage.getItem('readyFromCache_7.SPLITIO.split.p1__split'), JSON.stringify(splitDeclarations.p1__split), 'split declarations must be cached');
        t.equal(localStorage.getItem('readyFromCache_7.SPLITIO.split.p2__split'), JSON.stringify(splitDeclarations.p2__split), 'split declarations must be cached');
        t.equal(localStorage.getItem('readyFromCache_7.SPLITIO.splits.filterQuery'), '&prefixes=p1,p2', 'splits.filterQuery must correspond to the split filter query');
        t.end();
      });
    });
  });
  assert.test(function (assert) {
    // Testing when we start with cached data with split filter, and no or invalid split filter config (null query string)
    var syncParamsWithNullSplitQuery = [// not defined sync config param
    undefined, // invalid splitFilters param
    {
      splitFilters: 'invalid'
    }, // splitFilters param with all filters invalid
    {
      splitFilters: [{
        type: 'byTag',
        values: ['some_tag']
      }]
    }];
    syncParamsWithNullSplitQuery.forEach(function (syncParam) {
      assert.test(function (t) {
        var testUrls = {
          sdk: 'https://sdk.baseurl/readyFromCache_8',
          events: 'https://events.baseurl/readyFromCache_8'
        };
        localStorage.clear();
        t.plan(7);
        fetchMock.getOnce(testUrls.sdk + '/splitChanges?since=-1', {
          status: 200,
          body: {
            splits: [splitDeclarations.p1__split, splitDeclarations.p2__split, splitDeclarations.p3__split],
            since: -1,
            till: 1457552620999
          }
        }, {
          delay: 10
        }); // short delay to let emit SDK_READY_FROM_CACHE

        fetchMock.getOnce(testUrls.sdk + '/mySegments/nicolas%40split.io', {
          status: 200,
          body: {
            mySegments: []
          }
        });
        localStorage.setItem('some_user_item', 'user_item');
        localStorage.setItem('readyFromCache_8.SPLITIO.splits.till', 25);
        localStorage.setItem('readyFromCache_8.SPLITIO.split.p1__split', JSON.stringify(splitDeclarations.p1__split));
        localStorage.setItem('readyFromCache_8.SPLITIO.split.p2__split', JSON.stringify(splitDeclarations.p2__split));
        localStorage.setItem('readyFromCache_8.SPLITIO.split.deleted__split', 'deleted_split');
        localStorage.setItem('readyFromCache_8.SPLITIO.splits.filterQuery', '&names=p2__split&prefixes=p1');
        var splitio = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, baseConfig), {}, {
          storage: {
            type: 'LOCALSTORAGE',
            prefix: 'readyFromCache_8'
          },
          urls: testUrls,
          sync: syncParam,
          debug: true
        }));
        var client = splitio.client();
        var manager = splitio.manager();
        client.once(client.Event.SDK_READY_FROM_CACHE, function () {
          t.fail('It should not emit SDK_READY_FROM_CACHE because all splits were removed from cache since the filter query changed.');
          t.end();
        });
        client.once(client.Event.SDK_READY, function () {
          t.deepEqual(manager.names(), ['p1__split', 'p2__split', 'p3__split'], 'active splits should be present for evaluation');
          client.destroy().then(function () {
            t.equal(localStorage.getItem('some_user_item'), 'user_item', 'user items at localStorage must not be changed');
            t.equal(localStorage.getItem('readyFromCache_8.SPLITIO.splits.till'), '1457552620999', 'splits.till must correspond to the till of the last successfully fetched Splits');
            t.equal(localStorage.getItem('readyFromCache_8.SPLITIO.split.p1__split'), JSON.stringify(splitDeclarations.p1__split), 'split declarations must be cached');
            t.equal(localStorage.getItem('readyFromCache_8.SPLITIO.split.p2__split'), JSON.stringify(splitDeclarations.p2__split), 'split declarations must be cached');
            t.equal(localStorage.getItem('readyFromCache_8.SPLITIO.split.p3__split'), JSON.stringify(splitDeclarations.p3__split), 'split declarations must be cached');
            t.equal(localStorage.getItem('readyFromCache_8.SPLITIO.splits.filterQuery'), null, 'splits.filterQuery must correspond to the split filter query');
            t.end();
          });
        });
      });
    });
  });
  assert.test(function (t) {
    // Testing when we start with cached data with split filter, and a new valid split filter config
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCache_9',
      events: 'https://events.baseurl/readyFromCache_9'
    };
    localStorage.clear();
    t.plan(7);
    fetchMock.getOnce(testUrls.sdk + '/splitChanges?since=-1&names=no%20exist%20trim,no_exist,p3__split&prefixes=no%20exist%20trim,p2', {
      status: 200,
      body: {
        splits: [splitDeclarations.p2__split, splitDeclarations.p3__split],
        since: -1,
        till: 1457552620999
      }
    }, {
      delay: 10
    }); // short delay to let emit SDK_READY_FROM_CACHE

    fetchMock.getOnce(testUrls.sdk + '/mySegments/nicolas%40split.io', {
      status: 200,
      body: {
        mySegments: []
      }
    });
    localStorage.setItem('some_user_item', 'user_item');
    localStorage.setItem('readyFromCache_9.SPLITIO.splits.till', 25);
    localStorage.setItem('readyFromCache_9.SPLITIO.split.p1__split', JSON.stringify(splitDeclarations.p1__split));
    localStorage.setItem('readyFromCache_9.SPLITIO.split.p2__split', JSON.stringify(splitDeclarations.p2__split));
    localStorage.setItem('readyFromCache_9.SPLITIO.splits.filterQuery', '&names=p2__split&prefixes=p1');
    var splitio = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, baseConfig), {}, {
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_9'
      },
      urls: testUrls,
      sync: {
        splitFilters: [{
          type: 'byName',
          values: ['p3__split']
        }, {
          type: 'byPrefix',
          values: ['    p2', '   p2', '  p2', ' p2', 'no exist trim      ']
        }, {
          type: 'byName',
          values: ['no_exist', ' no exist trim     ']
        }]
      },
      debug: true
    }));
    var client = splitio.client();
    var manager = splitio.manager();
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.deepEqual(manager.names(), ['p2__split'], 'stored p1__split must be removed because doesn\'t match the filter');
    });
    client.once(client.Event.SDK_READY, function () {
      t.deepEqual(manager.names(), ['p3__split', 'p2__split'], 'active splits should be present for evaluation');
      client.destroy().then(function () {
        t.equal(localStorage.getItem('some_user_item'), 'user_item', 'user items at localStorage must not be changed');
        t.equal(localStorage.getItem('readyFromCache_9.SPLITIO.splits.till'), '1457552620999', 'splits.till must correspond to the till of the last successfully fetched Splits');
        t.equal(localStorage.getItem('readyFromCache_9.SPLITIO.split.p2__split'), JSON.stringify(splitDeclarations.p2__split), 'split declarations must be cached');
        t.equal(localStorage.getItem('readyFromCache_9.SPLITIO.split.p3__split'), JSON.stringify(splitDeclarations.p3__split), 'split declarations must be cached');
        t.equal(localStorage.getItem('readyFromCache_9.SPLITIO.splits.filterQuery'), '&names=no%20exist%20trim,no_exist,p3__split&prefixes=no%20exist%20trim,p2', 'splits.filterQuery must correspond to the split filter query');
        t.end();
      });
    });
  });
}