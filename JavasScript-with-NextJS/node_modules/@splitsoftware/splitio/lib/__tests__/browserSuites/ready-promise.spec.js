"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = readyPromiseAssertions;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _sinon = _interopRequireDefault(require("sinon"));

var _testUtils = require("../testUtils");

var _ = require("../..");

var _splitchangesSince = _interopRequireDefault(require("../mocks/splitchanges.since.-1.json"));

var _mysegmentsFacundoSplitIo = _interopRequireDefault(require("../mocks/mysegments.facundo@split.io.json"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function fromSecondsToMillis(n) {
  return Math.round(n * 1000);
}

var consoleSpy = {
  log: _sinon.default.spy(console, 'log'),
  error: _sinon.default.spy(console, 'error')
};
var baseConfig = {
  core: {
    authorizationKey: '<fake-token-3>',
    key: 'facundo@split.io'
  },
  debug: 'WARN',
  streamingEnabled: false
};

function assertGetTreatmentWhenReady(assert, client) {
  assert.equal(client.getTreatment('hierarchical_splits_test'), 'on', 'We should get an evaluation if client is ready.');
}

function assertGetTreatmentControlNotReady(assert, client) {
  consoleSpy.log.resetHistory();
  assert.equal(client.getTreatment('hierarchical_splits_test'), 'control', 'We should get control if client is not ready.');
  assert.true(consoleSpy.log.calledWithExactly('[WARN]  getTreatment: the SDK is not ready, results may be incorrect. Make sure to wait for SDK readiness before using this method.'), 'Telling us that calling getTreatment would return CONTROL since SDK is not ready at this point.');
}

function assertGetTreatmentControlNotReadyOnDestroy(assert, client) {
  consoleSpy.log.resetHistory();
  assert.equal(client.getTreatment('hierarchical_splits_test'), 'control', 'We should get control if client has been destroyed.');
  assert.true(consoleSpy.log.calledWithExactly('[ERROR] Client has already been destroyed - no calls possible.'), 'Telling us that client has been destroyed. Calling getTreatment would return CONTROL.');
}
/* Validate readiness state transitions, warning and error messages when using ready promises. */


function readyPromiseAssertions(fetchMock, assert) {
  // Timeout with retry attempt. Timeout is triggered even when it is longer than the request time, since the first and retry requests take more than the 'requestTimeoutBeforeReady' limit.
  assert.test(function (t) {
    var config = _objectSpread(_objectSpread({}, baseConfig), {}, {
      urls: {
        sdk: 'https://sdk.baseurl/readyPromise1',
        events: 'https://events.baseurl/readyPromise1'
      },
      startup: {
        readyTimeout: 0.15,
        requestTimeoutBeforeReady: 0.05,
        retriesOnFailureBeforeReady: 1
      }
    }); // /splitChanges takes longer than 'requestTimeoutBeforeReady' in both attempts


    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) + 20
    });
    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) + 20
    });
    fetchMock.get(config.urls.sdk + '/mySegments/facundo%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.postOnce(config.urls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(config.urls.events + '/testImpressions/count', 200);
    var splitio = (0, _.SplitFactory)(config);
    var client = splitio.client();
    client.ready().then(function () {
      t.fail('### SDK IS READY - not TIMED OUT when it should.');
    }).catch(function () {
      t.pass('### SDK TIMED OUT - Requests took longer than we allowed per requestTimeoutBeforeReady on both attempts, timed out.');
      assertGetTreatmentControlNotReady(t, client);
      client.destroy().then(function () {
        client.ready().then(function () {
          t.fail('### SDK IS READY - It should not in this scenario.');
          t.end();
        }).catch(function () {
          t.pass('### SDK IS READY - the promise remains rejected after client destruction.');
          assertGetTreatmentControlNotReadyOnDestroy(t, client);
          t.end();
        });
      });
    });
  }, 'Timeout with a retry attempt'); // Ready with retry attempt. The retry attempt is below the 'requestTimeoutBeforeReady' limit.

  assert.test(function (t) {
    var config = _objectSpread(_objectSpread({}, baseConfig), {}, {
      urls: {
        sdk: 'https://sdk.baseurl/readyPromise2',
        events: 'https://events.baseurl/readyPromise2'
      },
      startup: {
        readyTimeout: 0.15,
        requestTimeoutBeforeReady: 0.05,
        retriesOnFailureBeforeReady: 1
      }
    }); // /splitChanges takes longer than 'requestTimeoutBeforeReady' only for the first attempt


    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) + 20
    });
    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.get(config.urls.sdk + '/mySegments/facundo%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.postOnce(config.urls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(config.urls.events + '/testImpressions/count', 200);
    var splitio = (0, _.SplitFactory)(config);
    var client = splitio.client(); // In this case, we use the manager instead of the client to get the ready promise

    var manager = splitio.manager();
    manager.ready().then(function () {
      t.pass('### SDK IS READY - the retry request is under the limits.');
      assertGetTreatmentWhenReady(t, client);
      client.destroy().then(function () {
        client.ready().then(function () {
          t.pass('### SDK IS READY - the promise remains resolved after client destruction.');
          assertGetTreatmentControlNotReadyOnDestroy(t, client);
          t.end();
        }).catch(function () {
          t.fail('### SDK TIMED OUT - It should not in this scenario.');
          t.end();
        });
      });
    }).catch(function () {
      t.fail('### SDK TIMED OUT - It should not in this scenario');
    });
  }, 'Ready with retry attempt. The retry attempt is below the limit.'); // Time out and then ready after retry attempt. Time out is triggered, but the retry attempt is below the 'requestTimeoutBeforeReady' limit.

  assert.test(function (t) {
    var config = _objectSpread(_objectSpread({}, baseConfig), {}, {
      urls: {
        sdk: 'https://sdk.baseurl/readyPromise3',
        events: 'https://events.baseurl/readyPromise3'
      },
      startup: {
        readyTimeout: 0.15,
        requestTimeoutBeforeReady: 0.1,
        retriesOnFailureBeforeReady: 1
      }
    }); // /splitChanges takes longer than 'requestTimeoutBeforeReady' only for the first attempt


    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) + 20
    });
    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.get(config.urls.sdk + '/mySegments/facundo%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.postOnce(config.urls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(config.urls.events + '/testImpressions/count', 200);
    var splitio = (0, _.SplitFactory)(config);
    var client = splitio.client();
    client.ready().then(function () {
      t.fail('### SDK IS READY - not TIMED OUT when it should.');
    }).catch(function () {
      t.pass('### SDK TIMED OUT - time out is triggered before retry attempt finishes');
      assertGetTreatmentControlNotReady(t, client);
      setTimeout(function () {
        client.ready().then(function () {
          t.pass('### SDK IS READY - retry attempt finishes before the requestTimeoutBeforeReady limit');
          assertGetTreatmentWhenReady(t, client);
          client.destroy().then(function () {
            client.ready().then(function () {
              t.pass('### SDK IS READY - the promise remains resolved after client destruction.');
              assertGetTreatmentControlNotReadyOnDestroy(t, client);
              t.end();
            }).catch(function () {
              t.fail('### SDK TIMED OUT - It should not in this scenario.');
              t.end();
            });
          });
        }, function () {
          t.fail('### SDK TIMED OUT - It should not in this scenario');
        });
      }, fromSecondsToMillis(0.1));
    });
  }, 'Time out and then ready after retry attempt'); // Time out and then ready after scheduled refresh. Time out is triggered, but the state changes into ready after refresh (include assert on shared client)

  assert.test(function (t) {
    var config = _objectSpread(_objectSpread({}, baseConfig), {}, {
      urls: {
        sdk: 'https://sdk.baseurl/readyPromise4',
        events: 'https://events.baseurl/readyPromise4'
      },
      scheduler: {
        featuresRefreshRate: 0.25,
        segmentsRefreshRate: 0.25
      },
      startup: {
        readyTimeout: 0.2,
        requestTimeoutBeforeReady: 0.1,
        retriesOnFailureBeforeReady: 1
      }
    }); // time of the 3rd request (in milliseconds)


    var refreshTimeMillis = 50; // time difference between TIME OUT and IS READY events (in milliseconds)

    var diffTimeoutAndIsReady = fromSecondsToMillis(config.startup.requestTimeoutBeforeReady * (config.startup.retriesOnFailureBeforeReady + 1) + config.scheduler.featuresRefreshRate - config.startup.readyTimeout) + refreshTimeMillis; // /splitChanges takes longer than 'requestTimeoutBeforeReady' in both initial attempts

    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) + 20
    });
    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) + 20
    });
    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: refreshTimeMillis
    }); // main client endpoint configured to fetch segments before request timeout

    fetchMock.get(config.urls.sdk + '/mySegments/facundo%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.get(config.urls.sdk + '/splitChanges?since=1457552620999', {
      splits: [],
      since: 1457552620999,
      till: 1457552620999
    }); // shared client endpoint configured to fetch segments immediately, in order to emit SDK_READY as soon as splits arrives

    fetchMock.get(config.urls.sdk + '/mySegments/nicolas%40split.io', _mysegmentsFacundoSplitIo.default); // shared client endpoint configured to emit SDK_READY_TIMED_OUT

    fetchMock.get(config.urls.sdk + '/mySegments/emiliano%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.readyTimeout) + 20
    });
    fetchMock.postOnce(config.urls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(config.urls.events + '/testImpressions/count', 200);
    var splitio = (0, _.SplitFactory)(config);
    var client = splitio.client();
    var nicolasClient = splitio.client('nicolas@split.io');
    client.ready().then(function () {
      t.fail('### SDK IS READY - not TIMED OUT when it should.');
    }).catch(function () {
      t.pass('### SDK TIMED OUT - Requests took longer than we allowed per requestTimeoutBeforeReady on both attempts, timed out.');
      assertGetTreatmentControlNotReady(t, client);
      client.on(client.Event.SDK_READY, function () {
        client.ready().then(function () {
          t.pass('### SDK IS READY - the scheduled refresh changes the client state into "ready"');
          assertGetTreatmentWhenReady(t, client);
          var tStart = Date.now();
          nicolasClient.ready().then(function () {
            var delta = Date.now() - tStart;
            t.true((0, _testUtils.nearlyEqual)(delta, 0), 'shared client is ready as soon as main client is ready (i.e., splits have arrived)');
            var timeoutClient = splitio.client('emiliano@split.io');
            timeoutClient.ready().then(undefined, function () {
              // setting onRejected handler via `then` method
              t.pass('### Shared client TIMED OUT - promise rejected since mySegments fetch took more time than readyTimeout');
              timeoutClient.ready().catch(function () {
                // setting onRejected handler via `catch` method
                t.pass('### Shared client TIMED OUT - promise keeps being rejected');
                timeoutClient.on(timeoutClient.Event.SDK_READY, function () {
                  timeoutClient.ready().then(function () {
                    t.pass('### Shared client READY - `ready` returns a new resolved promise');
                    Promise.all([timeoutClient.destroy(), nicolasClient.destroy(), client.destroy()]).then(function () {
                      client.ready().then(function () {
                        t.pass('### SDK IS READY - the promise remains resolved after client destruction.');
                        assertGetTreatmentControlNotReadyOnDestroy(t, client);
                        t.end();
                      }).catch(function () {
                        t.fail('### SDK TIMED OUT - It should not in this scenario.');
                        t.end();
                      });
                    });
                  });
                });
              });
            });
          }, function () {
            t.fail('### SDK TIMED OUT - It should not in this scenario');
          });
        }, diffTimeoutAndIsReady + 20);
      });
    });
  }, 'Time out and then ready after scheduled refresh (include assert on shared client)'); // Validate fallback to 'catch' callback when exception is thrown on 'then' onRejected callback.

  assert.test(function (t) {
    var config = _objectSpread(_objectSpread({}, baseConfig), {}, {
      urls: {
        sdk: 'https://sdk.baseurl/readyPromise5',
        events: 'https://events.baseurl/readyPromise5'
      },
      startup: {
        readyTimeout: 0.1,
        requestTimeoutBeforeReady: 0.05,
        retriesOnFailureBeforeReady: 0
      }
    }); // /splitChanges takes longer than 'requestTimeoutBeforeReady'


    fetchMock.get(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) + 20
    });
    fetchMock.get(config.urls.sdk + '/mySegments/facundo%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.postOnce(config.urls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(config.urls.events + '/testImpressions/count', 200);
    var splitio = (0, _.SplitFactory)(config);
    var client = splitio.client();
    client.ready().then(function () {
      t.fail('### SDK IS READY - not TIMED OUT when it should.');
      client.destroy().then(function () {
        t.end();
      });
    }, function () {
      t.pass('### SDK TIMED OUT - Request tooks longer than we allowed per requestTimeoutBeforeReady, timed out.');
      assertGetTreatmentControlNotReady(t, client);
      throw 'error';
    }).catch(function (error) {
      t.equal(error, 'error', '### Handled thrown exception on onRejected callback.');
      client.destroy().then(function () {
        client.ready().then(function () {
          t.fail('### SDK IS READY - It should not in this scenario.');
          t.end();
        }).catch(function () {
          t.pass('### SDK TIME OUT - the promise remains rejected after client destruction.');
          assertGetTreatmentControlNotReadyOnDestroy(t, client);
          t.end();
        });
      });
    });
  }, 'Basic "time out" test with exception on onRejected callback.'); // Validate fallback to 'catch' callback when exception is thrown on 'then' onResolved callback.

  assert.test(function (t) {
    var config = _objectSpread(_objectSpread({}, baseConfig), {}, {
      urls: {
        sdk: 'https://sdk.baseurl/readyPromise6',
        events: 'https://events.baseurl/readyPromise6'
      },
      startup: {
        readyTimeout: 0.1,
        requestTimeoutBeforeReady: 0.05,
        retriesOnFailureBeforeReady: 0
      }
    }); // Both /splitChanges and /mySegments take less than 'requestTimeoutBeforeReady'


    fetchMock.get(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.get(config.urls.sdk + '/mySegments/facundo%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.postOnce(config.urls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(config.urls.events + '/testImpressions/count', 200);
    var splitio = (0, _.SplitFactory)(config);
    var client = splitio.client();
    client.ready().then(function () {
      t.pass('### SDK IS READY as it should, request is under the limits.');
      assertGetTreatmentWhenReady(t, client);
      throw 'error';
    }).catch(function (error) {
      t.equal(error, 'error', '### Handled thrown exception on onRejected callback.');
      client.destroy().then(function () {
        client.ready().then(function () {
          t.pass('### SDK IS READY - the promise remains resolved after client destruction.');
          assertGetTreatmentControlNotReadyOnDestroy(t, client);
          t.end();
        }).catch(function () {
          t.fail('### SDK TIMED OUT - It should not in this scenario.');
          t.end();
        });
      });
    });
  }, 'Basic "is ready" test with exception on onResolved callback'); // Validate that multiple promises are resolved/rejected on expected times.

  assert.test(function (t) {
    var config = _objectSpread(_objectSpread({}, baseConfig), {}, {
      urls: {
        sdk: 'https://sdk.baseurl/readyPromise7',
        events: 'https://events.baseurl/readyPromise7'
      },
      startup: {
        readyTimeout: 0.15,
        requestTimeoutBeforeReady: 0.1,
        retriesOnFailureBeforeReady: 1
      }
    }); // /splitChanges takes longer than 'requestTimeoutBeforeReady' only for the first attempt


    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) + 20
    });
    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.get(config.urls.sdk + '/mySegments/facundo%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.postOnce(config.urls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(config.urls.events + '/testImpressions/count', 200);
    var splitio = (0, _.SplitFactory)(config);
    var client = splitio.client(); // We also use the manager to get some of the promises

    var manager = splitio.manager(); // promise1 is handled inmediately. Thus, the 'reject' callback is expected to be called in 0.15 seconds aprox.

    setTimeout(function () {
      var promise1 = client.ready();
      var tStart = Date.now();
      promise1.then(function () {
        t.fail('### SDK IS READY - not TIMED OUT when it should.');
      }).catch(function () {
        t.pass('### SDK TIMED OUT - time out is triggered before retry attempt finishes');
        assertGetTreatmentControlNotReady(t, client);
        var tDelta = Date.now() - tStart;
        assert.ok(tDelta < fromSecondsToMillis(config.startup.readyTimeout) + 20 && tDelta > fromSecondsToMillis(config.startup.readyTimeout) - 20, 'The "reject" callback is expected to be called in 0.15 seconds aprox');
      });
    }, 0); // promise2 is handled in 0.15 seconds, when the promise is just rejected. Thus, the 'reject' callback is expected to be called inmediately (0 seconds aprox).

    setTimeout(function () {
      var promise2 = manager.ready();
      var tStart = Date.now();
      promise2.then(function () {
        t.fail('### SDK IS READY - not TIMED OUT when it should.');
      }).catch(function () {
        t.pass('### SDK TIMED OUT - time out is triggered before retry attempt finishes');
        assertGetTreatmentControlNotReady(t, client);
        var tDelta = Date.now() - tStart;
        assert.ok(tDelta < 20, 'The "reject" callback is expected to be called inmediately (0 seconds aprox).');
      });
    }, fromSecondsToMillis(0.15)); // promise3 is handled in 0.2 seconds, when the promise is just resolved. Thus, the 'resolve' callback is expected to be called inmediately (0 seconds aprox).

    setTimeout(function () {
      var promise3 = manager.ready();
      var tStart = Date.now();
      promise3.then(function () {
        t.pass('### SDK IS READY - retry attempt finishes before the requestTimeoutBeforeReady limit');
        assertGetTreatmentWhenReady(t, client);
        var tDelta = Date.now() - tStart;
        assert.ok(tDelta < 20, 'The "resolve" callback is expected to be called inmediately (0 seconds aprox).');
        return Promise.resolve();
      }, function () {
        t.fail('### SDK TIMED OUT - It should not in this scenario');
        return Promise.resolve();
      }).then(function () {
        client.destroy().then(function () {
          client.ready().then(function () {
            t.pass('### SDK IS READY - the promise remains resolved after client destruction.');
            assertGetTreatmentControlNotReadyOnDestroy(t, client);
            t.end();
          }).catch(function () {
            t.fail('### SDK TIMED OUT - It should not in this scenario.');
            t.end();
          });
        });
      });
    }, fromSecondsToMillis(0.2));
  }, 'Evaluate that multiple promises are resolved/rejected on expected times.'); // Validate that warning messages are properly sent.

  assert.test(function (t) {
    var config = _objectSpread(_objectSpread({}, baseConfig), {}, {
      urls: {
        sdk: 'https://sdk.baseurl/readyPromise8',
        events: 'https://events.baseurl/readyPromise8'
      },
      startup: {
        readyTimeout: 0.15,
        requestTimeoutBeforeReady: 0.1,
        retriesOnFailureBeforeReady: 1
      }
    }); // /splitChanges takes longer than 'requestTimeoutBeforeReady' only for the first attempt


    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) + 20
    });
    fetchMock.getOnce(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.get(config.urls.sdk + '/mySegments/facundo%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.get(config.urls.sdk + '/mySegments/nicolas%40split.io', _mysegmentsFacundoSplitIo.default);
    fetchMock.get(config.urls.sdk + '/mySegments/emiliano%40split.io', _mysegmentsFacundoSplitIo.default);
    fetchMock.postOnce(config.urls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(config.urls.events + '/testImpressions/count', 200);
    var splitio = (0, _.SplitFactory)(config);

    var onReadycallback = function onReadycallback() {}; // We invoke the ready method and also add and remove SDK_READY event listeners using the client and manager instances


    var client = splitio.client();
    client.ready();
    client.on(client.Event.SDK_READY, onReadycallback);
    client.off(client.Event.SDK_READY, onReadycallback);
    var manager = splitio.manager();
    manager.ready();
    manager.on(manager.Event.SDK_READY, onReadycallback);
    manager.off(manager.Event.SDK_READY, onReadycallback);
    consoleSpy.log.resetHistory();
    setTimeout(function () {
      client.ready();
      assertGetTreatmentWhenReady(t, client);
      t.true(consoleSpy.log.calledWithExactly('[WARN]  No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.'), 'Warning that there are not listeners for SDK_READY event'); // assert error messages when adding event listeners after SDK has already triggered them

      consoleSpy.log.resetHistory();
      client.on(client.Event.SDK_READY, function () {});
      client.on(client.Event.SDK_READY_TIMED_OUT, function () {});
      t.true(consoleSpy.log.calledWithExactly('[ERROR] A listener was added for SDK_READY on the SDK, which has already fired and won\'t be emitted again. The callback won\'t be executed.'), 'Logging error that a listeners for SDK_READY event was added after triggered');
      t.true(consoleSpy.log.calledWithExactly('[ERROR] A listener was added for SDK_READY_TIMED_OUT on the SDK, which has already fired and won\'t be emitted again. The callback won\'t be executed.'), 'Logging error that a listeners for SDK_READY_TIMED_OUT event was added after triggered'); // assert 'No listener warning' on shared clients

      consoleSpy.log.resetHistory();
      var sharedClientWithCb = splitio.client('nicolas@split.io');
      sharedClientWithCb.on(client.Event.SDK_READY, function () {
        t.false(consoleSpy.log.calledWithExactly('[WARN]  No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.'), 'No warning logged'); // eslint-disable-next-line no-unused-vars

        var sharedClientWithoutCb = splitio.client('emiliano@split.io');
        setTimeout(function () {
          t.true(consoleSpy.log.calledWithExactly('[WARN]  No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.'), 'Warning logged');
          client.destroy().then(function () {
            client.ready().then(function () {
              t.pass('### SDK IS READY - the promise remains resolved after client destruction.');
              assertGetTreatmentControlNotReadyOnDestroy(t, client);
              t.end();
            }).catch(function () {
              t.fail('### SDK TIMED OUT - It should not in this scenario.');
              t.end();
            });
          });
        }, 0);
      });
    }, fromSecondsToMillis(0.2));
  }, 'Validate that warning messages are properly sent'); // Time out event is not handled. Ready promise should not be resolved (include assert on shared client)

  assert.test(function (t) {
    var config = _objectSpread(_objectSpread({}, baseConfig), {}, {
      urls: {
        sdk: 'https://sdk.baseurl/readyPromise9',
        events: 'https://events.baseurl/readyPromise9'
      },
      startup: {
        readyTimeout: 0.1,
        // We use a short ready timeout to don't extend to much the test
        requestTimeoutBeforeReady: 0.05,
        retriesOnFailureBeforeReady: 0
      }
    }); // /splitChanges takes longer than 'requestTimeoutBeforeReady'


    fetchMock.get(config.urls.sdk + '/splitChanges?since=-1', _splitchangesSince.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) + 20
    });
    fetchMock.get(config.urls.sdk + '/mySegments/facundo%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.get(config.urls.sdk + '/mySegments/nicolas%40split.io', _mysegmentsFacundoSplitIo.default, {
      delay: fromSecondsToMillis(config.startup.requestTimeoutBeforeReady) - 20
    });
    fetchMock.postOnce(config.urls.events + '/testImpressions/bulk', 200);
    fetchMock.postOnce(config.urls.events + '/testImpressions/count', 200);
    var splitio = (0, _.SplitFactory)(config);
    var client = splitio.client();
    var otherClient = splitio.client('nicolas@split.io'); // Assert getTreatment return CONTROL and trigger warning when SDK is not ready yet

    assertGetTreatmentControlNotReady(t, client);
    client.ready().then(function () {
      t.fail('### SDK IS READY - not TIMED OUT when it should.');
    });
    otherClient.ready().then(function () {
      t.fail('### SDK IS READY - not TIMED OUT when it should.');
    });
    setTimeout(function () {
      Promise.all([client.destroy(), otherClient.destroy()]).then(function () {
        client.ready().then(function () {
          t.fail('### SDK IS READY - It should not in this scenario.');
          t.end();
        }).catch(function () {
          t.pass('### SDK IS READY - the promise remains rejected after client destruction.');
          assertGetTreatmentControlNotReadyOnDestroy(t, client);
          t.end();
        });
      });
    }, fromSecondsToMillis(config.startup.readyTimeout) + 20);
  }, 'Time out event is not handled. Ready promise should not be resolved (include assert on shared client)'); // Other possible tests:
  //  * Basic time out path: startup without retries on failure and response taking more than 'requestTimeoutBeforeReady'.
  //  * Basic is ready path: startup without retries on failure and response taking less than 'requestTimeoutBeforeReady'.
  //  * Ready with retry attempts and refresh.
  //  * Ready after timeout with retry attempts and refresh.
}