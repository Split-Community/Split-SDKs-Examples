"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _ = require("../../");

var _settings = _interopRequireDefault(require("../../utils/settings"));

var settings = (0, _settings.default)({
  core: {
    key: 'asd'
  },
  streamingEnabled: false
});

function _default(startWithTT, fetchMock, assert) {
  // mocking mySegments endpoints with delays for new clients
  fetchMock.get(settings.url('/mySegments/emiliano%2Fsplit.io'), {
    status: 200,
    body: {
      mySegments: []
    }
  }, {
    delay: 100
  });
  fetchMock.get(settings.url('/mySegments/matias%25split.io'), {
    status: 200,
    body: {
      mySegments: []
    }
  }, {
    delay: 200
  });
  var factory = (0, _.SplitFactory)({
    core: {
      authorizationKey: 'dummy',
      key: 'facundo@split.io',
      trafficType: startWithTT ? 'start_tt' : undefined
    },
    startup: {
      eventsFirstPushWindow: 3,
      readyTimeout: 0.15
    },
    streamingEnabled: false
  });
  var mainClient = factory.client();
  assert.equal(mainClient, factory.client(), 'If we call factory.client() (no params) more than once, it is just a get of the main client.');
  assert.equal(mainClient, factory.client('facundo@split.io', startWithTT ? 'start_tt' : undefined), 'If we call factory.client() with params matching what was passed on the configuration, it is just a get of the main client still.');
  var nicolasClient = factory.client('nicolas@split.io', 'nico_tt');
  var marcioClient = factory.client('marcio@split.io');
  var emilianoClient = factory.client('emiliano/split.io');
  var matiasClient = factory.client('matias%split.io');
  assert.throws(factory.client.bind(factory, null), 'Calling factory.client() with a key parameter that is not a valid key should throw.');
  assert.throws(factory.client.bind(factory, {}), 'Calling factory.client() with a key parameter that is not a valid key should throw.');
  assert.throws(factory.client.bind(factory, 'validKey', null), 'Calling factory.client() with a traffic type parameter that is not a valid should throw.');
  assert.throws(factory.client.bind(factory, 'validKey', []), 'Calling factory.client() with a traffic type parameter that is not a valid should throw.'); // Used for wrapping up test when we should

  var finished = /*#__PURE__*/_regenerator.default.mark(function f() {
    return _regenerator.default.wrap(function f$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return;

          case 2:
            _context.next = 4;
            return;

          case 4:
            _context.next = 6;
            return;

          case 6:
            _context.next = 8;
            return;

          case 8:
            _context.next = 10;
            return;

          case 10:
            _context.next = 12;
            return;

          case 12:
            _context.next = 14;
            return;

          case 14:
            _context.next = 16;
            return;

          case 16:
            _context.next = 18;
            return;

          case 18:
            _context.next = 20;
            return;

          case 20:
            _context.next = 22;
            return;

          case 22:
            _context.next = 24;
            return;

          case 24:
            _context.next = 26;
            return;

          case 26:
            marcioClient.destroy();
            nicolasClient.destroy();
            mainClient.destroy();
            emilianoClient.destroy();
            matiasClient.destroy();
            assert.end();

          case 32:
          case "end":
            return _context.stop();
        }
      }
    }, f);
  })();
  /**
   * Assertion suite for client.getTreatment() & client.getTreatments()
   */


  var getTreatmentsAssertions = /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(client, expect) {
      return _regenerator.default.wrap(function _callee$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.t0 = assert;
              _context2.next = 3;
              return client.getTreatment('always_off');

            case 3:
              _context2.t1 = _context2.sent;
              _context2.t2 = expect[0];

              _context2.t0.equal.call(_context2.t0, _context2.t1, _context2.t2, 'Shared client evaluations should be correct.');

              _context2.t3 = assert;
              _context2.next = 9;
              return client.getTreatment('always_on');

            case 9:
              _context2.t4 = _context2.sent;
              _context2.t5 = expect[1];

              _context2.t3.equal.call(_context2.t3, _context2.t4, _context2.t5, 'Shared client evaluations should be correct.');

              _context2.t6 = assert;
              _context2.next = 15;
              return client.getTreatment('splitters');

            case 15:
              _context2.t7 = _context2.sent;
              _context2.t8 = expect[2];

              _context2.t6.equal.call(_context2.t6, _context2.t7, _context2.t8, 'Shared client evaluations should be correct.');

              _context2.t9 = assert;
              _context2.next = 21;
              return client.getTreatment('developers');

            case 21:
              _context2.t10 = _context2.sent;
              _context2.t11 = expect[3];

              _context2.t9.equal.call(_context2.t9, _context2.t10, _context2.t11, 'Shared client evaluations should be correct.');

              _context2.t12 = assert;
              _context2.next = 27;
              return client.getTreatment('not_exists');

            case 27:
              _context2.t13 = _context2.sent;

              _context2.t12.equal.call(_context2.t12, _context2.t13, 'control', 'Shared client evaluations should be correct.');

              _context2.t14 = assert;
              _context2.next = 32;
              return client.getTreatments(['always_off', 'always_on', 'splitters', 'developers', 'not_exists']);

            case 32:
              _context2.t15 = _context2.sent;
              _context2.t16 = {
                'always_off': expect[0],
                'always_on': expect[1],
                'splitters': expect[2],
                'developers': expect[3],
                'not_exists': 'control'
              };

              _context2.t14.deepEqual.call(_context2.t14, _context2.t15, _context2.t16, 'Shared client evaluations should be correct.');

              finished.next();

            case 36:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee);
    }));

    return function getTreatmentsAssertions(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  /**
   * Assertion suite for client.track()
   */


  var trackAssertions = function trackAssertions() {
    // Prepare the mock to check for events having correct values
    fetchMock.postOnce(settings.url('/events/bulk'), function (url, opts) {
      var events = JSON.parse(opts.body);
      assert.equal(events.length, 3, 'Tracked only valid events');
      assert.equal(events[0].trafficTypeName, "".concat(startWithTT ? 'start' : 'main', "_tt"), 'matching traffic types both binded and provided through client.track()');
      assert.equal(events[1].trafficTypeName, 'nico_tt', 'matching traffic types both binded and provided through client.track()');
      assert.equal(events[2].trafficTypeName, 'marcio_tt', 'matching traffic types both binded and provided through client.track()');
      finished.next();
      return 200;
    });

    if (startWithTT) {
      assert.true(mainClient.track('myEvent', 10), 'If we specified the TT via settings, we should be able to track events without passing it as param');
    } else {
      assert.false(mainClient.track('myEvent'), 'If we have not specified TT via settings, it should be required on client.track()');
      assert.true(mainClient.track('main_tt', 'myEvent', 10), 'If we have not specified TT via settings, it should be required on client.track()');
    } // Shared instance with TT on instantiation


    assert.true(nicolasClient.track('nicoEvent', 10), 'If a shared client was created passing both key and TT, the latter gets binded to it so it is not necessary to provide the traffic type to client.track()'); // Shared instance without TT on instantiation

    assert.false(marcioClient.track('marcioEvent'), 'If a shared client was created passing only key, no traffic type is binded so we need to provide one for client.track()');
    assert.true(marcioClient.track('marcio_tt', 'marcioEvent', 10), 'If a shared client was created passing only key, no traffic type is binded so we need to provide one for client.track()');
  };
  /* Assert initial state */


  assert.notEqual(mainClient.ready, nicolasClient.ready, 'Shared clients should have their own ready promise.');
  assert.notEqual(mainClient.ready, marcioClient.ready, 'Shared clients should have their own ready promise.');
  assert.notEqual(nicolasClient.ready, marcioClient.ready, 'Shared clients should have their own ready promise.');
  /* Assert client.track(), no need to wait for ready. */

  trackAssertions();
  /* Assert getTreatment/s */

  var expectControls = ['control', 'control', 'control', 'control']; // If main is not ready and returning controls, they all return controls.

  getTreatmentsAssertions(mainClient, expectControls);
  getTreatmentsAssertions(nicolasClient, expectControls);
  getTreatmentsAssertions(marcioClient, expectControls);
  getTreatmentsAssertions(emilianoClient, expectControls); // Each client is ready when splits and its segments are fetched

  mainClient.ready().then(function () {
    assert.comment('Main instance - facundo@split.io');
    getTreatmentsAssertions(mainClient, ['off', 'on', 'on', 'off']);
    getTreatmentsAssertions(emilianoClient, expectControls);
    emilianoClient.ready().then(function () {
      assert.comment('Shared instance - emiliano/split.io');
      getTreatmentsAssertions(emilianoClient, ['off', 'on', 'off', 'off']);
    });
  });
  nicolasClient.ready().then(function () {
    assert.comment('Shared instance - nicolas@split.io');
    getTreatmentsAssertions(nicolasClient, ['off', 'on', 'off', 'on']);
  });
  marcioClient.ready().then(function () {
    assert.comment('Shared instance - marcio@split.io');
    getTreatmentsAssertions(marcioClient, ['off', 'on', 'off', 'off']);
  });
  matiasClient.on(matiasClient.Event.SDK_READY_TIMED_OUT, function () {
    getTreatmentsAssertions(matiasClient, expectControls);
  });
  matiasClient.ready().catch(function () {
    matiasClient.on(matiasClient.Event.SDK_READY, function () {
      getTreatmentsAssertions(matiasClient, ['off', 'on', 'off', 'off']);
      matiasClient.ready().then(function () {
        assert.comment('Shared instance - matias%split.io');
        getTreatmentsAssertions(matiasClient, ['off', 'on', 'off', 'off']);
      });
    });
    assert.comment('Shared instance - matias%split.io');
    getTreatmentsAssertions(matiasClient, expectControls);
  });
}