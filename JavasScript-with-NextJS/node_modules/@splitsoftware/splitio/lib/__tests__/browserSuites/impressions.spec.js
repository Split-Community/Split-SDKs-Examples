"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _ = require("../../");

var _settings = _interopRequireDefault(require("../../utils/settings"));

var _splitchangesSince = _interopRequireDefault(require("../mocks/splitchanges.since.-1.json"));

var _splitchangesSince2 = _interopRequireDefault(require("../mocks/splitchanges.since.1457552620999.json"));

var _mysegmentsFacundoSplitIo = _interopRequireDefault(require("../mocks/mysegments.facundo@split.io.json"));

var _constants = require("../../utils/constants");

var _time = require("../../utils/time");

var baseUrls = {
  sdk: 'https://sdk.baseurl/impressionsSuite',
  events: 'https://events.baseurl/impressionsSuite'
};
var settings = (0, _settings.default)({
  core: {
    key: 'asd'
  },
  urls: baseUrls,
  streamingEnabled: false
});
var truncatedTimeFrame;

function _default(fetchMock, assert) {
  // Mocking this specific route to make sure we only get the items we want to test from the handlers.
  fetchMock.getOnce(settings.url('/splitChanges?since=-1'), {
    status: 200,
    body: _splitchangesSince.default
  });
  fetchMock.get(settings.url('/splitChanges?since=1457552620999'), {
    status: 200,
    body: _splitchangesSince2.default
  });
  fetchMock.get(settings.url('/mySegments/facundo%40split.io'), {
    status: 200,
    body: _mysegmentsFacundoSplitIo.default
  });
  var splitio = (0, _.SplitFactory)({
    core: {
      authorizationKey: '<some-token>',
      key: 'facundo@split.io'
    },
    scheduler: {
      featuresRefreshRate: 0.5,
      segmentsRefreshRate: 0.5,
      metricsRefreshRate: 3000,
      impressionsRefreshRate: 0.5
    },
    startup: {
      eventsFirstPushWindow: 3000
    },
    urls: baseUrls,
    streamingEnabled: false
  });
  var client = splitio.client();

  var assertPayload = function assertPayload(req) {
    var resp = JSON.parse(req.body);
    assert.equal(resp.length, 2, 'We performed three evaluations so we should have 2 impressions type');
    var dependencyChildImpr = resp.filter(function (e) {
      return e.f === 'hierarchical_splits_test';
    })[0];
    var alwaysOnWithConfigImpr = resp.filter(function (e) {
      return e.f === 'split_with_config';
    })[0];
    assert.true(dependencyChildImpr, 'Split we wanted to evaluate should be present on the impressions.');
    assert.false(resp.some(function (e) {
      return e.f === 'hierarchical_dep_always_on';
    }), 'Parent split evaluations should not result in impressions.');
    assert.false(resp.some(function (e) {
      return e.f === 'hierarchical_dep_hierarchical';
    }), 'No matter how deep is the chain.');
    assert.true(alwaysOnWithConfigImpr, 'Split evaluated with config should have generated an impression too.');
    assert.false(Object.prototype.hasOwnProperty.call(alwaysOnWithConfigImpr.i[0], 'configuration'), 'Impressions do not change with configuration evaluations.');
    assert.false(Object.prototype.hasOwnProperty.call(alwaysOnWithConfigImpr.i[0], 'config'), 'Impressions do not change with configuration evaluations.');
    var _dependencyChildImpr$ = dependencyChildImpr.i[0],
        k = _dependencyChildImpr$.k,
        r = _dependencyChildImpr$.r,
        t = _dependencyChildImpr$.t;
    assert.equal(k, 'facundo@split.io', 'Present impression should have the correct key.'); // The label present on the mock.

    assert.equal(r, 'expected label', 'Present impression should have the correct label.');
    assert.equal(t, 'on', 'Present impression should have the correct treatment.');
  };

  fetchMock.postOnce(settings.url('/testImpressions/bulk'), function (url, req) {
    assertPayload(req);
    assert.comment('After a failure, Impressions will keep the data for the next call.');
    return 400;
  }); // Attach again to catch the retry.

  fetchMock.postOnce(settings.url('/testImpressions/bulk'), function (url, req) {
    assert.equal(req.headers.SplitSDKImpressionsMode, _constants.OPTIMIZED);
    assert.comment('We do one retry, so after a failed impressions post we will try once more.');
    assertPayload(req);
    client.destroy();
    assert.end();
    return 200;
  });
  fetchMock.postOnce(settings.url('/testImpressions/bulk'), 200);
  fetchMock.postOnce(settings.url('/testImpressions/count'), function (url, opts) {
    var data = JSON.parse(opts.body);
    assert.equal(data.pf.length, 2, 'We should generated 2 impressions count.'); // finding these validate the feature names collection too

    var dependencyChildImpr = data.pf.filter(function (e) {
      return e.f === 'hierarchical_splits_test';
    })[0];
    var alwaysOnWithConfigImpr = data.pf.filter(function (e) {
      return e.f === 'split_with_config';
    })[0];
    assert.equal(dependencyChildImpr.rc, 1);
    assert.equal((0, _typeof2.default)(dependencyChildImpr.m), 'number');
    assert.equal(dependencyChildImpr.m, truncatedTimeFrame);
    assert.equal(alwaysOnWithConfigImpr.rc, 3);
    assert.equal((0, _typeof2.default)(alwaysOnWithConfigImpr.m), 'number');
    assert.equal(alwaysOnWithConfigImpr.m, truncatedTimeFrame);
    return 200;
  });
  fetchMock.postOnce(settings.url('/testImpressions/count'), 200);
  client.ready().then(function () {
    truncatedTimeFrame = (0, _time.truncateTimeFrame)(Date.now()); // depends on hierarchical_dep_hierarchical which depends on hierarchical_dep_always_on

    assert.equal(client.getTreatment('hierarchical_splits_test'), 'on', 'We should get an evaluation as always.');
    assert.deepEqual(client.getTreatmentWithConfig('split_with_config'), {
      treatment: 'on',
      config: '{"color":"brown","dimensions":{"height":12,"width":14},"text":{"inner":"click me"}}'
    }, 'We should get an evaluation as always.');
    client.getTreatmentWithConfig('split_with_config');
    client.getTreatmentWithConfig('split_with_config');
  });
}