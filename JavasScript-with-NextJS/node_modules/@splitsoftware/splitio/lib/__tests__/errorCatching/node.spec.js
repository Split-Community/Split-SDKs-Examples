"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _tape = _interopRequireDefault(require("tape"));

var _includes = _interopRequireDefault(require("lodash/includes"));

var _fetchMock = _interopRequireDefault(require("../testUtils/fetchMock"));

var _ = require("../../");

var _settings = _interopRequireDefault(require("../../utils/settings"));

var _splitChangesSince = _interopRequireDefault(require("./splitChanges.since.-1.json"));

var _splitChangesSince2 = _interopRequireDefault(require("./splitChanges.since.1500492097547.json"));

var _splitChangesSince3 = _interopRequireDefault(require("./splitChanges.since.1500492297547.json"));

// Here we are testing exceptions and the handler should be ours, we need to avoid tape-catch
// Option object used to configure mocked routes with a delay of 1.5 seconds.
var responseDelay = {
  delay: 1500
};
var settings = (0, _settings.default)({
  core: {
    authorizationKey: '<fake-token>'
  },
  streamingEnabled: false
});

_fetchMock.default.get(settings.url('/splitChanges?since=-1'), {
  status: 200,
  body: _splitChangesSince.default
}, responseDelay);

_fetchMock.default.get(settings.url('/splitChanges?since=1500492097547'), {
  status: 200,
  body: _splitChangesSince2.default
}, responseDelay);

_fetchMock.default.get(settings.url('/splitChanges?since=1500492297547'), {
  status: 200,
  body: _splitChangesSince3.default
}, responseDelay);

(0, _tape.default)('Error catching on callbacks', function (assert) {
  var assertionsPlanned = 3;
  var errCount = 0;
  var factory = (0, _.SplitFactory)({
    core: {
      authorizationKey: '<fake-token-1>'
    },
    startup: {
      eventsFirstPushWindow: 10000,
      readyTimeout: 1
    },
    scheduler: {
      featuresRefreshRate: 2,
      segmentsRefreshRate: 10000,
      metricsRefreshRate: 10000,
      impressionsRefreshRate: 10000,
      eventsPushRate: 10000
    },
    debug: false,
    streamingEnabled: false
  });
  var client = factory.client();
  client.once(client.Event.SDK_READY_TIMED_OUT, function () {
    null.willThrowForTimedOut();
  });
  client.once(client.Event.SDK_READY, function () {
    null.willThrowForReady();
  });
  client.once(client.Event.SDK_UPDATE, function () {
    null.willThrowForUpdate();
  });

  var exceptionHandler = function exceptionHandler(err) {
    if ((0, _includes.default)(err.message, 'willThrowFor')) {
      errCount++;
      assert.pass("But this should be loud, all should throw as Uncaught Exception: ".concat(err.message));

      if (errCount === assertionsPlanned) {
        process.off('uncaughException', exceptionHandler);
        client.destroy();

        _fetchMock.default.restore();

        assert.end();
      }
    }
  };

  process.on('uncaughtException', exceptionHandler);
});