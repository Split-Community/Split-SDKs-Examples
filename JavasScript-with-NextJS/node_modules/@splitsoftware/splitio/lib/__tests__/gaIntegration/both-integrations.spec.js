"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _ = require("../..");

var _settings = _interopRequireDefault(require("../../utils/settings"));

var _gaTestUtils = require("./gaTestUtils");

var _includes = _interopRequireDefault(require("lodash/includes"));

var _constants = require("../../utils/constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function countImpressions(parsedImpressionsBulkPayload) {
  return parsedImpressionsBulkPayload.reduce(function (accumulator, currentValue) {
    return accumulator + currentValue.i.length;
  }, 0);
}

var config = {
  core: {
    key: 'facundo@split.io',
    trafficType: 'user'
  },
  integrations: [{
    type: 'GOOGLE_ANALYTICS_TO_SPLIT'
  }, {
    type: 'SPLIT_TO_GOOGLE_ANALYTICS'
  }],
  streamingEnabled: false,
  sync: {
    impressionsMode: _constants.DEBUG
  }
};
var settings = (0, _settings.default)(config);

function _default(fetchMock, assert) {
  var client; // test default behavior of both integrations

  assert.test(function (t) {
    var customHits = [{
      hitType: 'pageview'
    }, {
      hitType: 'event'
    }];
    var splitTrackParams = [['some_event'], ['other_event'], ['another_event']];
    var splitGetTreatmentParams = [['hierarchical_splits_test']]; // Generator to synchronize the call of t.end() when both impressions and events endpoints were invoked.

    var finish = /*#__PURE__*/_regenerator.default.mark(function _callee() {
      var totalHits;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return;

            case 2:
              totalHits = customHits.length + splitTrackParams.length + splitGetTreatmentParams.length;
              t.equal(window.gaSpy.getHits().length, totalHits, 'Total hits');
              setTimeout(function () {
                client.destroy();
                t.end();
              }, 0);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })();

    fetchMock.postOnce(settings.url('/testImpressions/bulk'), function (url, opts) {
      // we can assert payload and ga hits, once ga is ready and after `SplitToGa.queue`, that is timeout wrapped, make to the queue stack.
      window.ga(function () {
        setTimeout(function () {
          try {
            var resp = JSON.parse(opts.body);
            var numberOfSentImpressions = countImpressions(resp);
            var sentImpressionHits = window.gaSpy.getHits().filter(function (hit) {
              return hit.eventCategory === 'split-impression';
            });
            t.equal(numberOfSentImpressions, splitGetTreatmentParams.length, 'Number of impressions');
            t.equal(sentImpressionHits.length, splitGetTreatmentParams.length, "Number of sent impression hits must be equal to the number of impressions (".concat(splitGetTreatmentParams.length, ")"));
            finish.next();
          } catch (err) {
            console.error(err);
          }
        });
      });
      return 200;
    });
    fetchMock.postOnce(settings.url('/events/bulk'), function (url, opts) {
      window.ga(function () {
        setTimeout(function () {
          try {
            var sentEvents = JSON.parse(opts.body);
            var sentEventsFromSplitToGa = sentEvents.filter(function (event) {
              return event.properties && event.properties.eventCategory && (0, _includes.default)(event.properties.eventCategory, 'split');
            });
            t.equal(sentEvents.length, splitTrackParams.length + customHits.length, 'Number of sent events is equal to custom events plus hits tracked as events');
            t.equal(sentEventsFromSplitToGa.length, 0, 'GA hits comming from Split-to-GA integration must not be tracked again as Split events');
            var sentHitsNoSplitData = window.gaSpy.getHits().filter(function (hit) {
              return !hit.eventCategory || !(0, _includes.default)(hit.eventCategory, 'split');
            });
            var sentHitsSplitEvents = window.gaSpy.getHits().filter(function (hit) {
              return hit.eventCategory === 'split-event';
            });
            t.equal(sentHitsNoSplitData.length, customHits.length, 'Number of custom hits');
            t.equal(sentHitsSplitEvents.length, splitTrackParams.length, 'Number of Split event hits');
            finish.next();
          } catch (err) {
            console.error(err);
          }
        });
      });
      return 200;
    });
    (0, _gaTestUtils.gaTag)(); // siteSpeedSampleRate set to 0 to never send a site speed timing hit

    window.ga('create', 'UA-00000000-1', 'auto', {
      siteSpeedSampleRate: 0
    });
    (0, _gaTestUtils.gaSpy)();
    window.ga('require', 'splitTracker');
    customHits.forEach(function (hit) {
      window.ga('send', hit);
    });
    var factory = (0, _.SplitFactory)(_objectSpread(_objectSpread({}, config), {}, {
      startup: {
        eventsFirstPushWindow: 0
      },
      scheduler: {
        impressionsRefreshRate: 1,
        // @TODO eventsPushRate is too high, but using eventsQueueSize don't let us assert `filterSplitToGaHits`
        eventsPushRate: 10 // eventsQueueSize: splitTrackParams.length + customHits.length,

      }
    }));
    client = factory.client();
    client.ready().then(function () {
      splitTrackParams.forEach(function (trackParams) {
        client.track.apply(client, trackParams);
      });
      splitGetTreatmentParams.forEach(function (getTreatmentParams) {
        client.getTreatment.apply(client, getTreatmentParams);
      });
    });
  });
}