"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _browser = _interopRequireDefault(require("../browser"));

var _constants = require("../../utils/constants");

var _counter = _interopRequireDefault(require("../../impressions/counter"));

var UNLOAD_DOM_EVENT = 'unload';

var windowAddEventListenerSpy = _sinon.default.spy(window, 'addEventListener');

var windowRemoveEventListenerSpy = _sinon.default.spy(window, 'removeEventListener');

var sendBeaconSpy = _sinon.default.spy(window.navigator, 'sendBeacon');
/* Mocks start */


var generateContextMocks = function generateContextMocks() {
  // We are only mocking the pieces we care about
  var fakeImpression = {
    feature: 'splitName',
    keyName: 'facundo@split.io',
    treatment: 'off',
    time: Date.now(),
    bucketingKey: null,
    label: null,
    changeNumber: null
  };
  var fakeEvent = {
    eventTypeId: 'someEvent',
    trafficTypeName: 'sometraffictype',
    value: null,
    timestamp: null,
    key: 'facundo@split.io',
    properties: null
  };
  var fakeSettings = {
    url: _sinon.default.stub(),
    core: {
      labelsEnabled: true
    }
  };
  var fakeStorage = {
    impressions: {
      isEmpty: _sinon.default.stub(),
      clear: _sinon.default.stub(),
      queue: [fakeImpression],
      state: function state() {
        return this.queue;
      }
    },
    events: {
      isEmpty: _sinon.default.stub(),
      clear: _sinon.default.stub(),
      queue: [fakeEvent],
      toJSON: function toJSON() {
        return this.queue;
      }
    }
  };
  return {
    fakeSettings: fakeSettings,
    fakeStorage: fakeStorage
  };
};

var ContextMock = /*#__PURE__*/function () {
  function ContextMock(fakeStorage, fakeSettings, shouldCreateImpressionsCounter) {
    (0, _classCallCheck2.default)(this, ContextMock);
    this.constants = {
      STORAGE: 'storage',
      SETTINGS: 'settings',
      IMPRESSIONS_COUNTER: 'impressions_counter'
    };
    this.fakeStorage = fakeStorage;
    this.fakeSettings = fakeSettings;
    this.impressionsCounter = shouldCreateImpressionsCounter ? new _counter.default() : undefined;
  }

  (0, _createClass2.default)(ContextMock, [{
    key: "get",
    value: function get(target) {
      switch (target) {
        case 'storage':
          return this.fakeStorage;

        case 'settings':
          return this.fakeSettings;

        case 'impressions_counter':
          return this.impressionsCounter;

        default:
          break;
      }
    }
  }]);
  return ContextMock;
}();
/* Mocks end */


function triggerUnloadEvent() {
  var event = document.createEvent('HTMLEvents');
  event.initEvent('unload', true, true);
  event.eventName = 'unload';
  window.dispatchEvent(event);
}

(0, _tapeCatch.default)('Browser JS / Browser listener class constructor, start and stop methods', function (assert) {
  var _generateContextMocks = generateContextMocks(),
      fakeStorage = _generateContextMocks.fakeStorage,
      fakeSettings = _generateContextMocks.fakeSettings;

  var contextMock = new ContextMock(fakeStorage, fakeSettings, true);
  var listener = new _browser.default(contextMock);
  listener.start(); // Assigned right function to right signal.

  assert.ok(windowAddEventListenerSpy.calledOnce);
  assert.ok(windowAddEventListenerSpy.calledOnceWithExactly(UNLOAD_DOM_EVENT, listener.flushData));
  triggerUnloadEvent();
  setTimeout(function () {
    // Unload event was triggered. Thus sendBeacon method should have been called three times.
    assert.equal(sendBeaconSpy.callCount, 3); // pre-check and call stop

    assert.ok(windowRemoveEventListenerSpy.notCalled);
    listener.stop(); // removed correct listener from correct signal on stop.

    assert.ok(windowRemoveEventListenerSpy.calledOnce);
    assert.ok(windowRemoveEventListenerSpy.calledOnceWithExactly(UNLOAD_DOM_EVENT, listener.flushData));
    assert.end();
  }, 0);
});
(0, _tapeCatch.default)('Browser JS Debug Mode / Browser listener class constructor, start and stop methods', function (assert) {
  var _generateContextMocks2 = generateContextMocks(),
      fakeStorage = _generateContextMocks2.fakeStorage,
      fakeSettings = _generateContextMocks2.fakeSettings;

  fakeSettings.sync = {
    impressionsMode: _constants.DEBUG
  };
  var contextMock = new ContextMock(fakeStorage, fakeSettings, false);
  var listener = new _browser.default(contextMock);
  listener.start(); // Assigned right function to right signal.

  assert.ok(windowAddEventListenerSpy.calledOnce);
  assert.ok(windowAddEventListenerSpy.calledOnceWithExactly(UNLOAD_DOM_EVENT, listener.flushData));
  triggerUnloadEvent();
  setTimeout(function () {
    // Unload event was triggered. Thus sendBeacon method should have been called twice.
    assert.equal(sendBeaconSpy.callCount, 2); // pre-check and call stop

    assert.ok(windowRemoveEventListenerSpy.notCalled);
    listener.stop(); // removed correct listener from correct signal on stop.

    assert.ok(windowRemoveEventListenerSpy.calledOnce);
    assert.ok(windowRemoveEventListenerSpy.calledOnceWithExactly(UNLOAD_DOM_EVENT, listener.flushData));
    assert.end();
  }, 0);
});