"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _ioredis = _interopRequireDefault(require("ioredis"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _InRedis = _interopRequireDefault(require("../../../SplitCache/InRedis"));

var _Keys = _interopRequireDefault(require("../../../Keys"));

var _settings = _interopRequireDefault(require("../../../../utils/settings"));

(0, _tapeCatch.default)('SPLIT CACHE / Redis', /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(assert) {
    var settings, connection, keys, cache, values, splitNames, splits;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            settings = (0, _settings.default)({
              storage: {
                type: 'REDIS'
              }
            });
            connection = new _ioredis.default(settings.storage.options);
            keys = new _Keys.default(settings);
            cache = new _InRedis.default(keys, connection);
            _context.next = 6;
            return cache.flush();

          case 6:
            _context.next = 8;
            return cache.addSplits([['lol1', 'something'], ['lol2', 'something else']]);

          case 8:
            _context.next = 10;
            return cache.getAll();

          case 10:
            values = _context.sent;
            assert.ok(values.indexOf('something') !== -1);
            assert.ok(values.indexOf('something else') !== -1);
            _context.next = 15;
            return cache.getKeys();

          case 15:
            splitNames = _context.sent;
            assert.ok(splitNames.indexOf('lol1') !== -1);
            assert.ok(splitNames.indexOf('lol2') !== -1);
            _context.next = 20;
            return cache.removeSplit('lol1');

          case 20:
            _context.next = 22;
            return cache.getAll();

          case 22:
            values = _context.sent;
            assert.ok(values.indexOf('something') === -1);
            assert.ok(values.indexOf('something else') !== -1);
            _context.t0 = assert;
            _context.next = 28;
            return cache.getSplit('lol1');

          case 28:
            _context.t1 = _context.sent;
            _context.t2 = _context.t1 == null;

            _context.t0.ok.call(_context.t0, _context.t2);

            _context.t3 = assert;
            _context.next = 34;
            return cache.getSplit('lol2');

          case 34:
            _context.t4 = _context.sent;
            _context.t5 = _context.t4 === 'something else';

            _context.t3.ok.call(_context.t3, _context.t5);

            _context.next = 39;
            return cache.setChangeNumber(123);

          case 39:
            _context.t6 = assert;
            _context.next = 42;
            return cache.getChangeNumber();

          case 42:
            _context.t7 = _context.sent;
            _context.t8 = _context.t7 === 123;

            _context.t6.ok.call(_context.t6, _context.t8);

            _context.next = 47;
            return cache.getKeys();

          case 47:
            splitNames = _context.sent;
            assert.ok(splitNames.indexOf('lol1') === -1);
            assert.ok(splitNames.indexOf('lol2') !== -1);
            _context.next = 52;
            return cache.fetchMany(['lol1', 'lol2']);

          case 52:
            splits = _context.sent;
            assert.ok(splits['lol1'] === null);
            assert.ok(splits['lol2'] === 'something else');
            connection.quit();
            assert.end();

          case 57:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
(0, _tapeCatch.default)('SPLIT CACHE / Redis / trafficTypeExists tests', /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(assert) {
    var prefix, settings, connection, keys, cache, testTTName, testTTNameNoCount, testTTNameInvalid, ttKey, ttKeyNoCount, ttKeyInvalid;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            prefix = 'redis_cache_ut_prefix';
            settings = (0, _settings.default)({
              storage: {
                type: 'REDIS',
                prefix: prefix
              }
            });
            connection = new _ioredis.default(settings.storage.options);
            keys = new _Keys.default(settings);
            cache = new _InRedis.default(keys, connection);
            testTTName = 'tt_test_name';
            testTTNameNoCount = 'tt_test_name_2';
            testTTNameInvalid = 'tt_test_name_3';
            ttKey = keys.buildTrafficTypeKey(testTTName);
            ttKeyNoCount = keys.buildTrafficTypeKey(testTTNameNoCount);
            ttKeyInvalid = keys.buildTrafficTypeKey(testTTNameInvalid);
            _context2.next = 13;
            return cache.flush();

          case 13:
            _context2.next = 15;
            return connection.set(ttKey, 3);

          case 15:
            _context2.next = 17;
            return connection.set(ttKeyNoCount, 0);

          case 17:
            _context2.next = 19;
            return connection.set(ttKeyInvalid, 'NaN');

          case 19:
            _context2.t0 = assert;
            _context2.next = 22;
            return cache.trafficTypeExists(testTTName);

          case 22:
            _context2.t1 = _context2.sent;

            _context2.t0.true.call(_context2.t0, _context2.t1);

            _context2.t2 = assert;
            _context2.next = 27;
            return cache.trafficTypeExists(testTTNameNoCount);

          case 27:
            _context2.t3 = _context2.sent;

            _context2.t2.false.call(_context2.t2, _context2.t3);

            _context2.t4 = assert;
            _context2.next = 32;
            return cache.trafficTypeExists(ttKeyInvalid);

          case 32:
            _context2.t5 = _context2.sent;

            _context2.t4.false.call(_context2.t4, _context2.t5);

            _context2.t6 = assert;
            _context2.next = 37;
            return cache.trafficTypeExists('not_existent_tt');

          case 37:
            _context2.t7 = _context2.sent;

            _context2.t6.false.call(_context2.t6, _context2.t7);

            _context2.next = 41;
            return connection.del(ttKey);

          case 41:
            _context2.next = 43;
            return connection.del(ttKeyNoCount);

          case 43:
            _context2.next = 45;
            return connection.del(ttKeyInvalid);

          case 45:
            connection.quit();
            assert.end();

          case 47:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());