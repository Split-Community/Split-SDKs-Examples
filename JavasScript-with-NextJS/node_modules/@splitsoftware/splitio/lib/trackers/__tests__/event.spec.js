"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _event = _interopRequireDefault(require("../event"));

var _constants = require("../../utils/context/constants");

/* Mocks start */
var generateContextMocks = function generateContextMocks() {
  // We are only mocking the pieces we care about
  var fakeStorage = {
    events: {
      track: _sinon.default.stub()
    }
  };
  var fakeIntegrationsManager = {
    handleEvent: _sinon.default.stub()
  };
  return {
    fakeStorage: fakeStorage,
    fakeIntegrationsManager: fakeIntegrationsManager
  };
};

var ContextMock = /*#__PURE__*/function () {
  function ContextMock(fakeStorage, fakeIntegrationsManager) {
    (0, _classCallCheck2.default)(this, ContextMock);
    this.constants = {
      STORAGE: _constants.STORAGE,
      INTEGRATIONS_MANAGER: _constants.INTEGRATIONS_MANAGER
    };
    this.fakeStorage = fakeStorage;
    this.fakeIntegrationsManager = fakeIntegrationsManager;
  }

  (0, _createClass2.default)(ContextMock, [{
    key: "get",
    value: function get(target) {
      switch (target) {
        case _constants.STORAGE:
          return this.fakeStorage;

        case _constants.INTEGRATIONS_MANAGER:
          return this.fakeIntegrationsManager;

        default:
          break;
      }
    }
  }]);
  return ContextMock;
}();
/* Mocks end */


(0, _tapeCatch.default)('Event Tracker', function (t) {
  t.test('Tracker API', function (assert) {
    assert.equal((0, _typeof2.default)(_event.default), 'function', 'The module should return a function which acts as a factory.');

    var _generateContextMocks = generateContextMocks(),
        fakeStorage = _generateContextMocks.fakeStorage;

    var contextMock = new ContextMock(fakeStorage);
    var instance = (0, _event.default)(contextMock);
    assert.equal((0, _typeof2.default)(instance.track), 'function', 'The instance should implement the track method.');
    assert.end();
  });
  t.test('Propagate the event into the event cache and integrations manager, and return its result (a boolean or a promise that resolves to boolean)', function (assert) {
    var _generateContextMocks2 = generateContextMocks(),
        fakeStorage = _generateContextMocks2.fakeStorage,
        fakeIntegrationsManager = _generateContextMocks2.fakeIntegrationsManager;

    var fakeEvent = {
      eventTypeId: 'eventTypeId',
      trafficTypeName: 'trafficTypeName',
      value: 0,
      timestamp: Date.now(),
      key: 'matchingKey',
      properties: {
        prop1: 'prop1',
        prop2: 0
      }
    };
    fakeStorage.events.track.withArgs(fakeEvent, 1).returns(true);
    fakeStorage.events.track.withArgs(fakeEvent, 2).returns(Promise.resolve(false));
    fakeStorage.events.track.withArgs(fakeEvent, 3).returns(Promise.resolve(true));
    var contextMock = new ContextMock(fakeStorage, fakeIntegrationsManager);
    var tracker = (0, _event.default)(contextMock);
    var result1 = tracker.track(fakeEvent, 1);
    assert.true(fakeStorage.events.track.calledWithExactly(_sinon.default.match.same(fakeEvent), 1), 'Should be present in the event cache.');
    assert.true(!fakeIntegrationsManager.handleEvent.calledOnce, 'The integration manager handleEvent method should not be executed synchronously.');
    assert.true(result1, true, 'Should return the value of the event cache.');
    setTimeout(function () {
      assert.true(fakeIntegrationsManager.handleEvent.calledOnceWithExactly(fakeEvent), 'A copy of the tracked event should be sent to integration manager after the timeout wrapping make it to the queue stack.');
      assert.false(fakeIntegrationsManager.handleEvent.calledOnceWithExactly(_sinon.default.match.same(fakeEvent)), 'Should not send the original event.');
      var result2 = tracker.track(fakeEvent, 2);
      assert.true(fakeStorage.events.track.calledWithExactly(_sinon.default.match.same(fakeEvent), 2), 'Should be present in the event cache.');
      result2.then(function (tracked) {
        assert.equal(tracked, false, 'Should return the value of the event cache resolved promise.');
        setTimeout(function () {
          assert.true(fakeIntegrationsManager.handleEvent.calledOnce, 'Untracked event should not be sent to integration manager.');
          var result3 = tracker.track(fakeEvent, 3);
          assert.true(fakeStorage.events.track.calledWithExactly(_sinon.default.match.same(fakeEvent), 3), 'Should be present in the event cache.');
          result3.then(function (tracked) {
            assert.false(fakeIntegrationsManager.handleEvent.calledTwice, 'Tracked event should not be sent to integration manager synchronously');
            assert.equal(tracked, true, 'Should return the value of the event cache resolved promise.');
            setTimeout(function () {
              assert.true(fakeIntegrationsManager.handleEvent.getCalls()[1].calledWithExactly(fakeEvent), 'A copy of tracked event should be sent to integration manager after the timeout wrapping make it to the queue stack.');
              assert.false(fakeIntegrationsManager.handleEvent.getCalls()[1].calledWithExactly(_sinon.default.match.same(fakeEvent)), 'Should not send the original event.');
              assert.end();
            }, 0);
          });
        }, 0);
      });
    }, 0);
  });
});