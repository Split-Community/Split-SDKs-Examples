"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _lang = require("../../lang");

(0, _tapeCatch.default)('LANG UTILS / startsWith', function (assert) {
  assert.ok((0, _lang.startsWith)('myStr', 'myS'));
  assert.ok((0, _lang.startsWith)('this is something', 'this is'));
  assert.notOk((0, _lang.startsWith)('myStr', 'yS'));
  assert.notOk((0, _lang.startsWith)(' myStr', 'yS'));
  assert.notOk((0, _lang.startsWith)('myStr', ' yS'));
  assert.notOk((0, _lang.startsWith)('myStr', null));
  assert.notOk((0, _lang.startsWith)(false, null));
  assert.notOk((0, _lang.startsWith)());
  assert.notOk((0, _lang.startsWith)(null, 'ys'));
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / endsWith', function (assert) {
  assert.ok((0, _lang.endsWith)('myStr', 'Str'));
  assert.ok((0, _lang.endsWith)('myStr2', 'r2'));
  assert.ok((0, _lang.endsWith)('is a str', ' str', false)); // can be case insensitive too

  assert.ok((0, _lang.endsWith)('myStr', 'str', true));
  assert.ok((0, _lang.endsWith)('myStr', 'str', true));
  assert.ok((0, _lang.endsWith)('myStr', 'Str', true));
  assert.notOk((0, _lang.endsWith)('myStr', 'Sr'));
  assert.notOk((0, _lang.endsWith)('myStr ', 'tr'));
  assert.notOk((0, _lang.endsWith)('myStr', 'tr '));
  assert.notOk((0, _lang.endsWith)('myStr', 'str'));
  assert.notOk((0, _lang.endsWith)('myStr', 'str', false));
  assert.notOk((0, _lang.endsWith)('myStr', null));
  assert.notOk((0, _lang.endsWith)(false, null));
  assert.notOk((0, _lang.endsWith)());
  assert.notOk((0, _lang.endsWith)(null, 'ys'));
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / get', function (assert) {
  var obj = {
    simple: 'simple',
    undef: undefined,
    deepProp: {
      sample: 'sample',
      deeperProp: {
        deeper: true
      }
    }
  }; // negative

  assert.equal((0, _lang.get)(obj, 'not_exists', 'default'), 'default', 'If the property path does not match a property of the source, return the default value.');
  assert.equal((0, _lang.get)(obj, 'undef', 'default'), 'default', 'If the property is found but the value is undefined, return the default value.');
  assert.equal((0, _lang.get)(obj, 'undef.crap', 'default'), 'default', 'If the property path is incorrect and could cause an error, return the default value.');
  assert.equal((0, _lang.get)(obj, null, 'default'), 'default', 'If the property path is of wrong type, return the default value.');
  assert.equal((0, _lang.get)(obj, /regex/, 'default'), 'default', 'If the property path is of wrong type, return the default value.');
  assert.equal((0, _lang.get)(null, 'simple', 'default'), 'default', 'If the source is of wrong type, return the default value.');
  assert.equal((0, _lang.get)(/regex/, 'simple', 'default'), 'default', 'If the source is of wrong type, return the default value.'); // positive

  assert.equal((0, _lang.get)(obj, 'simple', 'default'), 'simple', 'If the property path (regardless of how "deep") matches a defined property of the object, returns that value instead of default.');
  assert.equal((0, _lang.get)(obj, 'deepProp.sample', 'default'), 'sample', 'If the property path (regardless of how "deep") matches a defined property of the object, returns that value instead of default.');
  assert.equal((0, _lang.get)(obj, 'deepProp.deeperProp.deeper', 'default'), true, 'If the property path (regardless of how "deep") matches a defined property of the object, returns that value instead of default.');
  assert.deepEqual((0, _lang.get)(obj, 'deepProp.deeperProp', 'default'), {
    deeper: true
  }, 'If the property path (regardless of how "deep") matches a defined property of the object, returns that value (regardless of the type) instead of default.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / findIndex', function (assert) {
  var arr = [1, 2, 3, 4, 3];
  assert.equal((0, _lang.findIndex)(), -1, 'If the parameters for findIndex are wrong it returns -1.');
  assert.equal((0, _lang.findIndex)(null, function () {}), -1, 'If the parameters for findIndex are wrong it returns -1.');
  assert.equal((0, _lang.findIndex)({}, function () {}), -1, 'If the parameters for findIndex are wrong it returns -1.');
  assert.equal((0, _lang.findIndex)({}, false), -1, 'If the parameters for findIndex are wrong it returns -1.');
  assert.equal((0, _lang.findIndex)(arr, function () {
    return false;
  }), -1, 'If no element causes iteratee to return truthy, it returns -1.');
  assert.equal((0, _lang.findIndex)(arr, function (e) {
    return e === 5;
  }), -1, 'If no element causes iteratee to return truthy, it returns -1.');
  assert.equal((0, _lang.findIndex)(arr, function (e) {
    return e === 1;
  }), 0, 'It should return the index of the first element that causes iteratee to return truthy.');
  assert.equal((0, _lang.findIndex)(arr, function (e) {
    return e === 2;
  }), 1, 'It should return the index of the first element that causes iteratee to return truthy.');
  assert.equal((0, _lang.findIndex)(arr, function (e) {
    return e === 3;
  }), 2, 'It should return the index of the first element that causes iteratee to return truthy.');
  /* Not testing the params received by iteratee because we know that Array.prototype.findIndex works ok */

  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / find', function (assert) {
  assert.equal((0, _lang.find)(), undefined, 'We cant find the element if the collection is wrong type, so we return undefined.');
  assert.equal((0, _lang.find)(null, function () {
    return true;
  }), undefined, 'We cant find the element if the collection is wrong type, so we return undefined.');
  assert.equal((0, _lang.find)([], function () {
    return true;
  }), undefined, 'If the collection is empty there is no element to be found, so we return undefined.');
  assert.equal((0, _lang.find)({}, function () {
    return true;
  }), undefined, 'If the collection is empty there is no element to be found, so we return undefined.');

  var spy = _sinon.default.spy();

  var obj = {
    myKey: 'myVal',
    myOtherKey: 'myOtherVal'
  };
  (0, _lang.find)(obj, spy);
  assert.ok(spy.calledTwice, 'The iteratee should be called as many times as elements we have on the collection.');
  assert.ok(spy.firstCall.calledWithExactly('myVal', 'myKey', obj), 'When iterating on an object the iteratee should be called with (val, key, collection)');
  assert.ok(spy.secondCall.calledWithExactly('myOtherVal', 'myOtherKey', obj), 'When iterating on an object the iteratee should be called with (val, key, collection)');
  var arr = ['one', 'two'];
  spy.resetHistory();
  (0, _lang.find)(arr, spy);
  assert.ok(spy.calledTwice, 'The iteratee should be called as many times as elements we have on the collection.');
  assert.ok(spy.firstCall.calledWithExactly('one', 0, arr), 'When iterating on an array the iteratee should be called with (val, index, collection)');
  assert.ok(spy.secondCall.calledWithExactly('two', 1, arr), 'When iterating on an array the iteratee should be called with (val, index, collection)');
  assert.equal((0, _lang.find)({
    val1: '1',
    val2: '2'
  }, function (e) {
    return e === '2';
  }), '2', 'If an element causes iteratee to return a truthy value, that value is returned.');
  assert.equal((0, _lang.find)(['uno', 'dos'], function (e) {
    return e === 'uno';
  }), 'uno', 'If an element causes iteratee to return a truthy value, that value is returned.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / isString', function (assert) {
  assert.ok((0, _lang.isString)(''), 'Should return true for strings.');
  assert.ok((0, _lang.isString)('asd'), 'Should return true for strings.');
  assert.ok((0, _lang.isString)(new String('asdf')), 'Should return true for strings.');
  assert.notOk((0, _lang.isString)(), 'Should return false for non-strings.');
  assert.notOk((0, _lang.isString)(null), 'Should return false for non-strings.');
  assert.notOk((0, _lang.isString)([]), 'Should return false for non-strings.');
  assert.notOk((0, _lang.isString)({}), 'Should return false for non-strings.');
  assert.notOk((0, _lang.isString)(/regex/), 'Should return false for non-strings.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / numberIsFinite', function (assert) {
  assert.ok((0, _lang.numberIsFinite)(1), 'Should return true for finite numbers.');
  assert.ok((0, _lang.numberIsFinite)(-0.5), 'Should return true for finite numbers.');
  assert.ok((0, _lang.numberIsFinite)(Number(0.5)), 'Should return true for finite numbers.');
  assert.ok((0, _lang.numberIsFinite)(new Number(4)), 'Should return true for finite numbers.');
  assert.notOk((0, _lang.numberIsFinite)(), 'Should return false for anything that is not a finite number.');
  assert.notOk((0, _lang.numberIsFinite)(Infinity), 'Should return false for anything that is not a finite number.');
  assert.notOk((0, _lang.numberIsFinite)(-Infinity), 'Should return false for anything that is not a finite number.');
  assert.notOk((0, _lang.numberIsFinite)(NaN), 'Should return false for anything that is not a finite number.');
  assert.notOk((0, _lang.numberIsFinite)(new Number(Infinity)), 'Should return false for anything that is not a finite number.');
  assert.notOk((0, _lang.numberIsFinite)(new Number(NaN)), 'Should return false for anything that is not a finite number.');
  assert.notOk((0, _lang.numberIsFinite)(null), 'Should return false for anything that is not a finite number.');
  assert.notOk((0, _lang.numberIsFinite)([]), 'Should return false for anything that is not a finite number.');
  assert.notOk((0, _lang.numberIsFinite)({}), 'Should return false for anything that is not a finite number.');
  assert.notOk((0, _lang.numberIsFinite)(/regex/), 'Should return false for anything that is not a finite number.');
  assert.notOk((0, _lang.numberIsFinite)('5'), 'Should return false for anything that is not a finite number.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / numberIsNaN', function (assert) {
  assert.ok((0, _lang.numberIsNaN)(NaN), 'Should return true for NaN numbers of "number" type.');
  assert.ok((0, _lang.numberIsNaN)(Number(NaN)), 'Should return true for NaN numbers of "number" type.');
  assert.ok((0, _lang.numberIsNaN)(new Number(NaN)), 'Should return true for NaN Number objects.');
  assert.notOk((0, _lang.numberIsNaN)(), 'Should return false for anything that is not a NaN number.');
  assert.notOk((0, _lang.numberIsNaN)(Infinity), 'Should return false for anything that is not a NaN number.');
  assert.notOk((0, _lang.numberIsNaN)(-Infinity), 'Should return false for anything that is not a NaN number.');
  assert.notOk((0, _lang.numberIsNaN)(new Number(Infinity)), 'Should return false for anything that is not a NaN number.');
  assert.notOk((0, _lang.numberIsNaN)(null), 'Should return false for anything that is not a NaN number.');
  assert.notOk((0, _lang.numberIsNaN)([]), 'Should return false for anything that is not a NaN number.');
  assert.notOk((0, _lang.numberIsNaN)({}), 'Should return false for anything that is not a NaN number.');
  assert.notOk((0, _lang.numberIsNaN)(/regex/), 'Should return false for anything that is not a NaN number.');
  assert.notOk((0, _lang.numberIsNaN)('5'), 'Should return false for anything that is not a NaN number.');
  assert.notOk((0, _lang.numberIsNaN)('NaN'), 'Should return false for anything that is not a NaN number.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / numberIsInteger', function (assert) {
  assert.ok((0, _lang.numberIsInteger)(1), 'Should return true for integer numbers of "number" type.');
  assert.ok((0, _lang.numberIsInteger)(Number.MIN_SAFE_INTEGER), 'Should return true for integer numbers of "number" type.');
  assert.ok((0, _lang.numberIsInteger)(Number(4)), 'Should return true for integer numbers of "number" type.');
  assert.ok((0, _lang.numberIsInteger)(new Number(4)), 'Should return true for integer Number objects.');
  assert.notOk((0, _lang.numberIsInteger)(), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)(Infinity), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)(-Infinity), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)(NaN), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)(-0.5), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)(new Number(Infinity)), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)(new Number(NaN)), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)(new Number(-0.5)), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)(null), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)([]), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)({}), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)(/regex/), 'Should return false for anything that is not an integer numbers.');
  assert.notOk((0, _lang.numberIsInteger)('5'), 'Should return false for anything that is not an integer numbers.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / isObject', function (assert) {
  assert.ok((0, _lang.isObject)({}), 'Should return true for map objects.');
  assert.ok((0, _lang.isObject)({
    a: true
  }), 'Should return true for map objects.');
  assert.ok((0, _lang.isObject)(new Object()), 'Should return true for map objects.');
  assert.ok((0, _lang.isObject)(Object.create({})), 'Should return true for map objects.');
  assert.notOk((0, _lang.isObject)([]), 'Should return false for anything that is not a map object.');
  assert.notOk((0, _lang.isObject)(function () {}), 'Should return false for anything that is not a map object.');
  assert.notOk((0, _lang.isObject)(true), 'Should return false for anything that is not a map object.');
  assert.notOk((0, _lang.isObject)(false), 'Should return false for anything that is not a map object.');
  assert.notOk((0, _lang.isObject)(null), 'Should return false for anything that is not a map object.');
  assert.notOk((0, _lang.isObject)(undefined), 'Should return false for anything that is not a map object.');
  assert.notOk((0, _lang.isObject)(1), 'Should return false for anything that is not a map object.');
  assert.notOk((0, _lang.isObject)('asd'), 'Should return false for anything that is not a map object.');
  assert.notOk((0, _lang.isObject)(function () {}), 'Should return false for anything that is not a map object.');
  assert.notOk((0, _lang.isObject)(Symbol('test')), 'Should return false for anything that is not a map object.');
  assert.notOk((0, _lang.isObject)(new Promise(function (res) {
    return res();
  })), 'Should return false for anything that is not a map object.'); // Object.create(null) creates an object with no prototype which may be tricky to handle. Filtering that out too.

  assert.notOk((0, _lang.isObject)(Object.create(null)), 'Should return false for anything that is not a map object.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / uniqueId', function (assert) {
  var currId = -100;
  var prevId = -100;

  for (var i = 0; i < 10; i++) {
    currId = (0, _lang.uniqueId)();
    assert.ok(prevId < currId, 'Each time we call the function, the new ID should be different (greater than) the previous one.');
    prevId = currId;
  }

  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / merge', function (assert) {
  var obj1 = {};
  var res1 = (0, _lang.merge)(obj1, {
    something: 'else'
  });
  assert.ok(res1 === obj1, 'It merges on the target, modifying that object and returning it too.');
  assert.deepEqual((0, _lang.merge)({
    a: 'a',
    b: 'b'
  }, {
    c: 'c'
  }), {
    a: 'a',
    b: 'b',
    c: 'c'
  }, 'Should be able to merge simple objects, an unlimited amount of them.');
  assert.deepEqual((0, _lang.merge)({
    a: 'a',
    b: 'b'
  }, {
    c: 'c'
  }, {
    d: 'd'
  }), {
    a: 'a',
    b: 'b',
    c: 'c',
    d: 'd'
  }, 'Should be able to merge simple objects, an unlimited amount of them.');
  assert.deepEqual((0, _lang.merge)({
    a: 'a'
  }, {
    b: 'b'
  }, {
    c: 'c'
  }, {
    d: 'd'
  }), {
    a: 'a',
    b: 'b',
    c: 'c',
    d: 'd'
  }, 'Should be able to merge simple objects, an unlimited amount of them.');
  obj1 = {
    a: 'a',
    abc: {
      b: 'b',
      c: 'c'
    },
    arr: [1, 2]
  };
  var obj2 = {
    a: 'not a anymore',
    d: 'd'
  }; // Two objects with complex structures but not in common.

  assert.deepEqual((0, _lang.merge)(obj1, obj2), {
    a: 'not a anymore',
    abc: {
      b: 'b',
      c: 'c'
    },
    d: 'd',
    arr: [1, 2]
  }, 'Should be able to merge complex objects');
  obj1 = {
    a: 'a',
    abc: {
      b: 'b',
      c: 'c'
    }
  };
  obj2 = {
    a: 'not a anymore',
    abc: {
      c: 'not c anymore',
      d: 'd'
    }
  }; // Two objects with object property in common

  assert.deepEqual((0, _lang.merge)(obj1, obj2), {
    a: 'not a anymore',
    abc: {
      b: 'b',
      c: 'not c anymore',
      d: 'd'
    }
  }, 'Should be able to merge complex objects');
  obj2.abc.d = {
    ran: 'dom'
  }; // Two objects with object property in common and with objects in it.

  assert.deepEqual((0, _lang.merge)(obj1, obj2), {
    a: 'not a anymore',
    abc: {
      b: 'b',
      c: 'not c anymore',
      d: {
        ran: 'dom'
      }
    }
  }, 'Should be able to merge complex objects');
  obj1.abc = 'abc'; // Two objects with property in common, as object on source.

  assert.deepEqual((0, _lang.merge)(obj1, obj2), {
    a: 'not a anymore',
    abc: {
      c: 'not c anymore',
      d: {
        ran: 'dom'
      }
    }
  }, 'Should be able to merge complex objects');
  obj1.abc = {
    a: 'obja',
    b: 'objb'
  };
  obj2.abc = 'str'; // Two objects with property in common, as object on target. Source should always take precedence.

  assert.deepEqual((0, _lang.merge)(obj1, obj2), {
    a: 'not a anymore',
    abc: 'str'
  }, 'Should be able to merge complex objects');
  obj1 = {
    1: '1',
    abc: {
      a: 'a',
      b: 'b'
    }
  };
  obj2 = {
    2: '2',
    abc: {
      a: 'a2',
      c: 'c'
    }
  };
  var obj3 = {
    3: '3',
    abc: {
      c: 'c3',
      d: {
        d: 'd'
      }
    },
    33: {
      3: 3
    }
  }; // Three complex objects.

  assert.deepEqual((0, _lang.merge)(obj1, obj2, obj3), {
    1: '1',
    2: '2',
    3: '3',
    33: {
      3: 3
    },
    abc: {
      a: 'a2',
      b: 'b',
      c: 'c3',
      d: {
        d: 'd'
      }
    }
  }, 'Should be able to merge complex objects, an unlimited amount of them.');
  var obj4 = {
    33: {
      4: false
    }
  };
  delete obj2.abc; // This removes the reference.

  obj1.abc.a = 'a'; // Remember that it merges on the target.
  // Four complex objects, not all of them have the object prop.

  assert.deepEqual((0, _lang.merge)(obj1, obj2, obj3, obj4), {
    1: '1',
    2: '2',
    3: '3',
    33: {
      3: 3,
      4: false
    },
    abc: {
      a: 'a',
      b: 'b',
      c: 'c3',
      d: {
        d: 'd'
      }
    }
  }, 'Should be able to merge complex objects, an unlimited amount of them.');
  assert.deepEqual(obj1, {
    1: '1',
    2: '2',
    3: '3',
    33: {
      3: 3,
      4: false
    },
    abc: {
      a: 'a',
      b: 'b',
      c: 'c3',
      d: {
        d: 'd'
      }
    }
  }, 'Always modifying the target.');
  obj2.abc = undefined; // We should avoid undefined values.
  // Four complex objects, all of them have the object prop but one instead of object, undefined.

  assert.deepEqual((0, _lang.merge)(obj1, obj2, obj3, obj4), {
    1: '1',
    2: '2',
    3: '3',
    33: {
      3: 3,
      4: false
    },
    abc: {
      a: 'a',
      b: 'b',
      c: 'c3',
      d: {
        d: 'd'
      }
    }
  }, 'Should be able to merge complex objects, an unlimited amount of them and still filter undefined props.');
  res1 = {};
  assert.ok((0, _lang.merge)(res1, obj1) === res1, 'Always returns the modified target.');
  assert.deepEqual(res1, obj1, 'If target is an empty object, it will be a clone of the source on that one.');
  var one = {};
  var two = {
    prop: 'val'
  };
  var three = {
    otherProp: 'val',
    objProp: {
      innerProp: true,
      innerObj: {
        deeperProp: 'test'
      }
    }
  };
  var four = {
    prop: 'val4'
  };
  var returnedObj = (0, _lang.merge)(one, two, three, four);
  assert.equal(one, returnedObj, 'The target object should be modified.');
  assert.deepEqual(two, {
    prop: 'val'
  }, 'But no other objects sents as source should be modified.');
  assert.deepEqual(three, {
    otherProp: 'val',
    objProp: {
      innerProp: true,
      innerObj: {
        deeperProp: 'test'
      }
    }
  }, 'But no other objects sents as source should be modified.');
  assert.deepEqual(four, {
    prop: 'val4'
  }, 'But no other objects sents as source should be modified.');
  assert.notEqual(returnedObj.objProp, three.objProp, 'Object properties should be clones of the value we had on source, not a reference.');
  assert.notEqual(returnedObj.objProp.innerObj, three.objProp.innerObj, 'Object properties should be clones of the value we had on source, not a reference.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / uniq', function (assert) {
  assert.deepEqual((0, _lang.uniq)(['1', '2', '1', '3', '3', '4', '3']), ['1', '2', '3', '4'], 'uniq should remove all duplicate strings from array.');
  assert.deepEqual((0, _lang.uniq)(['2', '2']), ['2'], 'uniq should remove all duplicate strings from array.');
  assert.deepEqual((0, _lang.uniq)(['2', '3']), ['2', '3'], 'uniq should remove all duplicate strings from array.');
  assert.deepEqual((0, _lang.uniq)(['3', '2', '3']), ['3', '2'], 'uniq should remove all duplicate strings from array.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / toString', function (assert) {
  assert.equal((0, _typeof2.default)((0, _lang.toString)()), 'string', 'It should ALWAYS return a string.');
  assert.equal((0, _typeof2.default)((0, _lang.toString)(null)), 'string', 'It should ALWAYS return a string.');
  assert.equal((0, _typeof2.default)((0, _lang.toString)(250)), 'string', 'It should ALWAYS return a string.');
  assert.equal((0, _typeof2.default)((0, _lang.toString)('asdad')), 'string', 'It should ALWAYS return a string.');
  assert.equal((0, _typeof2.default)((0, _lang.toString)(/regex/)), 'string', 'It should ALWAYS return a string.');
  assert.equal((0, _lang.toString)(), '', 'And the returned string should be correct');
  assert.equal((0, _lang.toString)('it is just me'), 'it is just me', 'And the returned string should be correct');
  assert.equal((0, _lang.toString)(5), '5', 'And the returned string should be correct');
  assert.equal((0, _lang.toString)(['str', /not_str/, 'secondStr']), 'str,,secondStr', 'And the returned string should be correct');
  assert.equal((0, _lang.toString)(0), '0', 'And the returned string should be correct');
  assert.equal((0, _lang.toString)(-0), '-0', 'And the returned string should be correct');
  assert.equal((0, _lang.toString)(-Infinity), '-Infinity', 'And the returned string should be correct');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / toNumber', function (assert) {
  assert.equal((0, _typeof2.default)((0, _lang.toNumber)(NaN)), 'number', 'It should ALWAYS return a number.');
  assert.equal((0, _typeof2.default)((0, _lang.toNumber)(null)), 'number', 'It should ALWAYS return a number.');
  assert.equal((0, _typeof2.default)((0, _lang.toNumber)(250)), 'number', 'It should ALWAYS return a number.');
  assert.equal((0, _typeof2.default)((0, _lang.toNumber)('asdad')), 'number', 'It should ALWAYS return a number.');
  assert.equal((0, _typeof2.default)((0, _lang.toNumber)(/regex/)), 'number', 'It should ALWAYS return a number.');
  assert.ok(Number.isNaN((0, _lang.toNumber)()), 'The returned number should be NaN for values that cannot be converted');
  assert.ok(Number.isNaN((0, _lang.toNumber)(/regex/)), 'The returned number should be NaN for values that cannot be converted');
  assert.ok(Number.isNaN((0, _lang.toNumber)({})), 'The returned number should be NaN for values that cannot be converted');
  assert.ok(Number.isNaN((0, _lang.toNumber)({})), 'The returned number should be NaN for values that cannot be converted');
  assert.ok(Number.isNaN((0, _lang.toNumber)('1.2.3')), 'The returned number should be NaN for values that cannot be converted');
  assert.equal((0, _lang.toNumber)('1.2124'), 1.2124, 'The returned number (if it can be converted) should be correct');
  assert.equal((0, _lang.toNumber)('238'), 238, 'The returned number (if it can be converted) should be correct');
  assert.equal((0, _lang.toNumber)(null), 0, 'The returned number (if it can be converted) should be correct');
  assert.equal((0, _lang.toNumber)(15), 15, 'The returned number (if it can be converted) should be correct');
  assert.equal((0, _lang.toNumber)(''), 0, 'The returned number (if it can be converted) should be correct');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / forOwn', function (assert) {
  var spy = _sinon.default.spy();

  var obj = {
    myKey: 'myVal',
    myOtherKey: 'myOtherVal'
  };
  (0, _lang.forOwn)(obj, spy);
  assert.ok(spy.calledTwice, 'The iteratee should be called as many times as elements we have on the object.');
  assert.ok(spy.firstCall.calledWithExactly('myVal', 'myKey', obj), 'When iterating on an object the iteratee should be called with (val, key, collection)');
  assert.ok(spy.secondCall.calledWithExactly('myOtherVal', 'myOtherKey', obj), 'When iterating on an object the iteratee should be called with (val, key, collection)');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / groupBy', function (assert) {
  var arr = [{
    team: 'SDK',
    name: 'Nico',
    ex: 'glb'
  }, {
    team: 'SDK',
    name: 'Martin'
  }, {
    team: 'QA',
    name: 'Adrian',
    ex: 'glb'
  }];
  assert.deepEqual((0, _lang.groupBy)(arr, 'team'), {
    SDK: [{
      team: 'SDK',
      name: 'Nico',
      ex: 'glb'
    }, {
      team: 'SDK',
      name: 'Martin'
    }],
    QA: [{
      team: 'QA',
      name: 'Adrian',
      ex: 'glb'
    }]
  }, 'Should group by the property specified respecting the order of appearance.');
  assert.deepEqual((0, _lang.groupBy)(arr, 'not_exist'), {}, 'If the property specified does not exist on the elements the map will be empty.');
  assert.deepEqual((0, _lang.groupBy)(arr, 'ex'), {
    glb: [{
      team: 'SDK',
      name: 'Nico',
      ex: 'glb'
    }, {
      team: 'QA',
      name: 'Adrian',
      ex: 'glb'
    }]
  }, 'If the property specified does not exist on all the elements the ones without it will be skipped.');
  assert.deepEqual((0, _lang.groupBy)([], 'team'), {}, 'If the input is empty or wrong type, it will return an empty object.');
  assert.deepEqual((0, _lang.groupBy)(null, 'team'), {}, 'If the input is empty or wrong type, it will return an empty object.');
  assert.deepEqual((0, _lang.groupBy)(undefined, 'team'), {}, 'If the input is empty or wrong type, it will return an empty object.');
  assert.deepEqual((0, _lang.groupBy)(true, 'team'), {}, 'If the input is empty or wrong type, it will return an empty object.');
  assert.deepEqual((0, _lang.groupBy)('string', 'team'), {}, 'If the input is empty or wrong type, it will return an empty object.');
  assert.deepEqual((0, _lang.groupBy)({}, 'team'), {}, 'If the input is empty or wrong type, it will return an empty object.');
  assert.deepEqual((0, _lang.groupBy)({
    something: 1
  }, null), {}, 'If the input is empty or wrong type, it will return an empty object.');
  assert.deepEqual((0, _lang.groupBy)({
    something: 1
  }), {}, 'If the input is empty or wrong type, it will return an empty object.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / getFnName', function (assert) {
  function name1() {}

  assert.equal((0, _lang.getFnName)(name1), 'name1', 'Should retrieve the function name.');
  assert.equal((0, _lang.getFnName)(Array.prototype.push), 'push', 'Should retrieve the function name.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / shallowClone', function (assert) {
  var toClone = {
    aProperty: 1,
    another: 'two',
    more: null,
    keys: [undefined, {}],
    innerObj: {
      test: true,
      deeper: {
        key: 'value'
      }
    },
    bool: true
  };
  var clone = (0, _lang.shallowClone)(toClone);
  assert.deepEqual(clone, toClone, 'The structure of the shallow clone should be the same since references are copied too.');
  assert.notEqual(clone, toClone, 'But the reference to the object itself is differente since it is a clone');
  assert.equal(clone.innerObj, toClone.innerObj, 'Internal references are just copied as references, since the clone is shallow.');
  assert.end();
});
(0, _tapeCatch.default)('LANG UTILS / isBoolean', function (assert) {
  var notBool = [null, undefined, 0, 1, NaN, Infinity, function () {}, new Promise(function () {}), [], {}, 'true', 'false']; // negatives

  notBool.forEach(function (val) {
    return assert.false((0, _lang.isBoolean)(val));
  }); // positives

  [true, false].forEach(function (val) {
    return assert.true((0, _lang.isBoolean)(val));
  });
  assert.end();
});