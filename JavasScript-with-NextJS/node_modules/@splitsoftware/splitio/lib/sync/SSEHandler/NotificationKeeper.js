"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = notificationKeeperFactory;

var _constants = require("../constants");

var CONTROL_PRI_CHANNEL_REGEX = /control_pri$/;

function notificationKeeperFactory(feedbackLoopEmitter) {
  var occupancyTimestamp = -1;
  var hasPublishers = true; // false if the number of publishers is equal to 0 in the last OCCUPANCY notification from CHANNEL_PRI

  var controlTimestamp = -1;
  var hasResumed = true; // false if last CONTROL event was STREAMING_PAUSED or STREAMING_DISABLED

  return {
    handleOpen: function handleOpen() {
      feedbackLoopEmitter.emit(_constants.PUSH_CONNECT);
    },
    isStreamingUp: function isStreamingUp() {
      return hasResumed && hasPublishers;
    },
    handleOccupancyEvent: function handleOccupancyEvent(publishers, channel, timestamp) {
      if (CONTROL_PRI_CHANNEL_REGEX.test(channel) && timestamp > occupancyTimestamp) {
        occupancyTimestamp = timestamp;

        if (hasResumed) {
          if (publishers === 0 && hasPublishers) {
            feedbackLoopEmitter.emit(_constants.PUSH_DISCONNECT); // notify(STREAMING_DOWN) in spec
          } else if (publishers !== 0 && !hasPublishers) {
            feedbackLoopEmitter.emit(_constants.PUSH_CONNECT); // notify(STREAMING_UP) in spec
          } // nothing to do when hasResumed === false:
          // streaming is already down for `publishers === 0`, and cannot be up for `publishers !== 0`

        }

        hasPublishers = publishers !== 0;
      }
    },
    handleControlEvent: function handleControlEvent(controlType, channel, timestamp) {
      if (CONTROL_PRI_CHANNEL_REGEX.test(channel) && timestamp > controlTimestamp) {
        controlTimestamp = timestamp;

        if (controlType === _constants.ControlTypes.STREAMING_DISABLED) {
          feedbackLoopEmitter.emit(_constants.PUSH_DISABLED);
        } else if (hasPublishers) {
          if (controlType === _constants.ControlTypes.STREAMING_PAUSED && hasResumed) {
            feedbackLoopEmitter.emit(_constants.PUSH_DISCONNECT); // notify(STREAMING_DOWN) in spec
          } else if (controlType === _constants.ControlTypes.STREAMING_RESUMED && !hasResumed) {
            feedbackLoopEmitter.emit(_constants.PUSH_CONNECT); // notify(STREAMING_UP) in spec
          } // nothing to do when hasPublishers === false:
          // streaming is already down for `STREAMING_PAUSED`, and cannot be up for `STREAMING_RESUMED`

        }

        hasResumed = controlType === _constants.ControlTypes.STREAMING_RESUMED;
      }
    }
  };
}