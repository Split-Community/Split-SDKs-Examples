"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _tape = _interopRequireDefault(require("tape"));

var _fetchMock = _interopRequireDefault(require("../../../__tests__/testUtils/fetchMock"));

var _AuthClient = _interopRequireDefault(require("../../AuthClient"));

var _index = _interopRequireDefault(require("../../../utils/settings/index"));

var _dataMocks = require("../mocks/dataMocks");

var settings = (0, _index.default)({
  core: {
    authorizationKey: 'SDK_KEY'
  }
});
(0, _tape.default)('authenticate', function (t) {
  t.test('success in node (200)', function (assert) {
    _fetchMock.default.getOnce(settings.url('/auth'), function (url, opts) {
      assert.equal(opts.headers['Authorization'], "Bearer ".concat(settings.core.authorizationKey), 'auth request must contain Authorization header with config authorizationKey');
      return {
        status: 200,
        body: _dataMocks.authDataResponseSample
      };
    });

    (0, _AuthClient.default)(settings).then(function (data) {
      assert.deepEqual(data, _dataMocks.authDataSample, 'if success, authorization must return data with token and decoded token');
      assert.end();
    }).catch(function (error) {
      assert.fail(error);
    });
  });
  t.test('success in browser (200)', function (assert) {
    var userKeys = ['emi@split.io', 'maldo@split.io'];

    _fetchMock.default.getOnce(settings.url('/auth?users=emi%40split.io&users=maldo%40split.io'), function (url, opts) {
      assert.equal(opts.headers['Authorization'], "Bearer ".concat(settings.core.authorizationKey), 'auth request must contain Authorization header with config authorizationKey');
      return {
        status: 200,
        body: _dataMocks.authDataResponseSample
      };
    });

    (0, _AuthClient.default)(settings, userKeys).then(function (data) {
      assert.deepEqual(data, _dataMocks.authDataSample, 'if success, authorization must return data with token and decoded token');
      assert.end();
    }).catch(function (error) {
      assert.fail(error);
    });
  });
  t.test('bad request in browser due to no user keys (400)', function (assert) {
    _fetchMock.default.getOnce(settings.url('/auth'), {
      status: 400,
      body: '"no user specified"'
    });

    (0, _AuthClient.default)(settings, []).then(function () {
      assert.fail('if bad request, promise is rejected');
    }).catch(function (error) {
      assert.equal(error.statusCode, 400, 'if bad request, status code is 400');
      assert.end();
    });
  });
  t.test('Invalid credentials (401)', function (assert) {
    _fetchMock.default.getOnce(settings.url('/auth'), {
      status: 401,
      body: '"Invalid credentials"'
    });

    (0, _AuthClient.default)(settings, []).then(function () {
      assert.fail('if invalid credential, promise is rejected');
    }).catch(function (error) {
      assert.equal(error.statusCode, 401, 'if invalid credential, status code is 401');
      assert.end();
    });
  });
  t.test('HTTP error (other than 401)', function (assert) {
    var NOT_OK_STATUS_CODE = 500;

    _fetchMock.default.getOnce(settings.url('/auth'), {
      status: NOT_OK_STATUS_CODE,
      body: 'some error message'
    });

    (0, _AuthClient.default)(settings, []).then(function () {
      assert.fail('if an HTTP error, promise is rejected');
    }).catch(function (error) {
      assert.equal(error.statusCode, NOT_OK_STATUS_CODE, 'if an HTTP error, status code is the HTTP status code');
      assert.end();
    });
  });
  t.test('Network error (e.g., timeout)', function (assert) {
    _fetchMock.default.getOnce(settings.url('/auth'), {
      throws: new TypeError('Network error')
    });

    (0, _AuthClient.default)(settings, []).then(function () {
      assert.fail('if network error, promise is rejected');
    }).catch(function (error) {
      assert.equal(error.statusCode, undefined, 'if network error, status code is `undefined`');
      assert.end();
    });
  });
  t.test('Error parsing token', function (assert) {
    _fetchMock.default.getOnce(settings.url('/auth'), {
      status: 200,
      body: {
        pushEnabled: true,
        token: _dataMocks.jwtSampleInvalid
      }
    });

    _fetchMock.default.getOnce(settings.url('/auth'), {
      status: 200,
      body: {
        pushEnabled: true,
        token: _dataMocks.jwtSampleNoChannels
      }
    });

    _fetchMock.default.getOnce(settings.url('/auth'), {
      status: 200,
      body: {
        pushEnabled: true,
        token: _dataMocks.jwtSampleNoIat
      }
    });

    (0, _AuthClient.default)(settings).then(function () {
      assert.fail('if invalid token, promise is rejected');
    }).catch(function (error) {
      assert.pass(error);
      (0, _AuthClient.default)(settings).then(function () {
        assert.fail('if invalid token, promise is rejected');
      }).catch(function (error) {
        assert.pass(error);
        (0, _AuthClient.default)(settings).then(function () {
          assert.fail('if invalid token, promise is rejected');
        }).catch(function (error) {
          assert.pass(error);
          assert.end();
        });
      });
    });
  });
});