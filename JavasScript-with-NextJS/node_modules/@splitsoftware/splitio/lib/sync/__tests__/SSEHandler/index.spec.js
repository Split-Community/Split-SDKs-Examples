"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _tape = _interopRequireDefault(require("tape"));

var _sinon = _interopRequireDefault(require("sinon"));

var _SSEHandler = _interopRequireDefault(require("../../SSEHandler"));

var _messageSPLIT_UPDATE = _interopRequireDefault(require("../../../__tests__/mocks/message.SPLIT_UPDATE.1457552620999"));

var _messageSPLIT_KILL = _interopRequireDefault(require("../../../__tests__/mocks/message.SPLIT_KILL.1457552650000"));

var _messageSEGMENT_UPDATE = _interopRequireDefault(require("../../../__tests__/mocks/message.SEGMENT_UPDATE.1457552640000"));

var _messageMY_SEGMENTS_UPDATENicolasSplitIo = _interopRequireDefault(require("../../../__tests__/mocks/message.MY_SEGMENTS_UPDATE.nicolas@split.io.1457552640000"));

var _messageOCCUPANCY1Control_pri = _interopRequireDefault(require("../../../__tests__/mocks/message.OCCUPANCY.1.control_pri.1586987434450"));

var _messageOCCUPANCY0Control_pri = _interopRequireDefault(require("../../../__tests__/mocks/message.OCCUPANCY.0.control_pri.1586987434550"));

var _messageOCCUPANCY2Control_pri = _interopRequireDefault(require("../../../__tests__/mocks/message.OCCUPANCY.2.control_pri.1586987434650"));

var _messageCONTROLSTREAMING_PAUSEDControl_pri = _interopRequireDefault(require("../../../__tests__/mocks/message.CONTROL.STREAMING_PAUSED.control_pri.1586987434750"));

var _messageCONTROLSTREAMING_RESUMEDControl_pri = _interopRequireDefault(require("../../../__tests__/mocks/message.CONTROL.STREAMING_RESUMED.control_pri.1586987434850"));

var _messageCONTROLSTREAMING_DISABLEDControl_pri = _interopRequireDefault(require("../../../__tests__/mocks/message.CONTROL.STREAMING_DISABLED.control_pri.1586987434950"));

var _constants = require("../../constants");

// update messages
// occupancy messages
// control messages
(0, _tape.default)('SSEHandler', function (t) {
  var pushEmitter = {
    emit: _sinon.default.stub()
  };
  t.test('`handleOpen` and `handlerMessage` for CONTROL and OCCUPANCY notifications (NotificationKeeper)', function (assert) {
    pushEmitter.emit.resetHistory();
    var sseHandler = (0, _SSEHandler.default)(pushEmitter); // handleOpen

    sseHandler.handleOpen();
    assert.true(pushEmitter.emit.calledOnceWithExactly(_constants.PUSH_CONNECT), 'must emit PUSH_CONNECT');
    sseHandler.handleMessage({
      data: '{ "data": "{\\"type\\":\\"SPLIT_UPDATE\\",\\"changeNumber\\":1457552620999 }" }'
    });
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.SPLIT_UPDATE, 1457552620999), 'must handle update massage if streaming on'); // OCCUPANCY messages

    sseHandler.handleMessage(_messageOCCUPANCY1Control_pri.default);
    assert.equal(pushEmitter.emit.callCount, 2, 'must not emit PUSH_CONNECT if streaming on');
    sseHandler.handleMessage(_messageOCCUPANCY0Control_pri.default);
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.PUSH_DISCONNECT), 'must emit PUSH_DISCONNECT if streaming on and OCCUPANCY 0 in control_pri');
    sseHandler.handleMessage({
      data: '{ "data": "{\\"type\\":\\"SPLIT_UPDATE\\",\\"changeNumber\\":1457552620999 }" }'
    });
    assert.true(pushEmitter.emit.callCount, 3, 'must not handle update massage if streaming off after an OCCUPANCY message');
    sseHandler.handleMessage(_messageOCCUPANCY0Control_pri.default);
    assert.equal(pushEmitter.emit.callCount, 3, 'must not emit PUSH_DISCONNECT if streaming off');
    sseHandler.handleMessage(_messageOCCUPANCY1Control_pri.default);
    assert.true(pushEmitter.emit.callCount, 3, 'must ignore OCCUPANCY message if its timestamp is older');
    sseHandler.handleMessage(_messageOCCUPANCY2Control_pri.default);
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.PUSH_CONNECT), 'must emit PUSH_CONNECT if streaming off and OCCUPANCY mayor than 0 in control_pri');
    sseHandler.handleMessage({
      data: '{ "data": "{\\"type\\":\\"SPLIT_UPDATE\\",\\"changeNumber\\":1457552620999 }" }'
    });
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.SPLIT_UPDATE, 1457552620999), 'must handle update massage if streaming on after an OCCUPANCY event'); // CONTROL messages

    sseHandler.handleMessage(_messageCONTROLSTREAMING_PAUSEDControl_pri.default);
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.PUSH_DISCONNECT), 'must emit PUSH_DISCONNECT if streaming on and received a STREAMING_PAUSED control message');
    sseHandler.handleMessage({
      data: '{ "data": "{\\"type\\":\\"SPLIT_UPDATE\\",\\"changeNumber\\":1457552620999 }" }'
    });
    assert.true(pushEmitter.emit.callCount, 6, 'must not handle update massage if streaming off after a CONTROL message');
    sseHandler.handleMessage(_messageCONTROLSTREAMING_PAUSEDControl_pri.default);
    assert.true(pushEmitter.emit.callCount, 6, 'must not emit PUSH_DISCONNECT if streaming off');
    sseHandler.handleMessage(_messageCONTROLSTREAMING_RESUMEDControl_pri.default);
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.PUSH_CONNECT), 'must emit PUSH_CONNECT if streaming off and received a STREAMING_RESUMED control message');
    sseHandler.handleMessage(_messageCONTROLSTREAMING_RESUMEDControl_pri.default);
    assert.equal(pushEmitter.emit.callCount, 7, 'must not emit PUSH_CONNECT if streaming on');
    sseHandler.handleMessage({
      data: '{ "data": "{\\"type\\":\\"SPLIT_UPDATE\\",\\"changeNumber\\":1457552620999 }" }'
    });
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.SPLIT_UPDATE, 1457552620999), 'must handle update massage if streaming on after a CONTROL event');
    sseHandler.handleMessage(_messageCONTROLSTREAMING_DISABLEDControl_pri.default);
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.PUSH_DISABLED), 'must emit PUSH_DISABLED if received a STREAMING_RESUMED control message');
    var sseHandler2 = (0, _SSEHandler.default)(pushEmitter);
    sseHandler2.handleOpen();
    sseHandler2.handleMessage(_messageCONTROLSTREAMING_PAUSEDControl_pri.default);
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.PUSH_DISCONNECT));
    sseHandler2.handleMessage(_messageCONTROLSTREAMING_DISABLEDControl_pri.default);
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.PUSH_DISABLED), 'must emit PUSH_DISABLED if received a STREAMING_RESUMED control message, even if streaming is off');
    assert.end();
  });
  t.test('`handlerMessage` for update notifications (NotificationProcessor)', function (assert) {
    var _pushEmitter$emit$las, _pushEmitter$emit$las2, _pushEmitter$emit$las3, _pushEmitter$emit$las4;

    var sseHandler = (0, _SSEHandler.default)(pushEmitter);
    sseHandler.handleOpen();
    pushEmitter.emit.resetHistory();
    var expectedParams = [1457552620999];
    sseHandler.handleMessage(_messageSPLIT_UPDATE.default);
    assert.true((_pushEmitter$emit$las = pushEmitter.emit.lastCall).calledWithExactly.apply(_pushEmitter$emit$las, [_constants.SPLIT_UPDATE].concat((0, _toConsumableArray2.default)(expectedParams))), 'must emit SPLIT_UPDATE with the message change number');
    expectedParams = [1457552650000, 'whitelist', 'not_allowed'];
    sseHandler.handleMessage(_messageSPLIT_KILL.default);
    assert.true((_pushEmitter$emit$las2 = pushEmitter.emit.lastCall).calledWithExactly.apply(_pushEmitter$emit$las2, [_constants.SPLIT_KILL].concat((0, _toConsumableArray2.default)(expectedParams))), 'must emit SPLIT_KILL with the message change number, split name and default treatment');
    expectedParams = [1457552640000, 'splitters'];
    sseHandler.handleMessage(_messageSEGMENT_UPDATE.default);
    assert.true((_pushEmitter$emit$las3 = pushEmitter.emit.lastCall).calledWithExactly.apply(_pushEmitter$emit$las3, [_constants.SEGMENT_UPDATE].concat((0, _toConsumableArray2.default)(expectedParams))), 'must emit SEGMENT_UPDATE with the message change number and segment name');
    expectedParams = [{
      type: 'MY_SEGMENTS_UPDATE',
      changeNumber: 1457552640000,
      includesPayload: false
    }, 'NzM2MDI5Mzc0_NDEzMjQ1MzA0Nw==_NTcwOTc3MDQx_mySegments'];
    sseHandler.handleMessage(_messageMY_SEGMENTS_UPDATENicolasSplitIo.default);
    assert.true((_pushEmitter$emit$las4 = pushEmitter.emit.lastCall).calledWithExactly.apply(_pushEmitter$emit$las4, [_constants.MY_SEGMENTS_UPDATE].concat((0, _toConsumableArray2.default)(expectedParams))), 'must emit MY_SEGMENTS_UPDATE with the message parsed data and channel');
    assert.end();
  });
  t.test('handleError', function (assert) {
    var sseHandler = (0, _SSEHandler.default)(pushEmitter);
    sseHandler.handleOpen();
    pushEmitter.emit.resetHistory();
    var error = 'some error';
    sseHandler.handleError(error);
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.SSE_ERROR, error), 'must emit SSE_ERROR with given error');
    var errorWithData = {
      data: '{ "message": "error message"}'
    };
    sseHandler.handleError(errorWithData);
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.SSE_ERROR, {
      data: errorWithData.data,
      parsedData: JSON.parse(errorWithData.data)
    }), 'must emit SSE_ERROR with given error and parsed data');
    var errorWithBadData = {
      data: '{"message"error"'
    };
    sseHandler.handleError(errorWithBadData);
    assert.true(pushEmitter.emit.lastCall.calledWithExactly(_constants.SSE_ERROR, {
      data: errorWithBadData.data
    }), 'must emit SSE_ERROR with given error and not parsed data if cannot be parsed');
    assert.end();
  });
  t.test('handlerMessage: ignore invalid events', function (assert) {
    var sseHandler = (0, _SSEHandler.default)(pushEmitter);
    sseHandler.handleOpen();
    pushEmitter.emit.resetHistory();
    sseHandler.handleMessage('invalid message');
    sseHandler.handleMessage({
      data: '{ data: %invalid json\'\'}'
    });
    assert.true(pushEmitter.emit.notCalled, 'must ignore massage if invalid');
    sseHandler.handleMessage({
      data: '{ "data": "{\\"type\\":\\"UNSUPPORTED_TYPE\\",\\"changeNumber\\":1457552620999 }" }'
    });
    assert.true(pushEmitter.emit.notCalled, 'must ignore massage if it has an invalid type');
    sseHandler.handleMessage({
      data: '{ "data": "{\\"type\\":\\"SPLIT_UPDATE\\",\\"changeNumber\\":1457552620999 }" }'
    });
    assert.true(pushEmitter.emit.calledOnce, 'must handle massage if valid');
    assert.end();
  });
});