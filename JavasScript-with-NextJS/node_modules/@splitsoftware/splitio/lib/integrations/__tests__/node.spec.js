"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _tape = _interopRequireDefault(require("tape"));

var _sinon = _interopRequireDefault(require("sinon"));

var _proxyquire = _interopRequireDefault(require("proxyquire"));

var _constants = require("../../utils/constants");

// Although we are testing integrations/browser.js, this is a "node" test suite
// because we need proxyquire to mock SplitToGa and GaToSplit.
var proxyquireStrict = _proxyquire.default.noCallThru();

var GaToSplitMock = _sinon.default.stub();

var SplitToGaQueueMethod = _sinon.default.stub();

var SplitToGaMock = _sinon.default.stub().callsFake(function () {
  return {
    queue: SplitToGaQueueMethod
  };
});

function resetStubs() {
  GaToSplitMock.resetHistory();
  SplitToGaQueueMethod.resetHistory();
  SplitToGaMock.resetHistory();
} // Import the module, mocking integration modules (GaToSplit and SplitToGa).


var browserIMF = proxyquireStrict('../browser', {
  './ga/GaToSplit': GaToSplitMock,
  './ga/SplitToGa': SplitToGaMock
}).default;

var ContextMock = /*#__PURE__*/function () {
  function ContextMock(fakeStorage, fakeSettings) {
    (0, _classCallCheck2.default)(this, ContextMock);
    this.constants = {
      STORAGE: 'storage',
      SETTINGS: 'settings'
    };
    this.fakeStorage = fakeStorage;
    this.fakeSettings = fakeSettings;
  }

  (0, _createClass2.default)(ContextMock, [{
    key: "get",
    value: function get(target) {
      switch (target) {
        case 'storage':
          return this.fakeStorage;

        case 'settings':
          return this.fakeSettings;

        default:
          break;
      }
    }
  }]);
  return ContextMock;
}();

(0, _tape.default)('IntegrationsManagerFactory for browser', function (t) {
  t.test('API', function (assert) {
    assert.equal((0, _typeof2.default)(browserIMF), 'function', 'The module should return a function which acts as a factory.');
    var contextMock1 = new ContextMock(null, {
      integrations: []
    });
    var instance1 = browserIMF(contextMock1);
    assert.equal(instance1, undefined, 'The instance should be undefined if settings.integrations does not contain integrations that register a listener.');
    var contextMock2 = new ContextMock(null, {
      integrations: [{
        type: _constants.GOOGLE_ANALYTICS_TO_SPLIT
      }, {
        type: _constants.SPLIT_TO_GOOGLE_ANALYTICS
      }]
    });
    var instance2 = browserIMF(contextMock2);
    assert.true(GaToSplitMock.calledOnce, 'GaToSplit invoked once');
    assert.true(SplitToGaMock.calledOnce, 'SplitToGa invoked once');
    assert.equal((0, _typeof2.default)(instance2.handleImpression), 'function', 'The instance should implement the handleImpression method if settings.integrations has items that register a listener.');
    assert.equal((0, _typeof2.default)(instance2.handleEvent), 'function', 'The instance should implement the handleEvent method if settings.integrations has items that register a listener.');
    resetStubs();
    var contextMock3 = new ContextMock(null, {
      integrations: [{
        type: _constants.GOOGLE_ANALYTICS_TO_SPLIT
      }, {
        type: _constants.SPLIT_TO_GOOGLE_ANALYTICS
      }, {
        type: _constants.GOOGLE_ANALYTICS_TO_SPLIT
      }, {
        type: _constants.SPLIT_TO_GOOGLE_ANALYTICS
      }, {
        type: _constants.SPLIT_TO_GOOGLE_ANALYTICS
      }]
    });
    browserIMF(contextMock3);
    assert.true(GaToSplitMock.calledTwice, 'GaToSplit invoked twice');
    assert.true(SplitToGaMock.calledThrice, 'SplitToGa invoked thrice');
    resetStubs();
    assert.end();
  });
  t.test('Interaction with GaToSplit integration module', function (assert) {
    var coreSetting = {
      key: 'emiliano',
      trafficType: 'user'
    };
    var gaToSplitOptions = {
      type: 'GOOGLE_ANALYTICS_TO_SPLIT',
      param1: 'param1',
      param2: 'param2'
    };
    var fakeStorage = 'fakeStorage';
    var contextMock = new ContextMock(fakeStorage, {
      core: coreSetting,
      integrations: [gaToSplitOptions]
    });
    browserIMF(contextMock);
    assert.true(GaToSplitMock.calledOnceWith(gaToSplitOptions, fakeStorage, coreSetting), 'Invokes GaToSplit integration module with options, storage and core settings');
    resetStubs();
    assert.end();
  });
  t.test('Interaction with SplitToGa integration module', function (assert) {
    var splitToGaOptions = {
      type: 'SPLIT_TO_GOOGLE_ANALYTICS',
      param1: 'param1',
      param2: 'param2'
    };
    var contextMock = new ContextMock(null, {
      integrations: [splitToGaOptions]
    });
    var instance = browserIMF(contextMock);
    assert.true(SplitToGaMock.calledOnceWith(splitToGaOptions), 'Invokes SplitToGa integration module with options');
    var fakeImpression = 'fake';
    instance.handleImpression(fakeImpression);
    assert.true(SplitToGaQueueMethod.calledOnceWith({
      payload: fakeImpression,
      type: _constants.SPLIT_IMPRESSION
    }), 'Invokes SplitToGa.queue method with tracked impression');
    resetStubs();
    var fakeEvent = 'fake';
    instance.handleEvent(fakeEvent);
    assert.true(SplitToGaQueueMethod.calledOnceWith({
      payload: fakeEvent,
      type: _constants.SPLIT_EVENT
    }), 'Invokes SplitToGa.queue method with tracked event');
    resetStubs();
    assert.end();
  });
});